                   CON
                   { TODO
                   FORMAT DUMP AS 5 ADDRES - ONLY USE UNDERSCORE IN LONGS AND ' ' ascii
                   
                   COG DUMP   000- B8 E8 AF FD D0 00 90 FD 3C 00 00 00 3B 00 00 00  '........<...;...'
                   
                   Print header string in Ray's header string
                   }
                   
                   ' Ray, Peter, this little 'Load new ROM' routine rewrites the built-in
                   ' ..16KB ROM with what is being assembled into $FC000..$FFFFF. After
                   ' ..running it, you'll have a new ROM. To update the ROM image again,
                   ' ..you'll need to power-cycle the FPGA board to get it to reload the
                   ' ..original image which permits loading the whole 1024KB again.
                   
                   
                   {{ *********************** CHANGELOG **************************
                   
                   '' RR20180512 v134a     Combine: ROM_Booter v33d, LSD_v133i, SD2_133jx, TAQOZ BOOTROM(7)
                   '' CG20180513     c     Update booter
                   '' RR20180513     c_001 Use booter's ao baud value for Monitor
                   ''                  002 Disable interrupts and smart pins on P0 & P1, but don't stop uart
                   ''            v134d
                   ''                ef    Cmd_G coginit if addr $FC000, clockmax=200MHz, add nops/waitx to sendrecv
                   '' may want to change the SD fail destination???
                   PJ20180514 V134e	Implement buffered serial interrupts
                   			^D from TAQOZ switches to DEBUGGER
                   			Add LF to LMM DEBUGGER (CRLF is standard line ending)
                   '' RR20180515 v135b     Add LF in other places; SD cogstop on failure
                   ''                cd    Add load SD file "R"UN; SDinit to check for pullup
                   ''                e     use "." in R<filename> as 8.3; add hubset #1 before cogstop
                   ''		  f     if Sd fails, jmp to shut_down in booter, now does cogid/cogstop
                   ''		        parse R<filename>
                   ''                g     add Chip's latest booter
                   ''                h     Chip's latest; rearrange
                   
                   PBJ180516 v136		Adding in high level SD support, not complete but has virtual SD memory layer.
                   			Can load in full version of Tachyon with SD support using Ray's SD loader
                   			TAQOZ will reboot if four ESCs are entered in sequence (usually I use break detect)
                   
                   PBJ20180516 V136a	Adding in FAT32 sections
                   
                   BIG BUG NOTICE!!! 	SD fail should not stop cog as application may be on Flash - Check Flash before SD
                   
                   
                   **************************************************************** }}
                   
                   
                   '
                   '
                   ' Load new ROM and wait for next reset
                   '
00000 000          dat		org
                   
00000 000 fecfc000 		loc	ptra,#$FC000		'ready to enter new data into rom
                   
00004 001 fac41361 .lp		rdbyte	byte_data,ptra++	'get new rom byte
00008 002 f8d00e09 		setbyte	rom_write,byte_data,#2	'install into command
0000c 003 fd600e00 		hubset	rom_write		'do rom write command
00010 004 f1040e01 		add	rom_write,#1		'inc address in command
00014 005 fb6c11fb 		djnz	byte_count,#.lp		'loop until 16KB loaded into rom
                   
00018 006 fd9ffffc 		jmp	#$			'wait for reset
                   
0001c 007 30000000 rom_write	long	$30000000		'rom write command
00020 008 00004000 byte_count	long	$4000			'number of rom bytes
00024 009          byte_data	res	1			'byte buffer
                   
                   
                   '****************************************
                   '*					*
                   '*	Propeller II ROM Booter		*
                   '*					*
                   '*	5/12/2018 - v32d		*
                   '*					*
                   '****************************************
                   
                   CON
                   	ver		=	"A"		'Prop123-A9 / BeMicro-A9, 8 cogs, 64 smart pins
                   '	ver		=	"B"		'DE2-115
                   '	ver		=	"C"		'DE0-Nano / DE0-Nano Bare
                   '	ver		=	"D"		'BeMicro-A2
                   '	ver		=	"E"		'Prop123-A7
                   '	ver		=	"F"		'Prop123-A9 / BeMicro-A9, 16 cogs, 12 smart pins
                   
                   	rx_pin		=	63		'pin serial receiver
                   	tx_pin		=	62		'pin serial transmitter
                   	spi_cs		=	61		'pin SPI memory select		(also sd_ck)
                   	spi_ck		=	60		'pin SPI memory clock		(also sd_cs)
                   	spi_di		=	59		'pin SPI memory data in		(also sd_di)
                   	spi_do		=	58		'pin SPI memory data out	(also sd_do)
                   	rx_ths		=	1		'pin autobaud time high states
                   	rx_tne		=	0		'pin autobaud time negative edges
                   
                   	cog_spi		=	$000		'cog SPI program start
                   	cog_start	=	$100		'cog code start
                   	cog_base64	=	$1B0		'cog base64 start
                   
                   	lut_buff	=	$000		'lut serial receive buffer
                   	lut_btop	=	$00F		'lut serial receive buffer top
                   	lut_start	=	$010		'lut code start
                   
                   	spi_ok		=	0		'bit flags
                   	cmd_on		=	1
                   
                   	rc_max		=	30_000_000	'max frequency of RC oscillator
                   
                   DAT
                   '
                   '
                   '*******************************************
                   '*  Cog init - overwritten by SPI program  *
                   '*******************************************
                   '
fc000              		orgh	$FC000
fc000 000          		org
                   '
                   '
                   ' Seed xoroshiro 128** using delta-sigma ADC bits from calibration mode
                   '
fc000 000 ff800800 		wrpin	##$00100000,#rx_pin	'put rx pin in adc gio calibration mode
fc004 001 fc0c003f 
                   
fc008 002 f606b632 		mov	x,#50			'ready to seed 50 times with 31 bits
                   
fc00c 003 fcdc041f .seed		rep	#2,#31			'get 31 bits (31*4 clocks = 124/20 = ~6us)
fc010 004 fd747e40 		testp	#rx_pin		wc
fc014 005 f0a6b801 		rcl	y,#1
                   
fc018 006 f426b81f 		bith	y,#31			'seed via hubset
fc01c 007 fd62b800 		hubset	y
                   
fc020 008 fb6eb7fa 		djnz	x,#.seed
                   
fc024 009 fc0c003f 		wrpin	#0,#rx_pin		'return rx pin to normal mode
                   '
                   '
                   ' Move code into position
                   '
fc028 00a fd64b228 		setq	#cog_end-cog_code-1	'move cog code into position
fc02c 00b ff0007e0 		rdlong	cog_start,##@cog_code
fc030 00c fb060134 
                   
fc034 00d fd655829 		setq2	#lut_end-lut_code-1	'move lut code into position
fc038 00e ff0007e1 		rdlong	lut_start,##@lut_code
fc03c 00f fb04209c 
                   '
                   '
                   ' Make 256-byte base64 lookup table
                   '
fc040 010 fd647e28 		setq	#$FF>>2			'reset table in hub
fc044 011 ffffffff 		wrlong	##$FFFFFFFF,#0
fc048 012 fc6ffe00 
                   
fc04c 013 fb4c8233 		callpa	#"A",#fill26		'"A".."Z" --> $00..$19
                   
fc050 014 fb4cc232 		callpa	#"a",#fill26		'"a".."z" --> $1A..$33
                   
fc054 015 f606b60a 		mov	x,#10			'"0".."9" --> $34..$3D
fc058 016 fb4c6031 		callpa	#"0",#fill
                   
fc05c 017 fc4c7c2b 		wrbyte	#$3E,#"+"		'"+" --> $3E
                   
fc060 018 fc4c7e2f 		wrbyte	#$3F,#"/"		'"/" --> $3F
                   
fc064 019 fd647e28 		setq	#$FF>>2			'load table into cog
fc068 01a fb076000 		rdlong	cog_base64,#0
                   '
                   '
                   ' If pull-up on spi_di then do serial
                   '
fc06c 01b fb4c76e4 		callpa	#spi_di,#check_pullup
fc070 01c cd9007d8 	if_c	jmp	#reset_serial
                   '
                   '
                   ' If pull-up on spi_ck (also sd_cs) then try to load from SD card
                   '
fc074 01d fb4c78e2 		callpa	#spi_ck,#check_pullup
fc078 01e cd8fc550 	if_c	jmp	#@_start_sdcard
                   '
                   '
                   ' If no pull-up on spi_cs then do serial
                   '
fc07c 01f fb4c7ae0 		callpa	#spi_cs,#check_pullup
fc080 020 3d9007c8 	if_nc	jmp	#reset_serial
                   '
                   '
                   ' Try to load from SPI memory
                   '
fc084 021 fd647a59 		drvh	#spi_cs			'drive spi_cs high
fc088 022 fd647858 		drvl	#spi_ck			'drive spi_ck low
                   
fc08c 023 f667ee01 		neg	pb,#1			'set command bits to all 1's
fc090 024 fd647459 		drvh	#spi_do			'drive spi_do high in case quad/dual mode
fc094 025 fb4c04e0 		callpa	#2,#spi_cmd		'send exit-quad command
fc098 026 fb4c10df 		callpa	#8,#spi_cmd		'send exit-quad command
fc09c 027 fb4c20de 		callpa	#16,#spi_cmd		'send exit-dual command
fc0a0 028 fd647450 		fltl	#spi_do			'float spi_do
                   
fc0a4 029 fb5cccdb 		callpb	#$66,#spi_cmd8		'send reset-enable command
fc0a8 02a fb5d32da 		callpb	#$99,#spi_cmd8		'send reset command
fc0ac 02b ff800002 		waitx	##rc_max/20_000		'wait 50us
fc0b0 02c fd67b81f 
                   
fc0b4 02d fb5c08d7 		callpb	#$04,#spi_cmd8		'send write-disable command to clear WEL
                   
fc0b8 02e fb5c0ad6 .wait		callpb	#$05,#spi_cmd8		'send read-status command
fc0bc 02f fdb00378 		call	#spi_in			'get status
fc0c0 030 f42eb601 		testbn	x,#1		wz	'if WEL high, no SPI memory
fc0c4 031 5d90003c 	if_nz	jmp	#.float
fc0c8 032 f42eb600 		testbn	x,#0		wz	'if BUSY high, wait for erase/write to finish
fc0cc 033 5d9fffe8 	if_nz	jmp	#.wait
                   
fc0d0 034 f607ec20 		mov	pa,#32			'send read-from-start command
fc0d4 035 fb5c06d0 		callpb	#$03,#spi_cmd
                   
fc0d8 036 f9c6b80a 		decod	y,#10			'ready to input $400 bytes from SPI
fc0dc 037 fc8c0000 		wrfast	#0,#0			'ready to write bytes to hub
fc0e0 038 fdb00354 .data		call	#spi_in			'get byte
fc0e4 039 fd62b615 		wfbyte	x			'store byte into hub
fc0e8 03a fb6eb9fd 		djnz	y,#.data		'loop for next byte (y=0 after)
                   
fc0ec 03b fc7c0000 		rdfast	#0,#0			'ready to read longs from hub
fc0f0 03c fcdc0500 		rep	@.sum,#$100		'ready to read and sum $100 longs
fc0f4 03d fd62ba12 		rflong	z			'read long
fc0f8 03e f102b95d 		add	y,z			'sum long
fc0fc 03f          .sum
fc0fc 03f f20ab949 		cmp	y,csum		wz	'verify checksum, z=1 if okay
                   
fc100 040 a4267c00 	if_z	bith	flags,#spi_ok		'if program verified, set spi_ok flag
                   
fc104 041 5d647a50 .float	if_nz	fltl	#spi_cs			'if no SPI memory or program didn't verify, float SPI pins
fc108 042 5d647850 	if_nz	fltl	#spi_ck
fc10c 043 5d647650 	if_nz	fltl	#spi_di
                   
fc110 044 fd647659 		drvh	#spi_di			'check pull-down on spi_di
fc114 045 fb4c76bb 		callpa	#spi_di,#check_pulldn	'c=0 if pull-down
                   
fc118 046 fd900724 		jmp	#spi_mov		'jump, if z=1 then SPI program, if c=0 then no serial
                   '
                   '
                   ' Fill table
                   '
fc11c 047 f606b61a fill26		mov	x,#26			'ready to fill "A".."Z"/"a".."z" entries
                   
fc120 048 fc8801f6 fill		wrfast	#0,pa			'set table pointer
                   
fc124 049 fcd8055b 		rep	@.v,x			'fill entries with ascending values
fc128 04a fd609815 		wfbyte	.v
fc12c 04b f1049801 		add	.v,#1
                   
fc130 04c 02040000 .v	_ret_	cmp	0,#0			'bottom byte used as a counter
                   
                   
fc134 04d          		fit	cog_start		'make sure below cog code
                   '
                   '
                   '**************
                   '*  Cog code  *
                   '**************
                   '
fc134 100          		org	cog_start
fc134 100          cog_code
                   '
                   '
                   ' Check pin pull-up
                   '
fc134 100 fd63ec58 check_pullup	drvl	pa			'drive pin low
fc138 101 fd643c1f check_pulldn	waitx	#30*1			'wait >1us
fc13c 102 fd63ec50 		fltl	pa			'float pin
fc140 103 fd652c1f 		waitx	#30*5			'wait >5us
fc144 104 0d73ec40 	_ret_	testp	pa		wc	'sample pin
                   '
                   '
                   ' SPI long/byte out
                   '
fc148 105 f607ec08 spi_cmd8	mov	pa,#8			'ready to send 8 bits
                   
fc14c 106 fd647a59 spi_cmd		drvh	#spi_cs			'cs pin high
fc150 107 f027ee18 		rol	pb,#24			'msb-justify byte
fc154 108 fd647a58 		drvl	#spi_cs			'cs pin low
                   
fc158 109 f037ee01 .out		rol	pb,#1		wc	'get bit to send
fc15c 10a fd64765a 		drvc	#spi_di			'drive data-in pin to bit
fc160 10b fd647859 		drvh	#spi_ck			'drive clock pin high
fc164 10c fd647858 		drvl	#spi_ck			'drive clock pin low
fc168 10d 0b6fedfb 	_ret_	djnz	pa,#.out		'loop to output bits, return when done
                   '
                   '
                   ' SPI byte in
                   '
fc16c 10e fcdc0808 spi_in		rep	@.in,#8			'ready to input a byte
fc170 10f fd647859 		drvh	#spi_ck			'drive clock pin high
fc174 110 fd647858 		drvl	#spi_ck			'drive clock pin low
fc178 111 fd747440 		testp	#spi_do		wc	'sample data-out pin ('testp' is from before 'drvh')
fc17c 112 f0a6b601 		rcl	x,#1			'save data bit
fc180 113          .in
fc180 113 fd64002d 		ret
                   '
                   '
                   ' Autobaud ISR - detects initial "> "
                   '
                   '	      falls |--7---|
                   '	 $3E --> ..10011111001..10000001001..
                   '	        highs |-5--|
                   '
fc184 114 fa8ec000 autobaud_isr	rdpin	a0,#rx_tne		'2	get fall-to-fall time	(7x if $3E)
fc188 115 fa8ec201 		rdpin	a1,#rx_ths		'2	get high time		(5x if $3E)
                   
fc18c 116 f292c134 		cmpr	a0,limit	wc	'2	make sure both measurements are within limit
fc190 117 3292c334 	if_nc	cmpr	a1,limit	wc	'2
                   
fc194 118 fa32c135 		scas	a0,norm0		'2	if they are within 1/35th of each other, $3E
fc198 119 3292c200 	if_nc	cmpr	a1,0		wc	'2
fc19c 11a fa32c336 		scas	a1,norm1		'2
fc1a0 11b 3292c000 	if_nc	cmpr	a0,0		wc	'2
fc1a4 11c cb3bfff5 	if_c	reti1				'2/4	if not $3E, exit
                   
fc1a8 11d fb3be9f5 		resi1				'4	got $3E, resume on next interrupt
                   
fc1ac 11e fc0c0200 		akpin	#rx_tne			'2	acknowledge pin
fc1b0 11f fa02c137 		mul	a0,baud0		'2	compute baud rate
fc1b4 120 f8c6c007 		setbyte	a0,#7,#0		'2	set word size to 8 bits
fc1b8 121 fc16c03f 		wxpin	a0,#rx_pin		'2	set receiver baud rate and word size
fc1bc 122 fc16c03e 		wxpin	a0,#tx_pin		'2	set transmitter baud rate and word size
fc1c0 123 fb3be9f5 		resi1				'4	resume on next interrupt
                   
fc1c4 124 fd647e41 		dirh	#rx_pin			'2	enable receiver before next start bit
fc1c8 125 fc067a00 		wrpin	mtpe,#rx_tne		'2	change rx_tne to measure positive edges
fc1cc 126 fd677e20 		setse1	#%110<<6+rx_pin		'2	set se1 to trigger on rx_pin high
fc1d0 127 fb3be9f5 		resi1				'4	resume on next interrupt
                   '
                   '
                   ' Receiver ISR - detects maintenance ">" chrs
                   '
                   '	        rises |--7---|
                   '	 $3E --> ..10011111001..
                   '
fc1d4 128 fa8ec200 		rdpin	a1,#rx_tne		'2	get rise-to-rise time	(7x if $3E)
                   
fc1d8 129 fa9ec43f 		rdpin	a2,#rx_pin	wc	'2	get received chr
fc1dc 12a f046c418 		shr	a2,#32-8		'2	shift to lsb justify
fc1e0 12b f20ec43e 		cmp	a2,#">"		wz	'2	autobaud chr?
fc1e4 12c 5c32c563 	if_nz	wrlut	a2,head			'2	if not, write byte to circular buffer in lut
fc1e8 12d 5706c60f 	if_nz	incmod	head,#lut_btop		'2	..increment buffer head
fc1ec 12e 5b3bfff5 	if_nz	reti1				'2/4	..exit
                   
fc1f0 12f fa02c337 		mul	a1,baud0		'2	autobaud chr, compute baud rate
fc1f4 130 f8c6c207 		setbyte	a1,#7,#0		'2	set word size to 8 bits
fc1f8 131 fc16c23f 		wxpin	a1,#rx_pin		'2	set receiver baud rate and word size
fc1fc 132 fc16c23e 		wxpin	a1,#tx_pin		'2	set transmitter baud rate and word size
fc200 133 fb3bfff5 		reti1				'4	exit
                   
                   
fc204 134 000058e4 limit		long	$58E4				'count limit ($58E4 = 1.3889, keeps SCAS within $7FFF w/norm1)
fc208 135 00002f05 norm0		long	$41D4*5/7			'fall-to-fall normalization factor
fc20c 136 00005c28 norm1		long	$41D4*7/5			'high-time normalization factor ($41D4 = 1.0 + 1/(7*5))
fc210 137 00002492 baud0		long	$1_0000/7			'7x baud computation factor
                   '
                   '
                   ' Constants / initialized variables
                   '
fc214 138 002dc6c0 timeout_per	long	rc_max/10			'100ms timeout for serial receive
fc218 139 00000258 timeout_cnt	long	600				'60s timeout for serial completion
                   
fc21c 13a 0000387c mtxf		long		%111<<11+%01_11110_0	'asynchronous serial transmit, float on high
fc220 13b 60000022 mths		long	%0_110_0_000<<24+%00_10001_0	'time high states on pin[-2] (pin 63 in case of pin 1)
fc224 13c ff000026 mtne		long	%1_111_1_111<<24+%00_10011_0	'time neg edges   on pin[-1] (pin 63 in case of pin 0)
fc228 13d 77000026 mtpe		long	%0_111_0_111<<24+%00_10011_0	'time pos edges   on pin[-1] (pin 63 in case of pin 0)
fc22c 13e 00000000 flags		long	0				'bit flags
                   
fc230 13f 50726f70 text_prop	byte	"porP"				'text
fc234 140 5f43686b text_chk	byte	"khC_"
fc238 141 5f436c6b text_clk	byte	"klC_"
fc23c 142 5f486578 text_hex	byte	"xeH_"
fc240 143 5f547874 text_txt	byte	"txT_"
fc244 144 72500a0d text_ver	byte	13,10,"Prop_Ver ",ver,13,10,0,0
fc254 148 0000002e text_sta	byte	".",0,0,0
                   
fc258 149 706f7250 csum		byte	"Prop"				'checksum
                   
fc25c 14a 00000000 hexchrs		long	%00000000_00000000_00000000_00000000
fc260 14b 03ff0000 		long	%00000011_11111111_00000000_00000000		'"0".."9"
fc264 14c 0000007e 		long	%00000000_00000000_00000000_01111110		'"A".."F"
fc268 14d 0000007e 		long	%00000000_00000000_00000000_01111110		'"a".."f"
fc26c 14e 00000000 		long	%00000000_00000000_00000000_00000000
fc270 14f 00000000 		long	%00000000_00000000_00000000_00000000
fc274 150 00000000 		long	%00000000_00000000_00000000_00000000
fc278 151 00000000 		long	%00000000_00000000_00000000_00000000
                   
fc27c 152 00002600 whitechrs	long	%00000000_00000000_00100110_00000000		'cr, lf, tab
fc280 153 20000001 		long	%00100000_00000000_00000000_00000001		'"=", space
fc284 154 00000000 		long	%00000000_00000000_00000000_00000000
fc288 155 00000000 		long	%00000000_00000000_00000000_00000000
fc28c 156 00000000 		long	%00000000_00000000_00000000_00000000
fc290 157 00000000 		long	%00000000_00000000_00000000_00000000
fc294 158 00000000 		long	%00000000_00000000_00000000_00000000
fc298 159 00000000 		long	%00000000_00000000_00000000_00000000
                   
fc29c 15a          cog_end
                   '
                   '
                   ' Uninitialized variables
                   '
fc29c 15a          i		res	1		'universal
fc29c 15b          x		res	1
fc29c 15c          y		res	1
fc29c 15d          z		res	1
                   
fc29c 15e          checksum	res	1		'checksum
fc29c 15f          bytemask	res	1
                   
fc29c 160          a0		res	1		'serial autobaud/receiver ISR
fc29c 161          a1		res	1
fc29c 162          a2		res	1
                   
fc29c 163          head		res	1		'serial receiver buffer
fc29c 164          tail		res	1
                   
fc29c 165          		fit	cog_base64	'make sure below cog_base64
                   '
                   '
                   '**************
                   '*  Lut code  *
                   '**************
                   '
fc29c 210          		org	$200 + lut_start
fc29c 210          lut_code
                   '
                   '
                   ' If SPI program verified, move into cog $000..$0FF and run it now if spi_di pull-down
                   '
fc29c 210 ad65fe28 spi_mov	if_z	setq	#$FF			'if verified, move SPI program into cog $000..$0FF
fc2a0 211 ab040000 	if_z	rdlong	0,#0
                   
fc2a4 212 3d900244 	if_nc	jmp	#serial_done		'if pull-down on spi_di, boot if SPI okay or shut down
                   '
                   '
                   ' Reset serial autobaud/receiver interrupt
                   '
fc2a8 213 f527f403 reset_serial	andn	dira,#%11		'disable timing measurements for autobaud
                   
fc2ac 214 fd640025 		setint1	#0			'disable int1
                   
fc2b0 215 f606c600 		mov	head,#0			'reset serial buffer pointers
fc2b4 216 f606c800 		mov	tail,#0
                   
fc2b8 217 fd647e40 		dirl	#rx_pin			'disable receiver
fc2bc 218 fc0c7c3f 		wrpin	#%00_11111_0,#rx_pin	'configure rx_pin for asynchronous receive, always input
                   
fc2c0 219 fc0cf83e 		wrpin	#%01_11110_0,#tx_pin	'configure tx_pin for asynchronous transmit, always output
fc2c4 21a fd647c41 		dirh	#tx_pin			'enable transmitter
                   
fc2c8 21b fc067601 		wrpin	mths,#rx_ths		'configure rx_ths for timing high states
                   
fc2cc 21c fc067800 		wrpin	mtne,#rx_tne		'configure rx_tne for timing negative edges
fc2d0 21d fc1c0200 		wxpin	#1,#rx_tne		'report each cycle
fc2d4 21e fc2c0000 		wypin	#0,#rx_tne		'measure fall to fall
                   
fc2d8 21f fd670020 		setse1	#%110<<6+rx_tne		'set se1 to trigger on rx_tne high
                   
fc2dc 220 f607e914 		mov	ijmp1,#autobaud_isr	'set int1 jump vector to autobaud ISR
                   
fc2e0 221 fd640825 		setint1	#4			'set int1 to trigger on se1 (rx_tne high)
                   
fc2e4 222 f547f403 		or	dira,#%11		'enable timing measurements for autobaud
                   '
                   '
                   ' Attempt to get serial command
                   '
fc2e8 223 fd62b61a get_command	getct	x			'reset serial timeout in case SPI program ready
fc2ec 224 fa62b738 		addct1	x,timeout_per
                   
fc2f0 225 f606ba00 		mov	z,#0			'reset string buffer
                   
fc2f4 226 fdb001d4 .byte		call	#get_rx			'get byte
                   
fc2f8 227 f20eb61b 		cmp	x,#$1B		wz	'esc?
fc2fc 228 ad8fcfe2 	if_z	jmp	#@_start_TAQOZ
                   
fc300 229 f20eb604 		cmp	x,#$04		wz	'ctrl-d?
fc304 22a ad8fca5c 	if_z	jmp	#@_start_monitor
                   
fc308 22b f91ab95d 		rolbyte	y,z,#3			'scroll byte into 2-long/8-byte string buffer
fc30c 22c f902bb5b 		rolbyte	z,x,#0
                   
fc310 22d f20ab93f 		cmp	y,text_prop	wz	'"Prop"?
fc314 22e 5d9fffdc 	if_nz	jmp	#.byte
                   
fc318 22f f20abb43 		cmp	z,text_txt	wz	'"_Txt"?
fc31c 230 ad90005c 	if_z	jmp	#command_txt
                   
fc320 231 f20abb42 		cmp	z,text_hex	wz	'"_Hex"?
fc324 232 ad9000b0 	if_z	jmp	#command_hex
                   
fc328 233 f20abb41 		cmp	z,text_clk	wz	'"_Clk"?
fc32c 234 ad900018 	if_z	jmp	#command_clk
                   
fc330 235 f20abb40 		cmp	z,text_chk	wz	'"_Chk"?
fc334 236 5d9fffbc 	if_nz	jmp	#.byte
                   '
                   '
                   ' Command - check device
                   '
fc338 237 fdb000ec command_chk	call	#match_device		'receive and check INA/INB filter values
                   
fc33c 238 f606b544 		mov	i,#text_ver		'transmit version string
fc340 239 fdb001c0 		call	#transmit
                   
fc344 23a fd9fffa0 		jmp	#get_command		'get next command
                   '
                   '
                   ' Command - clock setup
                   '
fc348 23b fdb000dc command_clk	call	#match_device		'receive and check INA/INB filter values
                   
fc34c 23c fdb0011c 		call	#get_hex		'get clock setting
fc350 23d 3d9fff94 	if_nc	jmp	#get_command		'if not hex, error, wait for another command
                   
fc354 23e f606902e 		mov	text_sta,#"."		'transmit acknowledgement character
fc358 23f fdb001a4 		call	#transmit_sta
                   
fc35c 240 f746b618 		zerox	x,#24			'clear non-clock bits
                   
fc360 241 f602b95b 		mov	y,x			'switch to partial setting, but in RC fast mode
fc364 242 f526b803 		andn	y,#%11
fc368 243 fd62b800 		hubset	y
                   
fc36c 244 ff800124 		waitx	##rc_max/200		'wait 5ms
fc370 245 fd67e01f 
                   
fc374 246 fd62b600 		hubset	x			'switch to full setting
                   
fc378 247 fd9fff2c 		jmp	#reset_serial		'restart serial at new setting, get next command
                   '
                   '
                   ' Command - text load
                   '
fc37c 248 fdb000a8 command_txt	call	#match_device		'receive and check INA/INB filter values
                   
fc380 249 f606b400 		mov	i,#0			'reset bit counter
                   
fc384 24a fdb00144 .chr		call	#get_rx			'get byte
                   
fc388 24b f99eb752 		altb	x,#whitechrs		'whitespace?
fc38c 24c f428015b 		testbn	0,x		wz
fc390 24d 5d9ffff0 	if_nz	jmp	#.chr			'if whitespace, get another byte
                   
fc394 24e f96eb7b0 		altgb	x,#cog_base64		'lookup base64 value in table
fc398 24f f8e2b800 		getbyte	y
                   
fc39c 250 f42eb807 		testbn	y,#7		wz	'if msb set, not base64 chr
                   
fc3a0 251 a066ba06 if_z		shl	z,#6			'if base64 chr, shift data buffer up 6 bits
fc3a4 252 a542bb5c if_z		or	z,y			'..or in new value
fc3a8 253 a106b406 if_z		add	i,#6			'..add 6 into bit counter
fc3ac 254 a2f6b408 if_z		cmpsub	i,#8		wc	'..if bit counter >= 8, subtract 8, byte ready
fc3b0 255 8602b75d if_z_and_c	mov	x,z			'....get data buffer value
fc3b4 256 8042b75a if_z_and_c	shr	x,i			'....shift down to justify byte
fc3b8 257 8d62b615 if_z_and_c	wfbyte	x			'....write byte to hub
fc3bc 258 89feb600 if_z_and_c	movbyts	x,#%%0000		'....replicate byte within long
fc3c0 259 8502b75f if_z_and_c	and	x,bytemask		'....mask current byte position
fc3c4 25a 8102bd5b if_z_and_c	add	checksum,x		'....add into checksum
fc3c8 25b 8026be08 if_z_and_c	rol	bytemask,#8		'....update byte position mask
fc3cc 25c ad9fffb4 if_z		jmp	#.chr			'..loop for next chr
                   
fc3d0 25d f726c80f 		decmod	tail,#lut_btop		'not base64 chr, repoint to prior chr
fc3d4 25e fd900020 		jmp	#end_of_data		'done
                   '
                   '
                   ' Command - hex load
                   '
fc3d8 25f fdb0004c command_hex	call	#match_device		'receive and check INA/INB filter values
                   
fc3dc 260 fdb0008c .byte		call	#get_hex		'get hex byte
fc3e0 261 cd62b615 	if_c	wfbyte	x			'if hex, write byte to hub
fc3e4 262 c9feb600 	if_c	movbyts	x,#%%0000		'..replicate byte within long
fc3e8 263 c502b75f 	if_c	and	x,bytemask		'..mask current byte position
fc3ec 264 c102bd5b 	if_c	add	checksum,x		'..add into checksum
fc3f0 265 c026be08 	if_c	rol	bytemask,#8		'..update byte position mask
fc3f4 266 cd9fffe4 	if_c	jmp	#.byte			'..loop for next byte (followed by end_of_data)
                   '
                   '
                   ' End of data for text/hex load - get "~" and launch code
                   '
fc3f8 267 fdb000b4 end_of_data	call	#get_chr		'end of data, check terminus chr
                   
fc3fc 268 f20eb67e 		cmp	x,#"~"		wz	'if "~", run program
fc400 269 ad90001c 	if_z	jmp	#.run
                   
fc404 26a f20eb63f 		cmp	x,#"?"		wz	'if not "?", error, wait for another command
fc408 26b 5d9ffedc 	if_nz	jmp	#get_command
                   
fc40c 26c f56abd49 		xor	checksum,csum	wz	'test checksum
                   
fc410 26d a606902e 	if_z	mov	text_sta,#"."		'(okay)
fc414 26e 56069021 	if_nz	mov	text_sta,#"!"		'(error)
fc418 26f fdb000e4 		call	#transmit_sta		'transmit status character
                   
fc41c 270 fb9ebdb2 		tjnz	checksum,#get_command	'if error, wait for another command
                   
fc420 271 fdb00110 .run		call	#reset_pins		'reset smart pins
                   
fc424 272 fcec0000 		coginit	#0,#$00000		'relaunch cog from $00000
                   '
                   '
                   ' Get and check INA/INB mask and data values
                   '
fc428 273 f4267c01 match_device	bith	flags,#cmd_on		'command on, enable serial timeout for SPI program
                   
fc42c 274 f606b5fe 		mov	i,#ina			'check INA first
                   
fc430 275 fdb00038 .pair		call	#get_hex		'get hex mask
fc434 276 3d9ffeb0 	if_nc	jmp	#get_command		'if not hex, error, wait for another command
fc438 277 f60abb5b 		mov	z,x		wz	'got mask
fc43c 278 5c06743e 	if_nz	wrpin	mtxf,#tx_pin		'if mask non-0, make tx_pin float on high
fc440 279 f996b400 		alts	i			'point to INA/INB
fc444 27a f502bbfe 		and	z,ina			'mask INA/INB
fc448 27b fdb00020 		call	#get_hex		'get hex data
fc44c 27c 3d9ffe98 	if_nc	jmp	#get_command		'if not hex, wait for another command
fc450 27d f20abb5b 		cmp	z,x		wz	'test for match
fc454 27e 5d9ffe90 	if_nz	jmp	#get_command		'if mismatch, wait for another command
                   
fc458 27f f4feb400 		bitnot	i,#0		wcz	'toggle INA/INB pointer
fc45c 280 3d9fffd0 	if_nc	jmp	#.pair			'if INA checked, loop to check INB
                   
fc460 281 f606bc00 		mov	checksum,#0		'reset checksum
fc464 282 f606beff 		mov	bytemask,#$FF		'reset bytemask
                   
fc468 283 0c8c0000 	_ret_	wrfast	#0,#0			'ready to load data bytes into hub
                   '
                   '
                   ' Get hex value, c=1 if hex
                   '
fc46c 284 fdb00040 get_hex		call	#get_chr		'get chr
                   
fc470 285 fdb00024 		call	#.check			'check for hex
fc474 286 3d900018 	if_nc	jmp	#.prior			'if not hex, repoint to chr, c=0
                   
fc478 287 f602b95b 		mov	y,x			'got first hex digit
                   
fc47c 288 fdb00014 .digit		call	#.get			'get any additional hex digits
fc480 289 c882b95b 	if_c	rolnib	y,x,#0
fc484 28a cd9ffff4 	if_c	jmp	#.digit
                   
fc488 28b f602b75c 		mov	x,y			'done, set result
fc48c 28c fd75e06f 		modcz	_set,0		wc	'c=1 for hex
fc490 28d 0726c80f .prior	_ret_	decmod	tail,#lut_btop		'repoint to chr, exit
                   
                   
fc494 28e fdb00034 .get		call	#get_rx			'get byte
fc498 28f f99eb74a .check		altb	x,#hexchrs		'check for hex
fc49c 290 f410015b 		testb	0,x		wc
fc4a0 291 3d64002d 	if_nc	ret				'if not hex, c=0
                   
fc4a4 292 f42eb606 		testbn	x,#6		wz	'hex, "0".."9"?
fc4a8 293 5106b609 	if_nz	add	x,#9			'if not, make $A..$F
fc4ac 294 0506b60f 	_ret_	and	x,#$F			'isolate nibble, c=1
                   '
                   '
                   ' Get chr after any whitespace
                   '
fc4b0 295 fdb00018 get_chr		call	#get_rx			'get byte
                   
fc4b4 296 f99eb752 		altb	x,#whitechrs		'whitespace?
fc4b8 297 f428015b 		testbn	0,x		wz
                   
fc4bc 298 5d9ffff0 	if_nz	jmp	#get_chr		'if whitespace, get another byte
                   
fc4c0 299 fd64002d 		ret
                   '
                   '
                   ' Get serial byte
                   '
fc4c4 29a fd62b61a get_rx_res	getct	x			'reset timer
fc4c8 29b fa62b738 		addct1	x,timeout_per
                   
                   
fc4cc 29c fbcc0204 get_rx		jct1	#.timeout		'timeout?
fc4d0 29d f20ac764 		cmp	head,tail	wz	'byte received?
fc4d4 29e ad9ffff4 	if_z	jmp	#get_rx			'loop until timeout or byte received
                   
fc4d8 29f faa2b764 		rdlut	x,tail			'get byte from circular buffer in lut
fc4dc 2a0 0706c80f 	_ret_	incmod	tail,#lut_btop		'increment buffer tail
                   
                   
fc4e0 2a1 f40e7c00 .timeout	testb	flags,#spi_ok	wz	'timeout, SPI program?
fc4e4 2a2 f4167c01 		testb	flags,#cmd_on	wc	'command on?
fc4e8 2a3 db6e73f6 if_nz_or_c	djnz	timeout_cnt,#get_rx_res	'if no SPI program or command on, try until 60s (serial_done follows)
                   '
                   '
                   ' Serial done
                   ' on entry, z=1 if SPI program
                   '
fc4ec 2a4 fdb00044 serial_done	call	#reset_pins		'reset pins
                   
fc4f0 2a5 ad9ff568 	if_z	jmp	#0			'if SPI program, run it, else shut down
                   
fc4f4 2a6 fd62b601 shut_down	cogid	x			'get cogid (in case jumped to from outside)
fc4f8 2a7 fd640200 		hubset	#1			'set 20KHz oscillator
fc4fc 2a8 fd62b603 		cogstop	x			'shut down cog (floats pins)
                   '
                   '
                   ' Transmit message
                   '
fc500 2a9 f606b548 transmit_sta	mov	i,#text_sta		'point to status character
                   
fc504 2aa f9b6b401 transmit	setd	i,#1			'set auto-increment for altgb
                   
fc508 2ab f602b960 		mov	y,a0			'wait 16 bit periods to allow host turn-around time
fc50c 2ac f046b80e 		shr	y,#16-4+2		'shr 16 gets clocks/bit, -4 gets 16 bits, +2 gets 4 clocks/djnz
fc510 2ad fb6eb9ff 		djnz	y,#$			'y=0 after (djnz allows interrupts, unlike waitx)
                   
fc514 2ae f96ab95a .byte		altgb	y,i			'get next byte of string, increment y
fc518 2af f8e2ba00 		getbyte	z
                   
fc51c 2b0 0b9eba00 	_ret_	tjnz	z,#.send		'if zero, done
                   
fc520 2b1 fc26ba3e .send		wypin	z,#tx_pin		'send byte
                   
fc524 2b2 fd64021f 		waitx	#1			'accommodate wypin -> rdpin latency
                   
fc528 2b3 fa9eba3e .wait		rdpin	z,#tx_pin	wc	'wait for transmit done
fc52c 2b4 cd9ffff8 	if_c	jmp	#.wait
                   
fc530 2b5 fd9fffe0 		jmp	#.byte			'loop for more bytes
                   '
                   '
                   ' Reset smart pins
                   '
fc534 2b6 fd640025 reset_pins	setint1	#0			'disable int1
                   
fc538 2b7 f607f400 		mov	dira,#0			'reset smart pins (avoids output on mode clears)
fc53c 2b8 f747f61d 		zerox	dirb,#29		'..but leave spi pins in current state
                   
fc540 2b9 fc0c0001 		wrpin	#0,#rx_ths		'clear rx_ths mode
fc544 2ba fc0c0000 		wrpin	#0,#rx_tne		'clear rx_tne mode
fc548 2bb fc0c003f 		wrpin	#0,#rx_pin		'clear rx_pin mode
fc54c 2bc 0c0c003e 	_ret_	wrpin	#0,#tx_pin		'clear tx_pin mode
                   
fc550 2bd          lut_end
                   '------------------------------------------------------------------------------------------------
                   
                   
                   
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   
                   CON
                   '------------------------------------------------------------------------------------------------
                     _clockmax	= 200_000_000		     ' max clock freq
                     _clockfreq    = 80_000_000
                     _cpufreq      = _clockmax
                     delay1s       = _cpufreq                   ' 1s  (xtal * pll)
                     delay5us      = _cpufreq / 200_000         ' 5us
                     delay1ms      = _cpufreq / 1_000           ' 1ms
                     _baud         = 115_200
                     _bitper       = (_cpufreq / _baud) << 16 + 7            ' 115200 baud, 8 bits
                     _txmode       = %0000_0000_000_0000000000000_01_11110_0 'async tx mode, output enabled for smart output
                     _rxmode       = %0000_0000_000_0000000000000_00_11111_0 'async rx mode, input  enabled for smart input
                   '------------------------------------------------------------------------------------------------
                           sd_ck           =       spi_cs          'pin SD Card clock
                           sd_cs           =       spi_ck          'pin SD Card select
                           sd_di           =       spi_di          'pin SD Card MOSI
                           sd_do           =       spi_do          'pin SD Card MISO
                   
                   '------------------------------------------------------------------------------------------------
                   '    ASCII equates
                   '------------------------------------------------------------------------------------------------
                   _CLS_     =       $0C     '$00    ' clear screen
                   _BS_      =       $08
                   _LF_      =       $0A
                   _CR_      =       $0D
                   _TAQOZ_   =       $1B     '<esc>  ' <esc>   goto TAQOZ
                   '------------------------------------------------------------------------------------------------
                   
                   '------------------------------------------------------------------------------------------------
                   '               HUB ADDRESSES
                   '------------------------------------------------------------------------------------------------
                     _HUBROM       = $F_C000         ' for ROM $FC000 testing!!!
                     _HUBBUF       = $0_2000 '[128]   ' hub buffer[128] used as default buffer by _HubRxString  (in writable hub ram!!)
                     _HUBBUFSIZE   = 80              ' RxString default size
                     _HUBBUFWORK   = 128-80          ' -unused-
                   '------------------------------------------------------------------------------------------------
                   
                   DAT
                   ''============[ COG VARIABLES - SD BOOT]========================================
fc550 1c0                          org     $1C0              ' place the variables in cog $1C0-$1DF
                   
fc550 1c0          cmdout          res     1                       ' The 8b CMDxx | $40
fc550 1c1          cmdpar          res     1                       ' The 32b parameters
fc550 1c2          cmdcrc          res     1                       ' The 8b CRC (must be valid for CMD0 & CMD8)
fc550 1c3          cmdpar2         res     1                       ' SDV1=$0, SDV2=$40000000
fc550 1c4          cmdtype         res     1                       ' reply is R1=1, R3=3, R7=7, else 0
fc550 1c5          reply           res     1                       ' R1 reply (moved to replyR1 when R3/R7 32b reply here)
fc550 1c6          replyR1         res     1                       ' R1 reply (8b saved when R3/R7 32b reply follows)
fc550 1c7          dataout         res     1                       ' 8/32 bit data being shifted out
fc550 1c8          bytescnt        res     1                       ' #bytes to send/recv
fc550 1c9          bitscnt         res     1                       ' #bits to be shifted in/out
fc550 1ca          ctr1            res     1
fc550 1cb          starttime       res     1
fc550 1cc          duration        res     1
fc550 1cd          skiploading     res     1
                                                                   '\ 1=SDV1, 2=SDV2(byte address), 3=SDHC/SDV2(block address)
fc550 1ce          blocksh         res     1                       '/ block shift 0/9 bits
                   
fc550 1cf          vol_begin       res     1 '$0000_2000           ' Ptn0: first sector of PTN
fc550 1d0          fsi_begin       res     1 '$0000_2001           ' Ptn0:       sector of file system info
fc550 1d1          fat_begin       res     1 '$0000_3122           ' Ptn0: first sector of FAT table
fc550 1d2          dir_begin       res     1' $0000_4000           ' Ptn0: first sector of DATA is DIR table
fc550 1d3          dat_begin       res     1 '$0000_4580 $0000_54C0' Ptn0: first sector of file's DATA
fc550 1d4          ptn_size        res     1 '$0008_0000           '       file-size 32KB = 64<<9 sectors
                   
fc550 1d5          _bufad          res     1
fc550 1d6          _blocknr        res     1
fc550 1d7          _sectors        res     1
fc550 1d8          _entries        res     1
fc550 1d9          bufad           res     1                       ' ptr sector buffer
fc550 1da          blocknr         res     1                       ' sector#
fc550 1db          fname           res     3                       ' 8+3+1
fc550 1de          _unused         res     2
fc550 1e0                          fit     $1E0
                   
                   ''============[ COG VARIABLES - MONITOR]========================================
fc550 1e0                          org     $1E0              ' place the variables in cog $1E0-$1EF
                   ''-------[ LMM parameters, etc ]------------------------------------------------
fc550 1e0          lmm_x           res     1       ' parameter passed to/from LMM routine (typically a value)
fc550 1e1          lmm_f           res     1       ' parameter passed to      LMM routine (function options; returns unchanged)
fc550 1e2          lmm_p           res     1       ' parameter passed to/from LMM routine (typically a hub/cog ptr/addr)
fc550 1e3          lmm_p2          res     1       ' parameter passed to/from LMM routine (typically a 2nd hub/cog address)
fc550 1e4          lmm_c           res     1       ' parameter passed to/from LMM routine (typically a count)
                   ''-------[ LMM additional workareas ]-------------------------------------------
fc550 1e5          lmm_w           res     1       ' workarea (never saved - short term use between calls, except _HubTx)
fc550 1e6          lmm_tx          res     1       ' _HubTx
fc550 1e7          lmm_hx          res     1       ' _HubHex/_HubString
fc550 1e8          lmm_hx2         res     1       ' _HubHex
fc550 1e9          lmm_hc          res     1       '   "
fc550 1ea          lmm_lx          res     1       ' _HubList
fc550 1eb          lmm_lf          res     1       '   "
fc550 1ec          lmm_lp          res     1       '   "
fc550 1ed          lmm_lp2         res     1       '   "
fc550 1ee          lmm_lc          res     1       '   "
fc550 1ef          lmm_bufad       res     1       ' _HubRxString
fc550 1f0                          fit     $1F0
                   ''=======[ ^^^^^ End of COG Variables ^^^^^ ]===================================
                   
                   
                   '' +--------------------------------------------------------------------------+
                   '' | Cluso's Minimal SD Boot Test for P2  (c)2012-2018 "Cluso99" (Ray Rodrick)|
                   '' +--------------------------------------------------------------------------+
                   '' RR20180505 v128a    add into ROM_v131b
                   
                   ''============================[ CON ]============================================================
                   CON
                   
                     _csum    = ("P" + "r"<<8 + "o"<<16 + "p"<<24)  ' "Prop" checksum (reversed)
                     _csum2   = ("P" + "r"<<8 + "o"<<16 + "P"<<24)  ' "ProP" checksum (reversed)
                   
                     _fname1a = ("_" + "B"<<8 + "O"<<16 + "O"<<24)  '\\ filename...
                     _fname1b = ("T" + "_"<<8 + "P"<<16 + "2"<<24)  '||   8.3 +$00
                     _fname1c = ("B" + "I"<<8 + "X"<<16 + $00<<24)  '//
                   
                     _fname2a = ("_" + "B"<<8 + "O"<<16 + "O"<<24)  '\\ filename...
                     _fname2b = ("T" + "_"<<8 + "P"<<16 + "2"<<24)  '||   8.3 +$00
                     _fname2c = ("B" + "I"<<8 + "Y"<<16 + $00<<24)  '//
                   
                     PTN_SECCLU = 64                ' Ptn0 #SectorsPerCluster (assumed 64)
                     mbr_begin  = 0                 ' first sector of disk $0000_0000
                   
                   '------------------------------------------------------------------------------------------------
                   '       COG & LUT & HUB ADDRESSES
                   '------------------------------------------------------------------------------------------------
                     hubdata       = $0_0000        ' expands up   (512byte sectors)
                     max_size      = (512-16)*1024  ' max file_size(bytes) that can be loaded
                   
                     cog_start0    = $000           ' cog code start
                     cog_len       = 512-16         ' cog code length
                     cog_len80     = 512/4          ' 512 bytes (sector)
                   
                   '------------------------------------------------------------------------------------------------
                   ' SD Commands & Responses...
                   '------------------------------------------------------------------------------------------------
                   ' Command             Argument        Response/Data    Description
                     CMD0  = 0  +$40   ' 0               R1       -       GO_IDLE_STATE            *Reqs valid CRC
                     CMD1  = 1  +$40   ' 0               R1       -       SEND_OP_COND
                     ACMD41 = 41 +$40   ' $4000_0000      R1       -       APP_SEND_OP_COND         *Reqs CMD55 first
                     CMD8  = 8  +$40   ' 0               R1+R7    -       SEND_IF_COND             *Reqs valid CRC
                     CMD9  = 9  +$40   ' 0               R1       Y       SEND_CSD
                     CMD10 = 10 +$40   ' 0               R1       Y       SEND_CID
                     CMD12 = 12 +$40   ' 0               R2       -       STOP_TRANSMISSION
                     CMD16 = 16 +$40   ' BlkLen[31:0]    R1       -       SET_BLOCKLEN
                     CMD17 = 17 +$40   ' Addr[31:0]      R1       Y       READ_SINGLE_BLOCK
                     CMD18 = 18 +$40   ' Addr[31:0]      R1       Y       READ_MULTIPLE_BLOCK
                     CMD23 = 23 +$40   ' NoBlks[15:0]    R1       -       SET_BLOCK_COUNT
                     ACMD23 = 23 +$40   ' NoBlks[22:0]    R1       -       SET_WR_BLOCK_ERASE_COUNT *Reqs CMD55 first
                     CMD24 = 24 +$40   ' Addr[31:0]      R1       Y       WRITE_BLOCK
                     CMD25 = 25 +$40   ' Addr[31:0]      R1       Y       WRITE_MULTIPLE_BLOCK
                     CMD55 = 55 +$40   ' 0               R1       -       APP_CMD                  *Prefix for ACMD41/ACMD23
                     CMD58 = 58 +$40   ' 0               R1+R3    -       READ_OCR
                   
                   
                   ' R1 response:  $FF = busy/wait (0-8 bytes?)
                   '               b7: 0 (msb first)
                   '               b6: Parameter Error
                   '               b5: Address Error
                   '               b4: Erase Sequence Error
                   '               b3: Command CRC Error
                   '               b2: Illegal Command
                   '               b1: Erase Reset
                   '               b0: In Idle State
                   ' R1b response: ???
                   ' R3 response:  R1 + OCR(32b)
                   ' R7 response:  R1($01) + 32b(b11..b0 = $1AA = SDC V2 2V7-3V6, else reject)
                   '
                   ' DataPacket:   DataToken(1byte) + DataBlock(1-2048bytes) + CRC(2bytes)
                   '   DataToken:  $FE = CMD17/18/24 (read'1'block/read'n'blocks/write'1'block)
                   '               $FC = CMD25 (write'n'blocks)
                   '               $FD = CMD25 StopToken  (Single byte packet without data or CRC)
                   ' ErrorToken:   Single Byte Reply
                   '               b7-b5: 000
                   '               b4: Card Locked
                   '               b3: Out of Range
                   '               b2: Card ECC failed
                   '               b1: CC Error
                   '               b0: Error
                   ' DataResponse:
                   '               b7-b4: xxx0
                   '               $x5: Data Accepted
                   '               $xB: Data Rejected - CRC Error
                   '               $xD: Data Rejected - Write Error
                   
                   
                   DAT
                   ''################################################################################################
                   ''##    SD Card - HUBEXEC code...                                                               ##
                   ''################################################################################################
fc550                              orgh
                   '+-----------------------------------------------------------------------------+
fc550              _Start_SDcard
fc550     fdbfffe0                 call    #@reset_pins                    ' reset interrupts and pins    <<<<<<<<<<<<<<<<<<<<<<<<<<
                   
fc554     f6079a00                 mov     skiploading,      #0            ' don't skip loading (1 to skip)
fc558     fdb00030                 call    #@_SDcard_Init                  ' initialise & read CSD/CID
fc55c     adb00150         if_e    call    #@readMBR                       ' read MBR/VOL/FSI/FAT
fc560     adb00274         if_e    call    #@readDIR                       ' read directory for filenames
fc564     adb002e0         if_e    call    #@readFILE                      ' read/load/run the file
                   
fc568     fd9fff88 		JMP	#@shut_down			' failed: so shut down
                   '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
                   '+      RUN a file on SD Card             fname = 11 char filename             +
                   '+-----------------------------------------------------------------------------+
fc56c     ff007fff _Run_SDfile     and     fname+2,	##$00FFFFFF	' 12th char must be $00
fc570     f507bbff 
fc574     f6079a01 		mov     skiploading,      #1            ' do not load MBR/VOL code
fc578     fdb00010                 call    #@_SDcard_Init                  ' initialise & read CSD/CID
fc57c     adb00130         if_e    call    #@readMBR                       ' read MBR/VOL/FSI/FAT
fc580     adb00308         if_e    call    #@search_dir                    ' search dir for <fname>
fc584     adb002c0         if_e    call    #@readFILE                      ' read/load/run the file
                   
fc588     fd64002d 		RET 		              ' failed: return to Monitor
                   '+-----------------------------------------------------------------------------+
                   
                   
                   '+-----------------------------------------------------------------------------+
                   '+      SD/SDHC/sdxc SPI Initialisation                                        +
                   '+-----------------------------------------------------------------------------+
                   '+      Send >74 clocks with /CS=1 & DI=1 starting & ending with CLK=0         +
                   '+-----------------------------------------------------------------------------+
fc58c     f607ec3c _SDcard_Init    mov	pa,	#sd_cs	'\ ensure we have an SD card
fc590     fdbffba0 		call    #@check_pullup 			'|   (pullup on cs)
fc594     3d9004b0         if_nc   jmp     #@fail_pullup                   '/ note: uses pa!
                   
fc598     fd647859     		drvh    #sd_cs                          ' cs=1 & output
fc59c     fd647a58                 drvl    #sd_ck                          ' ck=0 & output
fc5a0     fd647659                 drvh    #sd_di                          ' di=1 & output
                   
fc5a4     f60794c0                 mov     ctr1,             #(96*2)
fc5a8     ff800001 .count          waitx   ##delay5us                      '\ 5us+5us (ie 100KHz)
fc5ac     fd67d01f 
fc5b0     fd647a4f                 outnot  #sd_ck                          '| CLK=0-->1-->0
fc5b4     fb6f95fc                 djnz    ctr1,             #.count       '/
fc5b8     ff800001                 waitx   ##delay5us                      '  CLK=0 (idle) & /CS=1
fc5bc     fd67d01f 
                   '+-----------------------------------------------------------------------------+
                   '+ Software Reset:                                                             +
                   '+      CMD0,  PAR=$0,        CRC=$95, REPLY=R1($01)                           +
                   '+-----------------------------------------------------------------------------+
fc5c0     fd63961a .Command0       getct   starttime                       ' timeout up to CMD9
fc5c4     f607940a                 mov     ctr1,             #10           ' try a few times
fc5c8     f6078040 .again0         mov     cmdout,           #CMD0
fc5cc     f6078200                 mov     cmdpar,           #0
fc5d0     f6078495                 mov     cmdcrc,           #$95
                   '+-----------------------------------------------------------------------------+
fc5d4     fdb003b8                 call    #@cmdR1           ' /CS=0, send cmd, recv R1, /CS=1
                   '+-----------------------------------------------------------------------------+
                                                                           '\ $01(idle): SD/MMC, not fully validated
fc5d8     3d900010   if_nc         jmp     #@Command8                      '/ $00(good): (dane card response)
                   '+-----------------------------------------------------------------------------+
fc5dc     ff800001                 waitx   ##delay5us                      ' delay 5us
fc5e0     fd67d01f 
fc5e4     fb6f95f8                 djnz    ctr1,             #.again0      ' n: try again?
fc5e8     fd90045c                 jmp     #@fail00                        '
                   '+=============================================================================+
                   
                   ' we know we now have an SD/MMC card but its not fully validated yet...
                   '+-----------------------------------------------------------------------------+
                   '+ Check Voltage:                                                              +
                   '+      CMD8,  PAR=$1AA,      CRC=$87, REPLY=R1($01)+R7($xx1AA) ($05=try SDV1) +
                   '+-----------------------------------------------------------------------------+
fc5ec     f6078048 Command8        mov     cmdout,           #CMD8
fc5f0     f60783aa                 mov     cmdpar,           #$1AA
fc5f4     f6078487                 mov     cmdcrc,           #$87
                   '+-----------------------------------------------------------------------------+
fc5f8     fdb00394                 call    #@cmdR1R7         ' /CS=0, send cmd, recv R1+R7, /CS=1
                   '+-----------------------------------------------------------------------------+
fc5fc     ed90001c   if_c_or_z     jmp     #.illegal                       ' j if <> $01 (not idle)
fc600     ff000007 .idle           and     reply,            ##$FFF        '\
fc604     f5078bff 
fc608     f20f8baa                 cmp     reply,            #$1AA     wz  '/ R7[11:0]=$1AA ?
fc60c     ff200000                 mov     cmdpar2,          ##$40000000   ' preset for SDV2
fc610     f6078600 
fc614     5d900430   if_ne         jmp     #@fail98                        ' n: unknown R7
fc618     fd90000c                 jmp     #@Command55                     ' y: CMD55+ACMD41($4000_0000)
                   
fc61c     f2078c05 .illegal        cmp     replyR1,          #$05          ' $05(illegal cmd) ?
fc620     5d900424   if_ne         jmp     #@fail08                        ' <>$01/$05 (not idle/illegal)
fc624     f6078600                 mov     cmdpar2,          #0            ' try SDV1
                                                                           ' CMD55+ACMD41($0) fall thru
                   '+-----------------------------------------------------------------------------+
                   '+ Prefix to ACMD41 & ACMD23:                                                  +
                   '+      CMD55, PAR=$0,        CRC=$xx, REPLY=R1($01)                           +
                   '+-----------------------------------------------------------------------------+
fc628              Command55                                               '
fc628     f6078077 .again55        mov     cmdout,           #CMD55        '
fc62c     f6078200                 mov     cmdpar,           #0            '
                   '+-----------------------------------------------------------------------------+
fc630     fdb00354                 call    #@cmdRZA41        ' /CS=0, send cmd, recv R1, /CS=0(ena)
                   '+-----------------------------------------------------------------------------+
fc634     ed900410   if_c_or_z     jmp     #@fail55                        ' <>$01 (not idle)
                                                                           '              fall thru
                   '+-----------------------------------------------------------------------------+
                   '+ Check SDV1/SDV2:  (follows CMD55)                                           +
                   '+     ACMD41, PAR=$0,        CRC=$xx, REPLY=R1($00) SD-V1                     +
                   '+     ACMD41, PAR=$40000000, CRC=$xx, REPLY=R1($00) SD-V2                     +
                   '+-----------------------------------------------------------------------------+
fc638     f6078069 .CommandA41     mov     cmdout,           #ACMD41       '
fc63c     f60383c3                 mov     cmdpar,           cmdpar2       ' SDV1=0 / SDV2=$40000000
                   '+-----------------------------------------------------------------------------+
fc640     fdb0034c                 call    #@cmdR1           ' /CS=0, send cmd, recv R1, /CS=1
                   '+-----------------------------------------------------------------------------+
fc644     1d9fffe0   if_nc_and_nz  jmp     #.again55                       '  =$01(busy): CMD55+CMD41 again
fc648     cd9003fc   if_c          jmp     #@fail41                        ' <>$00/$01: error
                   
fc64c     f20f8600                 cmp     cmdpar2,          #0        wz  ' SDV1 ?
fc650     a6079c09         if_z    mov     blocksh,          #9            ' y: #1 SDV1(byte address)
fc654     ad900020         if_z    jmp     #@Command16                     ' y: SDV1 does not use CMD58
                                                                           ' SDV2         fall thru
                   '+-----------------------------------------------------------------------------+
                   '+ Check OCR CCS bit:                                                          +
                   '+      CMD58, PAR=$0,        CRC=$xx, REPLY=R1($00)+R3(b30=1)                 +
                   '+-----------------------------------------------------------------------------+
fc658     f607807a .Command58      mov     cmdout,           #CMD58        ' SDHC ?
fc65c     f6078200                 mov     cmdpar,           #0            '
                   '+-----------------------------------------------------------------------------+
fc660     fdb0032c                 call    #@cmdR1R3         ' /CS=0, send cmd, recv R1+R3, /CS=1
                   '+-----------------------------------------------------------------------------+
fc664     dd9003e0   if_c_or_nz    jmp     #@fail58                        ' <>$00(good): error
fc668     ff200000                 test    reply,          ##$40000000 wz  ' bit30=CCS=1?
fc66c     f7cf8a00 
fc670     a6079c09         if_z    mov     blocksh,          #9            ' n: #2 SDV2(byte address)
fc674     56079c00         if_nz   mov     blocksh,          #0            ' y: #3 SDHC/SDV2(block address)
                   ''      if_nz   jmp     #@Command9x                     ' y: does not req cmd16?                        ?????????
                                                                           ' SDV2(byte)   fall thru
                   '+-----------------------------------------------------------------------------+
                   '+ Force block size to 512 bytes:                                              +
                   '+      CMD16, PAR=$200,      CRC=$xx, REPLY=R1($00)                           +
                   '+-----------------------------------------------------------------------------+
fc678     f6078050 Command16       mov     cmdout,           #CMD16        ' force blocksize=512bytes
fc67c     ff000001                 mov     cmdpar,           ##512         ' 512 bytes
fc680     f6078200 
                   '+-----------------------------------------------------------------------------+
fc684     fdb00308                 call    #@cmdR1           ' /CS=0, send cmd, recv R1, /CS=1
                   '+-----------------------------------------------------------------------------+
fc688     1d9fffec   if_nc_and_nz  jmp     #@Command16                     '  =$01(idle): again
fc68c     dd9003b8   if_c_or_nz    jmp     #@fail16                        ' <>$00(good): error
                   '+-----------------------------------------------------------------------------+
fc690     ff000000 Command9x       mov     _bufad,           ##hubdata     ' where to store data
fc694     f607aa00 
fc698     f603b3d5                 mov     bufad,            _bufad        ' where to store CSD/CID
                   '+-----------------------------------------------------------------------------+
                   '+ Read CSD register (16 bytes):                                               +
                   '+      CMD9,  PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
                   '+-----------------------------------------------------------------------------+
fc69c     f6078049 Command9        mov     cmdout,           #CMD9         ' read CSD register
fc6a0     fdb002a4                 call    #@readregister                  '
                   '+-----------------------------------------------------------------------------+
                   '+ Read CID register (16 bytes):                                               +
                   '+      CMD10, PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
                   '+-----------------------------------------------------------------------------+
fc6a4     f607804a Command10       mov     cmdout,           #CMD10        ' read CID register
fc6a8     fdb0029c                 call    #@readregister                  '
                   '+-----------------------------------------------------------------------------+
fc6ac     0d6c1e6f         _ret_   modz    _set                      wz    ' "Z" = success
                   '+-----------------------------------------------------------------------------+
                   
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read MBR/VBR (Sector 0):                                                    +
                   '+-----------------------------------------------------------------------------+
fc6b0     ff000000 readMBR         mov     _blocknr,         ##mbr_begin   ' VBR/MBR = SECTOR 0
fc6b4     f607ac00 
fc6b8     fdb00268                 call    #@read_sector                   ' read sector
fc6bc     fd639a31                 skip    skiploading                     ' skips next instr if #1
fc6c0     fdb00154                 call    #@validate_csum                 ' valid -> load & run
                     '+-----------------------------------------------------------------------------+
                     ' Validate MBR (PTN0 table & signature)                                        +
                     '               +$1BE[16]   =         = Ptn0 Table...                          +
                     '       verify  +$1BE+$0[1] = $00/$80 = Ptn0 State                             +
                     '       verify  +$1BE+$4[1] = $0B/$0C = Ptn0 Type                              +
                     '       calc    +$1BE+$8[4] =         = Ptn0 StartSector#    --> vol_begin     +
                     '       calc    +$1BE+$C[4] =         = Ptn0 SectorSize      --> ptn_size      +
                     '       verify  +$1FE[2]    = $55AA   = signature                              +
                     '+-----------------------------------------------------------------------------+
fc6c4     f603b3d5 .validate_mbr     mov     bufad,            _bufad        ' MBR hub addr
fc6c8     f107b3be                   add     bufad,            #$1BE         ' offset to PTN0 table
fc6cc     fac38bd9                   rdbyte  reply,            bufad         ' ptn_state
fc6d0     f5078a7f                   and     reply,            #$7F
fc6d4     f20f8a00                   cmp     reply,            #0        wz  ' $00/80? inactive/active
fc6d8     5d90036c           if_ne   jmp     #@invalid_mbr                   '
fc6dc     f107b204                   add     bufad,            #$4           ' offset to ptn_type
fc6e0     fac38bd9                   rdbyte  reply,            bufad         ' ptn_type
fc6e4     f20f8a0c                   cmp     reply,            #$0C      wz  ' $0C=FAT32(LBA)
fc6e8     520f8a0b           if_ne   cmp     reply,            #$0B      wz  ' $0B=FAT32(<=2TB)
                     ''''    if_ne   cmp     reply,            #$07      wz  ' $07=exFAT             Do not allow!!!
fc6ec     5d900358           if_ne   jmp     #@invalid_mbr                   '
fc6f0     f107b23c                   add     bufad,         #($1FE-$1BE-$4)  ' offset to $55AA signature
fc6f4     fae38bd9                   rdword  reply,            bufad         ' read
fc6f8     ff000055                   cmp     reply,            ##$AA_55  wz  ' we read it reversed!
fc6fc     f20f8a55 
fc700     5d900344           if_ne   jmp     #@invalid_mbr                   '
                   
fc704     f603b3d5                   mov     bufad,            _bufad        ' MBR hub addr
fc708     f107b3be                   add     bufad,            #$1BE         ' offset to PTN0 table
                     '+-----------------------------------------------------------------------------+
                     ' Calculate the raw sector address (LBA) for the VOL sector (vol_begin)...
                     '       vol_begin = LBA begin  ptn0 $1BE+$08[4] (reversed & not long aligned!!!)
                     '+-----------------------------------------------------------------------------+
fc70c     f107b208                   add     bufad,            #$08          ' offset to start sector LBA
fc710     fb039fd9                   rdlong  vol_begin,        bufad         ' read
                     '+-----------------------------------------------------------------------------+
                     ' Calculate the partition size in sectors
                     '       ptn_size = #sectors in ptn0 $1BE+$0C[4] (reversed & not long aligned!!!)
                     '+-----------------------------------------------------------------------------+
fc714     f107b204                   add     bufad,            #($0C-$08)    ' offset to PTN0 size
fc718     fb03a9d9                   rdlong  ptn_size,         bufad         ' read
                     '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read VOL (Sector x):                                                        +
                   '+-----------------------------------------------------------------------------+
fc71c     f603adcf readVOL         mov     _blocknr,         vol_begin     ' VOL SECTOR#
fc720     fdb00200                 call    #@read_sector                   ' read sector
fc724     fd639a31                 skip    skiploading                     ' skips next instr if #1
fc728     fdb000ec                 call    #@validate_csum                 ' valid -> load & run
                     '+-----------------------------------------------------------------------------+
                     ' Validate VOL...                                                              +
                     '       verify  +$00B[2] = 512   = Bytes/Sector                                +
                     '     not chkd  +$00D[1] = 64    = Sectors/Cluster             PTN0SECCLU      +
                     '       calc    +$00E[2]         = #ResvSectors            --> PTN0RESV        +
                     '       verify  +$010[1] = 2     = #NoOfFATs                   PTN0NFATS       +
                     '       ???     +$020[4]         = #Sectors/PTN            --> =ptn_size?      +
                     '       calc    +$024[4]         = #Sectors/FAT            --> PTN0SECFAT      +
                     '       calc    +$030[2]         = #FileSystemInfo         --> fsi_begin       +
                     '       verify  +$1FE[2] = $55AA = signature                                   +
                     '                                                                              +
                     '       calc    fat_begin = vol_begin + PTN0RESV                               +
                     '       calc    dir_begin = fat_begin + (PTN0SECFAT * 2)                       +
                     '+-----------------------------------------------------------------------------+
fc72c     f603b3d5 .validate_vol     mov     bufad,            _bufad        ' VOL hub locn
                   
fc730     f107b20b                   add     bufad,            #$0B          '\ offset to bytes/sector
fc734     fae38bd9                   rdword  reply,            bufad         '| read
fc738     ff000001                   cmp     reply,            ##512     wz  '|
fc73c     f20f8a00 
fc740     5d900304           if_ne   jmp     #@invalid_vol                   '/
                   
fc744     f107b203                   add     bufad,            #($0E-$0B)    ' offset to #ResvSectors
fc748     fae3a3d9                   rdword  fat_begin,        bufad         '\ start of FAT table
fc74c     f103a3cf                   add     fat_begin,        vol_begin     '/
                   
fc750     f107b202                   add     bufad,            #($10-$0E)    '\ offset to #nooffats
fc754     fac38bd9                   rdbyte  reply,            bufad         '| read
fc758     f20f8a02                   cmp     reply,            #2        wz  '| $02   PTN0NFATS
fc75c     5d9002e8           if_ne   jmp     #@invalid_vol                   '/
                   
fc760     f107b214                   add     bufad,            #($24-$10)    ' offset to #Sectors/FAT
fc764     fb03a5d9                   rdlong  dir_begin,        bufad         '\ start of DATA (DIR table)
fc768     f067a401                   shl     dir_begin,        #1            '| *2
fc76c     f103a5d1                   add     dir_begin,        fat_begin     '/ +base
                   
fc770     f107b20c                   add     bufad,            #($30-$24)    ' offset to #FileSystemSector
fc774     fae3a1d9                   rdword  fsi_begin,        bufad         ' read
fc778     f103a1cf                   add     fsi_begin,        vol_begin     ' add vol_begin
                   
fc77c     f107b3ce                   add     bufad,            #($1FE-$30)   ' offset to $55AA signature
fc780     fae38bd9                   rdword  reply,            bufad         ' read
fc784     ff000055                   cmp     reply,            ##$AA_55  wz  ' we read it reversed!
fc788     f20f8a55 
fc78c     5d9002b8           if_ne   jmp     #@invalid_vol                   '
                     '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read FSI (Sector x):                                                        +
                   '+-----------------------------------------------------------------------------+
fc790     f603add0 readFSI         mov     _blocknr,         fsi_begin     ' FSI SECTOR#
fc794     fdb0018c                 call    #@read_sector                   ' read sector
                     '+-----------------------------------------------------------------------------+
                     ' Validate FSI...                                                              +
                     '       verify  +$000[4] = "RRaR" = signature                                  +
                     '       verify  +$1E4[4] = "rrAa" = signature                                  +
                     '       verify  +$1FE[2] = $55AA  = signature                                  +
                     '+-----------------------------------------------------------------------------+
fc798     f603b3d5 .validate_fsi     mov     bufad,            _bufad        ' FSI hub locn
fc79c     fb038bd9                   rdlong  reply,             bufad        ' read
fc7a0     ff20b0a9                   cmp     reply,          ##$41615252 wz  ' "RRaA" signature (reversed)
fc7a4     f20f8a52 
fc7a8     f107b3e4                   add     bufad,            #$1E4         ' offset to signature
fc7ac     fb038bd9                   rdlong  reply,            bufad         ' read
fc7b0     af30a0b9           if_e    cmp     reply,          ##$61417272 wz  ' "rrAa" signature (reversed)
fc7b4     a20f8a72 
fc7b8     f107b21a                   add     bufad,            #($1FE-$1E4)  ' offset to signature
fc7bc     fae38bd9                   rdword  reply,            bufad         ' read
fc7c0     af000055           if_e    cmp     reply,            ##$AA_55  wz  ' $55AA  signature (reversed)
fc7c4     a20f8a55 
fc7c8     5d90027c           if_ne   jmp     #@invalid_fsi                   '
                     '+-----------------------------------------------------------------------------+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read FAT (Sector x):                                                        +
                   '+-----------------------------------------------------------------------------+
fc7cc     f603add1 readFAT         mov     _blocknr,         fat_begin     ' FAT SECTOR#
fc7d0     fdb00150                 call    #@read_sector                   ' read sector
                     '+-----------------------------------------------------------------------------+
                     ' Validate FAT...                                                              +
                     '       nothing to validate                                                    +
                     '+-----------------------------------------------------------------------------+
fc7d4     0d6c1e6f         _ret_   modz    _set                      wz    ' "Z" = success
                   '+-----------------------------------------------------------------------------+
                   
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read DIR (n Sectors):  Search for "<_fname/_fname2>"                        +
                   '+-----------------------------------------------------------------------------+
fc7d8     ff27a7a1 readDIR         mov     fname,            ##_fname1a    ' copy _fname1 -> fname
fc7dc     f607b65f 
fc7e0     ff19282f                 mov     fname+1,          ##_fname1b    '
fc7e4     f607b954 
fc7e8     ff002c24                 mov     fname+2,          ##_fname1c    '
fc7ec     f607bb42 
fc7f0     fdb00098                 call    #@search_dir                    ' search dir for <fname>
fc7f4     ad64002d         if_e    RET                                     ' return "Z" = found
                   
fc7f8     ff27a7a1                 mov     fname,            ##_fname2a    ' copy _fname2 -> fname
fc7fc     f607b65f 
fc800     ff19282f                 mov     fname+1,          ##_fname2b    '
fc804     f607b954 
fc808     ff002ca4                 mov     fname+2,          ##_fname2c    '
fc80c     f607bb42 
fc810     fdb00078                 call    #@search_dir                    ' search dir for <fname2>
fc814     fd64002d                 RET                                     ' return "Z" = found, else "NZ"
                   '+-----------------------------------------------------------------------------+
                   
                   
                   '+-----------------------------------------------------------------------------+
                   ' Validate MBR/VOL CSUM $080-$17F="Prop". If valid, copy to Cog & Run          +
                   '+-----------------------------------------------------------------------------+
fc818     f607b37c validate_csum   mov     bufad,            #$17C         ' check long at $17C
fc81c     fb038bd9                 rdlong  reply,            bufad         '
fc820     ff3837b9                 cmp     reply,            ##_csum   wz  ' ="Prop"?
fc824     f20f8a50 
fc828     ad900050         if_e    jmp     #@success80                     ' y: go load it
fc82c     ff2837b9                 cmp     reply,            ##_csum2  wz  ' ="ProP"? sector/size?
fc830     f20f8a50 
fc834     5d64002d         if_ne   RET                                     ' return "NZ" = not found
fc838     f607b374                 mov     bufad,            #$174         ' get sector start
fc83c     fb03a7d9                 rdlong  dat_begin,        bufad         '
fc840     f607b378                 mov     bufad,            #$178         ' get length(bytes)
fc844     fb03afd9                 rdlong  _sectors,         bufad         ' simulate file found
                   '+-----------------------------------------------------------------------------+
                   '+ Read FILE (n Sectors):  File "<_fname/_fname2>"                             +
                   '+-----------------------------------------------------------------------------+
fc848     f603add3 readFILE        mov     _blocknr,         dat_begin     ' DAT SECTOR#
                   ' convert _sectors = file_size (bytes) into sectors to read
fc84c     ff0003e0                 fle     _sectors,         ##max_size    ' limit max size to load
fc850     f327ae00 
fc854     f107afff                 add     _sectors,         #511          ' +sector if extra bytes
fc858     f047ae09                 shr     _sectors,         #9            ' sectors=file_size/512
                   ' load file's data - multiple sector(s)
fc85c     fdb000c4                 call    #@read_sector                   ' read sector
fc860     fb67ae02                 djz     _sectors,         #success
fc864     fdb000b0 .nextsector     call    #@read_nxtsector                ' read sector(s)
fc868     fb6faffe                 djnz    _sectors,         #.nextsector
                   '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                   ' load Cog & jmp #$000
fc86c     fd67de28 success         setq    #cog_len-1                      ' length -1
fc870     ff000000                 rdlong  cog_start0,       ##hubdata     ' copy loaded code into cog
fc874     fb040000 
fc878     fd800000                 jmp     #$0                             ' execute loaded cog code
                   '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                   ' load cog & jmp #$020
fc87c     fd64fe28 success80       setq    #cog_len80-1                    ' length -1
fc880     ff000000                 rdlong  cog_start0,       ##hubdata     ' copy loaded code into cog
fc884     fb040000 
fc888     fd800020                 jmp     #$020                           ' execute loaded cog code from $080+
                   '+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                   
                   
                   
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Search Directory for <_fname> entry:                                        +
                   '+     returns: "Z",  _sectors = file_size (bytes) if <file> found             +
                   '+             "NZ"                                if <file> not found         +
                   '+-----------------------------------------------------------------------------+
fc88c     f603add2 search_dir      mov     _blocknr,         dir_begin     ' DIR SECTOR#
fc890     ff000000                 mov     _sectors,         ##PTN_SECCLU  ' max sectors to scan (1 cluster)
fc894     f607ae40 
fc898     fdb00088 .search_next    call    #@read_sector                   ' read sector
                     '+-----------------------------------------------------------------------------+
                     ' Walk Directory: (read DIR sectors)                                           +
                     ' 16 x 32byte DIR(fname) entries per DIR sector                                +
                     '               +$00[1] = $00 = empty                                          +
                     '                      => $80 = deleted file                                   +
                     '       search  +$00[11] = 8.3 filename                                        +
                     '       verify  +$0B[1]  = FileAttrib                 AND $D8,check $00        +
                     '          $01=read,02=hidden,04=system,08=volume,0F=longfile,10=dir,20=archive+
                     '       calc    +$14[2]  = FAT32: 1st cluster# HI     -\-> cluster             +
                     '       calc    +$1A[2]  = FAT32: 1st cluster# LO     -/                       +
                     '       calc    +$1C[4]  = FAT32: FileSize in bytes   --> file_size            +
                     '       calc    dat_begin = dir_begin + ((cluster-2)<<6)                       +
                     '+-----------------------------------------------------------------------------+
                     ' scan dir sector for files...
fc89c     f607b010 .walk_dir         mov     _entries,         #16           ' 16*32byte file entries
fc8a0     f603b3d5                   mov     bufad,            _bufad        ' dir hub locn
                     ' scan this sector for filename entry...
fc8a4     fb038bd9 .scan             rdlong  reply,            bufad         '\ check this entry
fc8a8     f20f8a00                   cmp     reply,            #0        wz  '|  $0 = empty?
fc8ac     5d900004           if_ne   jmp     #.check                         '|  n:
fc8b0     0d6c006f         _ret_   modz      _clr                        wz  '/ return "NZ" = not found
                   
fc8b4     f20b8bdb .check            cmp     reply,            fname     wz  '| check fname...
fc8b8     f107b204                   add     bufad,            #4            '|
fc8bc     fb038bd9                   rdlong  reply,            bufad         '|
fc8c0     a20b8bdc           if_e    cmp     reply,            fname+1   wz  '|
fc8c4     f107b204                   add     bufad,            #4            '|
fc8c8     fb038bd9                   rdlong  reply,            bufad         '|
fc8cc     ff6c7fff                   and     reply,            ##$D8FFFFFF   '|  check atts b7+6+4+3
fc8d0     f5078bff 
fc8d4     a20b8bdd           if_e    cmp     reply,            fname+2   wz  '|
fc8d8     ad900010           if_e    jmp     #.found                         '/  found!
fc8dc     f107b218                   add     bufad,            #(32-8)       ' next entry
fc8e0     fb6fb1f0                   djnz    _entries,         #.scan        ' "NZ" not found this sector
                     '+-----------------------------------------------------------------------------+
fc8e4     f107ac01                 add     _blocknr,         #1            ' next sector#
fc8e8     0b6fafeb         _ret_   djnz    _sectors,         #.search_next ' return "NZ" = not found
                   
                     '+-----------------------------------------------------------------------------+
                     ' set:          cluster  = +$14[2] +$1A[2]
                     '               filesize = +$1C[4]
                     '               sector   = ((cluster-2)<<6)+base
                     '                          where <<6 = *sectors/cluster, base=dir_begin
                     '+-----------------------------------------------------------------------------+
fc8ec     f107b20c .found            add     bufad,            #($14-8)      ' ptr to 1st cluster hi
fc8f0     fae3a7d9                   rdword  dat_begin,        bufad         ' read
fc8f4     f067a610                   shl     dat_begin,        #16           ' bytes 3&2
fc8f8     f107b206                   add     bufad,            #($1A-$14)    ' ptr to 1st cluster lo
fc8fc     fae38bd9                   rdword  reply,            bufad         ' read
fc900     f543a7c5                   or      dat_begin,        reply         ' bytes 3-0
                     ' convert to sector#
fc904     f187a602                   sub     dat_begin,        #2            '\ correct cluster addr(-2)
fc908     f067a606                   shl     dat_begin,        #6            '| convert to sector
fc90c     f103a7d2                   add     dat_begin,        dir_begin     '/ +base
                     ' read filesize(bytes)
fc910     f107b202                   add     bufad,            #($1C-$1A)    '\ _sectors <-- filesize
fc914     0b03afd9           _ret_   rdlong  _sectors,         bufad         '/ return "Z" = found
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
                   ' Read Sector:
                   '+-----------------------------------------------------------------------------+
fc918     f107ac01 read_nxtsector  add     _blocknr,         #1            ' next sector#
fc91c     ff000001 read_nxtslot    add     _bufad,           ##512         ' next data slot
fc920     f107aa00 
                   
fc924     f603b5d6 read_sector     mov     blocknr,          _blocknr      ' sector#
fc928     f603b3d5                 mov     bufad,            _bufad        ' where to store data
                      '+-----------------------------------------------------------------------------+
                      '+ Read Block/Sector:  (512 bytes)                                             +
                      '+      CMD17, PAR=blocknr,   CRC=$xx, REPLY=R1($??) +n*$FF +($FE+block+CRC16) +
                      '+-----------------------------------------------------------------------------+
fc92c     ff000001 .Command17         mov     bytescnt,         ##512         ' read block (no. bytes)
fc930     f6079000 
fc934     f6078051                    mov     cmdout,           #CMD17        '
fc938     f60383da                    mov     cmdpar,           blocknr       '
fc93c     f06383ce                    shl     cmdpar,           blocksh       ' <<0 or <<9
                      '+-----------------------------------------------------------------------------+
fc940     fdb0000c                    call    #@readblock                     ' read 512 bytes
                      '+-----------------------------------------------------------------------------+
fc944     fd64002d                 RET                                      ' "Z" = success
                   '+=============================================================================+
                   
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
                   '+ Read Block/Sector:  (512 bytes)                                             +
                   '+      CMD9,  PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
                   '+      CMD10, PAR=$0,        CRC=$xx, REPLY=R1($00)                           +
                   '+      CMD17, PAR=blocknr,   CRC=$xx, REPLY=R1($??) +n*$FF +($FE+block+CRC16) +
                   '+-----------------------------------------------------------------------------+
fc948     f6079010 readregister    mov     bytescnt,         #16     ' CMD9,10: CSD,CID register
fc94c     f6078200                 mov     cmdpar,           #0      '        PAR=$0,      16 bytes
fc950              readblock                                         ' CMD17: PAR=sector, 512 bytes
fc950     fd63961a                 getct   starttime                       ' timeout for cmd9,10,17
                   '+-----------------------------------------------------------------------------+
fc954     fdb00030                 call    #@cmdRZtoken      ' /CS=0, send cmd, recv R1, /CS=0(ena)
                   '+-----------------------------------------------------------------------------+
fc958     5d9000ec         if_nz   jmp     #@fail17                        ' <>$00(good): error
fc95c     fdb00064                 call    #@getreply                      ' n*$FF+$FE
fc960     f20f8afe                 cmp     reply,            #$FE      wz  ' $FE=valid Data Token
fc964     5d9000e0         if_nz   jmp     #@fail97                        '
fc968     fdb000a4 .readbyte       call    #@recvbyte                      ' read data byte
fc96c     fc438bd9                 wrbyte  reply,            bufad         ' save byte
fc970     f107b201                 add     bufad,            #1            ' bufad++
fc974     fb6f91fc                 djnz    bytescnt,         #.readbyte    ' byte--
fc978     fdb00094                 call    #@recvbyte                      ' read CRC16 1/2
fc97c     fdb00090                 call    #@recvbyte                      ' read CRC16 2/2
                   ' NOTE: CRC16 not checked - do we want to do this?                                         ??????????
                   ''              outl    #sd_ck                          ' CLK=0 (idle)          already=0
fc980     fd647849                 outh    #sd_cs                          ' /CS=1 (disable)
fc984     0d6c1e6f         _ret_   modz    _set                        wz  ' "Z" = success
                   '+=============================================================================+
                   
                   
                   '+-----------------------------------------------------------------------------+
                   '+      SEND: CMDx, PARx, CRCx, GET REPLY                                      +
                   '+-----------------------------------------------------------------------------+
fc988              cmdRZA41                                                ' CMD55:       R1 response
fc988              cmdRZtoken                                              ' CMD9,10,17: R1+$FE response
fc988     f6078801                 mov     cmdtype,          #1            ' returns w /CS=0(ena)
fc98c     fd900004                 jmp     #@cmdxx
fc990              CMDR1R3                                                 ' CMD58:    R1+R3 response
fc990              cmdR1R7                                                 ' CMD8:     R1+R7 response
fc990              cmdR1                                                   ' CMD0,A41,16: R1 response
fc990     f6078800                 mov     cmdtype,          #0            ' returns w /CS=1(disabled)
fc994              cmdxx
                   '+-----------------------------------------------------------------------------+
fc994     fd647848                 outl    #sd_cs                          ' /CS=0 (enable)
                   '+-----------------------------------------------------------------------------+
fc998     fdb00074                 call    #@sendFF                        ' send $FF byte first
fc99c     f6038fc0                 mov     dataout,          cmdout        ' CMD
fc9a0     fdb00070                 call    #@sendbyte                      ' send cmd byte
fc9a4     f6038fc1                 mov     dataout,          cmdpar        ' Parameter
fc9a8     fdb0005c                 call    #@sendlong                      ' send 4 bytes (MSB first)
fc9ac     f6038fc2                 mov     dataout,          cmdcrc        ' CRC
fc9b0     fdb00060                 call    #@sendbyte                      ' send crc byte
                   '+-----------------------------------------------------------------------------+
fc9b4     fdb0000c                 call    #@getreply                      ' recv R1/R1+R3/R1+R7/RZ..+Token
                   '+-----------------------------------------------------------------------------+
                   ''              outl    #sd_ck                          ' CLK=0 (idle)           already=0
                                                                           '\ /CS=0 cmdRZA41/cmdRZtoken
fc9b8     fd638831                 skip    cmdtype                         '| skips next instr if #1
fc9bc     fd647849                 outh    #sd_cs                          '/ /CS=1(disable) if reqd
fc9c0     fd64002d               RET
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
                   '+      READ REPLY: R1/R1+R3/R1+R7/R1+token                                    +
                   '+-----------------------------------------------------------------------------+
fc9c4     fdb00048 getreply        call    #@recvbyte                      ' recv R1 byte
fc9c8     f20f8aff                 cmp     reply,            #$FF      wz  ' reply=$FF=busy ?
fc9cc     5d900018         if_nz   jmp     #.doneR1                        ' n:
                   ' starttime set in CMD0(for CMD0,8,55,A41,58,16) and CMD9,10,17(readblock)
fc9d0     fd63981a                 getct   duration                        '\ check timeout ?
fc9d4     f18399cb                 sub     duration,         starttime     '|
fc9d8     ff05f5e1                 cmp     duration,         ##delay1s wc  '|
fc9dc     f2179800 
fc9e0     cd9fffe0         if_c    jmp     #@getreply                      '| n: try again
fc9e4     fd900060                 jmp     #@fail90                        '/ timeout:
                   
fc9e8     f6038dc5 .doneR1         mov     replyR1,          reply         ' save R1/Token reply
                   '+-----------------------------------------------------------------------------+
fc9ec     f20f8048                 cmp     cmdout,           #CMD8     wz
fc9f0     520f807a         if_nz   cmp     cmdout,           #CMD58    wz
fc9f4     5d900004         if_nz   jmp     #.end                           ' ret if not CMD8/CMD58
                   '+-----------------------------------------------------------------------------+
fc9f8     fdb00008                 call    #@recvlong                      ' R7=CMD8=volts/R3=CMD58=OCR
                   '+-----------------------------------------------------------------------------+
fc9fc              .end                                                    '\ returns with...
                                                                           '| nc+z  replyR1=$00(success)
fc9fc     f7cf8c01                 test    replyR1,          #1        wz  '| nc+nz replyR1=$01(idle)
fca00     02978c01         _ret_   cmpr    replyR1,          #$01      wc  '/  c    replyR1>$01(error)
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
                   '+      SD SPI Send/Recv Routines... (write/read byte/long simultaneously)     +
                   '+              /CS=0 & CLK=0 on both entry and exit                           +
                   '+-----------------------------------------------------------------------------+
fca04     f6678e01 recvlong        neg     dataout,          #1            ' call here to Recv a Long (+send 1's)
fca08     f6079220 sendlong        mov     bitscnt,          #32           ' call here to Send a Long (long=32bits)
fca0c     fd90000c                 jmp     #@sendrecv
fca10              sendFF                                                  ' call here to Send $FF Byte
fca10     f6678e01 recvbyte        neg     dataout,          #1            ' call here to Recv a Byte (+send 1's)
fca14     f0278e18 sendbyte        rol     dataout,          #24           ' call here to Send a Byte (msbit first)
fca18     f6079208                 mov     bitscnt,          #8            '                          (byte=8bits)
fca1c     f6078a00 sendrecv        mov     reply,            #0            ' clear reply
fca20     f0378e01 .nextbit        rol     dataout,          #1        wc  ' \ prepare output bit (DI=0/1)..
fca24     fd647a48                 outl    #sd_ck                          ' | CLK=0  (already 0 first time)
fca28     fd64764a                 outc    #sd_di                          ' / write output bit: output on CLK falling edge
fca2c     fd64041f                 waitx   #2                              ' |   setup time to be safe
fca30     fd647a49                 outh    #sd_ck                          ' \ CLK=1
fca34     fd64041f                 waitx   #2                              ' |   setup time to be safe
fca38     fd747440                 testp   #sd_do                      wc  ' | read input bit:   sample on CLK rising edge
fca3c     f0a78a01                 rcl     reply,            #1            ' / accum DO input bits
fca40     fb6f93f7                 djnz    bitscnt,          #.nextbit     '   8/32 bits?
fca44     0d647a48         _ret_   outl    #sd_ck                          ' CLK=0 on exit
                   '+=============================================================================+
                   
                   '+-----------------------------------------------------------------------------+
fca48              fail_pullup     ' #1
fca48              invalid_fat     ' #1
fca48              invalid_fsi     ' #1
fca48              invalid_vol     ' #1
fca48              invalid_mbr     ' #2
fca48              fail98          ' #1
fca48              fail97          ' #7
fca48              fail90          ' #32
fca48              fail58          ' #3
fca48              fail55          ' #14
fca48              fail41          ' #24
fca48              fail17          ' #1
fca48              fail16          ' #8
fca48              fail08          ' #8
fca48              fail00
fca48     0d6c006f         _ret_   modz    _clr                      wz    ' "NZ" = fail
                   '+=============================================================================+
                   
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   
                   '' +--------------------------------------------------------------------------+
                   '' | Cluso's LMM_SerialDebugger for P2    (c)2013-2018 "Cluso99" (Ray Rodrick)|
                   '' +--------------------------------------------------------------------------+
                   '' RR20180512  v133i    LSD_v131i
                   
                   ''============================[ CON ]============================================================
                   CON
                   ''-----------------------------------------------------------------------------------------------
                   ''              LMM DEBUGGER - SUPPORTED COMMANDS
                   ''-----------------------------------------------------------------------------------------------
                   ''  xxxxxx - xx xx xx xx ... <cr>  DOWNLOAD:  to cog/lut/hub {addr1} following {byte(s)}
                   ''  xxxxxx [.xxxxxx] L <cr>        LIST:      from cog/lut/hub {addr1} to < {addr2}
                   ''  xxxxxx G <cr>                  GOTO:      to cog/lut/hub {addr1}
                   ''  Q <cr>                         QUIT:      Quit Rom Monitor and return to the User Program
                   ''  Rffffffffxxx<cr>               RUN:       Run file from SD
                   ''  <esc><cr>                      TAQOZ:     goto TAQOZ
                   ''-----------------------------------------------------------------------------------------------
                   ''              LMM DEBUGGER - CALL Modes...(not all modes supported)
                   ''-----------------------------------------------------------------------------------------------
                     _MODE         = $F << 5                       ' mode bits defining the call b8..b5 (b4..b0 are modifier options)
                     _SHIFT        = 5                             ' shr # to extract mode bits
                     _HEX_         = 2 << 5                        ' hex...
                       _REV_               = 1 << 4                '   - reverse byte order
                       _SP                 = 1 << 3                '   - space between hex output pairs
                      '_DIGITS             = 7..0 where 8->0       '   - no. of digits to display
                     _LIST         = 3 << 5                        ' LIST memory line (1/4 longs) from cog/hub
                       _ADDR2              = 1 << 4                ' 1= use lmm_p2 as to-address
                       _HDG                = 1 << 2                ' 1=display heading for opcode format
                     _TXSTRING     = 4 << 5                        ' tx string (nul terminated) from hub
                     _RXSTRING     = 5 << 5                        ' rx string
                       _ECHO_              = 1 << 4                '    - echo char
                       _PROMPT             = 1 << 3                '    - prompt (lmm_x)
                       _ADDR               = 1 << 2                '    - addr of string buffer supplied
                       _NOLF               = 1 << 1                '    - strip <lf>
                     _MONITOR      = 7 << 5                        ' goto rom monitor
                   '------------------------------------------------------------------------------------------------
                   
                   
                   DAT
                   ''################################################################################################
                   ''##    LMM Monitor - HUBEXEC code...                                                           ##
                   ''################################################################################################
fca4c                              orgh
                   
                   ''-----------------------------------------------------------------------------------------------
                   ''	RESET BOOTER SERIAL INTERRUPTS & AUTOBAUD - KEEP SMART UART RUNNING
                   ''-----------------------------------------------------------------------------------------------
fca4c     fd640025 _reset_booter   setint1 #0                              ' disable int1
fca50     f527f403                 andn    dira,#3                         ' reset smart pins on P0 & P1
fca54     fc0c0001                 wrpin   #0,#rx_ths                      ' clear P1 rx_ths mode
fca58     0c0c0000         _ret_   wrpin   #0,#rx_tne                      ' clear P0 rx_tne mode
                   ''-----------------------------------------------------------------------------------------------
                   
                   
                   ''-------[ Start Monitor ]----------------------------------------------------- <--- start monitor --->
fca5c     fdbfffec _Start_Monitor  call    #@_reset_booter                 ' reset the booters interrupts and autobaud
                   
fca60     ff000010 _Enter_Monitor  mov       lmm_bufad,      ##_HUBBUF     ' addr of hub buffer (_HubRxString)
fca64     f607de00 
                   
fca68     f607c00d                 mov     lmm_x,            #_CR_         ' we have to prime send buffer empty flag,
fca6c     fc27c03e                 wypin   lmm_x,            #tx_pin       ' ... so send <cr> to tx pin
                   ''---------------------------------------------------------------------------------------------------
                   ' this code displays a version string (it's not required)
fca70     fdb000fc _Redo_Monitor   call      #_HubTxStrVer                   ' send version string
                   ''---------------------------------------------------------------------------------------------------
                   ' call the Monitor (because we need a return address set)
fca74     fdb00348 .monitor      call      #_HubMonitor                    ' to the monitor/debugger
fca78     fd9ffff8               jmp       #.monitor                       ' loop back in case of "Q<cr>"
                   ''---------------------------------------------------------------------------------------------------
                   
                   
                   ''-------[ Serial Routines (uses SmartPins) ]---------------------------------- <--- serial initialise --->
                   ''_SerialInit
                   '' On Entry:
                   ''      lmm_x     = _bitper                             ' tx & rx bit period + #(bits-1)
                   ''      lmm_bufad = 'bufad'                             ' hubbuf addr (_HubRxString)
                   '' Call Format:
                   ''            CALL      #_SerialInit                    '                       < call: serial initilise>
                   '' On Return:
                   ''      lmm_x = #CR                                     ' (changed)
                   ''--------------------------------------------------------------------------------------------------
fca7c     ff000010 _SerialAddr     mov     lmm_bufad,        ##_HUBBUF     ' addr of hub buffer (_HubRxString)
fca80     f607de00 
fca84     ff036400 _SerialBaud     mov     lmm_x,            ##_bitper     ' 115200 baud, 8 bits
fca88     f607c007 
fca8c     ff800000 _SerialInit     wrpin   ##_txmode,        #tx_pin       ' set asynchronous tx mode in smart pin tx
fca90     fc0cf83e 
fca94     fc17c03e                 wxpin   lmm_x,            #tx_pin       ' set tx bit period + #(bits-1)
fca98     fd647c41                 dirh    #tx_pin                         ' enable smart pin tx
                   
fca9c     ff800000                 wrpin   ##_rxmode,        #rx_pin       ' set asynchronous rx mode in smart pin rx
fcaa0     fc0c7c3f 
fcaa4     fc17c03f                 wxpin   lmm_x,            #rx_pin       ' set rx bit period + #(bits-1)
fcaa8     fd647e41                 dirh    #rx_pin                         ' enable smart pin rx
                   
fcaac     f607c00d                 mov     lmm_x,            #_CR_         ' we have to prime send buffer empty flag,
fcab0     fc27c03e                 wypin   lmm_x,            #tx_pin       ' ... so send <cr> to tx pin
                   
                                 ''''waitx     ##delay1ms                      ' ??? required                     <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<???
fcab4     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''--------------------------------------------------------------------------------------------------
                   
                   
                   ''-------[ Display Char(s) ]--------------------------------------------------- <--- display char(s) --->
                   ''_HubTx                                                '
                   '' On Entry:
                   ''      lmm_x = char(s)                                 ' char(s): up to 4 chars; B0 first; <nul> terminates
                   ''                                                      '            if =$0, tx one <nul>
                   '' Call Format:
                   ''            CALL      #_HubTx                         '                       < call: display char(s)>
                   '' On Return:
                   ''      lmm_x = -same-                                  ' char(s):  (unchanged)
                   ''--------------------------------------------------------------------------------------------------
fcab8     ff068500 _HubTxCR        mov     lmm_x, ##(_CR_<<24+_LF_<<16)    ' <cr><lf>
fcabc     f607c000 
fcac0     f9ffc01b _HubTxRev       movbyts lmm_x, #%%0123                  ' reversed
fcac4              _HubTx                                                  '                       <--- display char(s) --->
fcac4     f603cbe0               MOV       lmm_w, lmm_x                    '                       < push: 'x'    #0 >
                   '               ----------------------------------------
fcac8     fd747c40 .send           testp   #tx_pin                 wc      ' wait for buffer empty on tx pin
fcacc     3d9ffff8         if_nc   jmp     #.send                          '
fcad0     fc27c03e                 wypin   lmm_x, #tx_pin                  ' send byte (bits7:0) to tx pin
                   
fcad4     f04fc008                 shr     lmm_x, #8               wz      ' any more chars to send?
fcad8     5d9fffec         if_nz   jmp     #.send                          '> br back:  (nz = another char in lmm_x)
                   '               ----------------------------------------
fcadc     f603c1e5               MOV       lmm_x, lmm_w                    '                       < pop:  'x'    #0 >
fcae0     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   '---------------------------------------------------------------------------------------------------
                   
                   
                   ''-------[ Rx: Receive a char ]------------------------------------------------ <--- receive char --->
                   ''_HubRx
                   '' On Entry:
                   ''      lmm_x = -anything-                              ' value:
                   '' Call Format:
                   ''             CALL     #_HubRx                         '                       < call: receive char>
                   '' On Return:
                   ''      lmm_x = char                                    ' char:   input char
                   ''--------------------------------------------------------------------------------------------------
fcae4              _HubRx                                                  '                       <--- receive char --->
fcae4     fd747e40 .recv           testp   #rx_pin                 wc      ' char ready?
fcae8     3d9ffff8         if_nc   jmp     #.recv                          '
fcaec     fa8fc03f                 rdpin   lmm_x,            #rx_pin       ' recv byte (bits31:24) from rx pin
fcaf0     f047c018                 shr     lmm_x,            #24           ' shift rx bits
fcaf4     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   '---------------------------------------------------------------------------------------------------
                   
                   
                   ''-------[ Display Hex ]------------------------------------------------------- <--- display hex --->
                   ''_HubHex                                               '
                   '' On Entry:
                   ''      lmm_f = _HEX_ [+options]                        ' mode:  #_HEX_[+_REV_][+_SP][+_ndigits]
                   ''                                                      '        'n' digits = 7..0 where 0 = 8 digits
                   ''      lmm_x = char(s)                                 ' char(s):
                   '' Call Format:
                   ''            CALL      #_HubHex                        '                       < call: display hex >
                   '' On Return:
                   ''      lmm_f = -same-                                  ' mode:     (unchanged)
                   ''      lmm_x = -same-                                  ' char(s):  (unchanged)
                   ''--------------------------------------------------------------------------------------------------
fcaf8     f9ffc01b _HubHexRev      movbyts lmm_x, #%%0123                  ' reversed
fcafc     f607c240 _HubHex8        mov     lmm_f, #_HEX_+0                 ' 8 digits
fcb00              _HubHex                                                 '                       <--- display hex --->
fcb00     f603cfe0               MOV       lmm_hx, lmm_x                   '                       < push: 'x'    #0 >
fcb04     f603d3e4               MOV       lmm_hc, lmm_c                   '                       < push: 'c'    #1 >
                   '               ----------------------------------------
fcb08     f7cfc210                 test    lmm_f, #_REV_            wz      '  reverse mode?
fcb0c     59ffc01b         if_nz   movbyts lmm_x, #%%0123                  '  y: reverse bytes
fcb10     f603c9e1                 mov     lmm_c, lmm_f                    '\ CTR = ...
fcb14     f50fc807                 and     lmm_c, #7               wz      '|   ... 'n' digits ...
fcb18     a607c808         if_z    mov     lmm_c, #8                       '/   ... if 0, then 8
fcb1c     f607ca08                 mov     lmm_w, #8                       '\ nibbles to...
fcb20     f18bcbe4                 sub     lmm_w, lmm_c            wz      '|   ...     ...
fcb24     5067ca02         if_nz   shl     lmm_w, #2                       '|   ... *4  ...
fcb28     5023c1e5         if_nz   rol     lmm_x, lmm_w                    '/   ... discard
                   '               ----------------------------------------
fcb2c     f027c004 .next           rol     lmm_x, #4                       '\  next nibble  ...
fcb30     f603d1e0               MOV       lmm_hx2, lmm_x                  '|   ... save    ...    < push: 'x'    #2 >
fcb34     f507c00f                 and     lmm_x, #$0F                     '|   ... extract ...
fcb38     f547c030                 or      lmm_x, #"0"                     '|   ... convert ...
fcb3c     f217c03a                 cmp     lmm_x, #":"             wc      '|   ...         ...
fcb40     3107c007         if_nc   add     lmm_x, #("A"-"9"-1)             '/   ... now 0-9,A-F
fcb44     fdbfff7c               CALL      #_HubTx                         '                       < call: display char(s)>
                   '               ----------------------------------------
fcb48     f7cfc208                 test    lmm_f, #_SP             wz      ' hex space mode?
fcb4c     f7d7c801                 test    lmm_c, #1               wc      ' c if odd count
fcb50     bd900008    if_z_or_nc   jmp     #.nospace                       '> br: (no space reqd)
fcb54     f607c020                 mov     lmm_x, #" "                     ' " "
fcb58     fdbfff68               CALL      #_HubTx                         '                       < call: transmit char(s)>
                   '               ----------------------------------------
fcb5c              .nospace
fcb5c     f603c1e8               MOV       lmm_x, lmm_hx2                  '    ... restore ...    < pop:  'x'    #2 >
fcb60     fb6fc9f2                 djnz    lmm_c, #.next                   '> CTR--
                   '               ----------------------------------------
fcb64     f603c9e9               MOV       lmm_c, lmm_hc                   '                       < pop:  'c'    #1 >
fcb68     f603c1e7               MOV       lmm_x, lmm_hx                   '                       < pop:  'x'    #0 >
fcb6c     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   '------------------------------------------------------------------------------
                   
                   
                   ''-------[ Display String, <nul> terminated ]---------------------------------- <--- display string --->
                   ''_HubTxString                                          '
                   '' On Entry:
                   ''      lmm_f = #_TXSTRING [+options]                   ' mode:   #_TXSTRING
                   ''      lmm_p = 'addr'                                  ' addr:   string (hub ptr)
                   '' Call Format:
                   ''            CALL      #_HubTxString                   '                       < call: display string>
                   '' On Return:
                   ''      lmm_f = -same-                                  ' mode:   (unchanged)
                   ''      lmm_p = 'addr' (next string)                    ' addr:   (hub ptr to next string)
                   ''--------------------------------------------------------------------------------------------------
fcb70     ff0007e7 _HubTxStrVer  mov       lmm_p,            ##_str_vers   ' send version string, $00 terminated
fcb74     f607c5d0 
fcb78              _HubTxString                                            '                       <--- display string --->
fcb78     f603cfe0               MOV       lmm_hx, lmm_x                   '                       < push: 'x'    #0 >
                   '               ----------------------------------------
fcb7c     facbc1e2 .loop           rdbyte  lmm_x, lmm_p            wz      ' get char from string: nul?
fcb80     f107c401                 add     lmm_p, #1                       ' PTR++
fcb84     ad900008         if_z    jmp     #.return                        '> br fwd:              (returns to calling program)
fcb88     fdbfff38               CALL      #_HubTx                         '                       < call: transmit char(s)>
fcb8c     fd9fffec                 jmp     #.loop                          '  br back
                   '               ----------------------------------------
fcb90              .return
fcb90     f603c1e7               MOV       lmm_x, lmm_hx                   '                       < pop:  'x'    #0 >
fcb94     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   '------------------------------------------------------------------------------
                   
                   
                   ''-------[ LIST a line ]------------------------------------------------------- <--- LIST a line --->
                   ''_HubList
                   '' On Entry:
                   ''      lmm_f   = #_LIST [+options]                     ' mode:         _LIST[+_ADDR2][+_HDG]
                   ''      lmm_p   = 'addr'        (from)                  ' addr:    from cog addr / hub ptr
                   ''      lmm_p2  = 'addr2'       (to)    (optional)      ' addr2:   to   cog addr / hub ptr (if _ADDR2 specified)
                   '' Call Format:
                   ''             CALL     #_HubList                       '                       < call: LIST a line >
                   '' On Return:
                   ''      lmm_f   = same except _HDG off                  ' mode:    same except _HDG will be off
                   ''      lmm_p   = addr++        (from)                  ' addr:    next from cog addr / hub ptr
                   ''      lmm_p2  = addr2++/same  (to)                    ' addr2:   next to addr -OR- unchanged
                   ''---------------------------------------------------------------------------------------------------
fcb98     f607c274 _HubListA2H     mov     lmm_f,  #_LIST+_ADDR2+_HDG      ' list count w heading
fcb9c              _HubList                                                '                       <--- LIST a line --->
                   ' ===LIST LINE(S)===
fcb9c     f603d5e0               MOV       lmm_lx, lmm_x                   '\ save params
fcba0     f603d7e1               MOV       lmm_lf, lmm_f                   '|
fcba4     f603d9e2               MOV       lmm_lp, lmm_p                   '|
fcba8     f603dbe2               MOV       lmm_lp2,lmm_p                   '|   orig {addr}
fcbac     f603dde4               MOV       lmm_lc, lmm_c                   '/
                   ' addr2 mode ?
fcbb0     f7cfc210                 test    lmm_f, #_ADDR2          wz      ' nz if addr2 mode
fcbb4     a603c7e2         if_z  MOV       lmm_p2, lmm_p                   ' n: replace {addr2} <-- {addr}
                   '               ----------------------------------------
                   ' ===DISPLAY HDG ?===
fcbb8     f7cfc204                 test    lmm_f, #_HDG            wz      ' heading?
fcbbc     ad900054         if_z    jmp     #_HubListLoop                   ' n:
fcbc0     ff323230                 mov     lmm_x, ##(" "+"a"<<8+"d"<<16+"d"<<24)
fcbc4     f607c120 
fcbc8     fdbffef8               CALL      #_HubTx
fcbcc     ff101016                 mov     lmm_x, ##("r"+"-"<<8+" "<<16+" "<<24)
fcbd0     f607c172 
fcbd4     fdbffeec               CALL      #_HubTx
fcbd8     f607c810                 mov     lmm_c, #16
fcbdc     ff001010                 mov     lmm_x, ##("0"+" "<<8+" "<<16)
fcbe0     f607c030 
fcbe4     fdbffedc .hdg1         CALL      #_HubTx
fcbe8     f107c001                 add     lmm_x, #1                       ' 0..9
fcbec     ff001010                 cmp     lmm_x, ##(":"+" "<<8+" "<<16) wz
fcbf0     f20fc03a 
fcbf4     a107c007         if_e    add     lmm_x, #7                       ' : -> A
fcbf8     fb6fc9fa                 djnz    lmm_c, #.hdg1
fcbfc     fdbffeb8               CALL      #_HubTxCR
fcc00     f607c836                 mov     lmm_c, #54
fcc04     f607c02d                 mov     lmm_x, #"-"
fcc08     fdbffeb8 .hdg2         CALL      #_HubTx
fcc0c     fb6fc9fe                 djnz    lmm_c, #.hdg2
fcc10     fdbffea4               CALL      #_HubTxCR
                   '               ----------------------------------------
                   ' ===LOOPS HERE FOR MULTIPLE LINES===
fcc14              _HubListLoop
                   '               ----------------------------------------
                   ' ===DISPLAY LINE: ADDR===
fcc14     f603c5ec               MOV       lmm_p, lmm_lp                   ' restore 'addr'
fcc18     ff000001                 cmp     lmm_p, ##$3FF           wcz     ' z|c if =<$3FF = cog/lut mode?
fcc1c     f21fc5ff 
                   ' cog:
fcc20     ef000010         if_be   mov     lmm_x, ##(" "+" "<<8)           ' "  "
fcc24     e607c020 
fcc28     edbffe98         if_be CALL      #_HubTx                         '                       < call: transmit char(s) >
fcc2c     e607c243         if_be   mov     lmm_f, #_HEX_+3                 ' set hex mode with 3 digits
                   ' hub:
fcc30     1607c245         if_a    mov     lmm_f, #_HEX_+5                 ' set hex mode with 5 digits
                   ' display address
fcc34     f603c1e2                 mov     lmm_x, lmm_p                    ' set cog/hub address (for displaying)
fcc38     fdbffec4               CALL      #_HubHex                        '                       < call: display hex >
fcc3c     ff000010                 mov     lmm_x, ##("-"+" "<<8)           ' "- "
fcc40     f607c02d 
fcc44     fdbffe7c               CALL      #_HubTx                         '                       < call: transmit char(s) >
                   '               ----------------------------------------
                   ' ===DISPLAY 4x HEX LONGS===
                   ' lmm_p = ptr to 1st long
fcc48     f607c258                 mov     lmm_f, #_HEX_+_REV_+_SP+0       ' set hex reversed space mode with 8(=0) digits
fcc4c     f607c804                 mov     lmm_c, #4                       ' set 4 longs
                   ' read a long from cog/hub into lmm_x pointed to by lmm_p and inc lmm_p
fcc50     fdb00090 .long4        CALL      #_RdLongCogHub                  '                       < call: read cog/hub long >
fcc54     fdbffea8               CALL      #_HubHex                        '                       < call: display hex>
fcc58     fb6fc9fd                 djnz    lmm_c, #.long4                  ' (4 longs)--
                   '               ----------------------------------------
                   ' ===DISPLAY ASCII===
fcc5c     f607c804                 mov     lmm_c, #4                       ' set 4 longs
fcc60     f603c5ec               MOV       lmm_p, lmm_lp                   ' restore 'addr'
                   '               ------------------------
                   ' lmm_p = ptr to 1st long
fcc64     ff000013                 mov     lmm_x, ##(" "+"'"<<8)           ' " '"
fcc68     f607c120 
fcc6c     fdbffe54               CALL      #_HubTx                         '                       < call: transmit char(s) >
                   '               ------------------------
                   ' read a long from cog/hub into lmm_x pointed to by lmm_p and inc lmm_p
fcc70     fdb00070 .asciiloop    CALL      #_RdLongCogHub                  '                       < call: read cog/hub long >
                   ' convert 4 bytes to visible
fcc74     f607c204                 mov     lmm_f, #4                       ' (lmm_f as temp byte counter)
fcc78     f603cbe0 .convert        mov     lmm_w, lmm_x                    ' duplicate
fcc7c     f527c0ff                 andn    lmm_x, #$FF                     ' clear   lower byte
fcc80     f507caff                 and     lmm_w, #$FF                     ' extract lower byte
fcc84     f217ca20                 cmp     lmm_w, #" "             wc      ' c if <$20: invisible?
fcc88     c607ca2e         if_c    mov     lmm_w, #"."                     ' y: replace
fcc8c     f217ca7f                 cmp     lmm_w, #$7F             wc      ' c if <$7F: visible?
fcc90     3607ca2e         if_nc   mov     lmm_w, #"."                     ' n: replace
fcc94     f543c1e5                 or      lmm_x, lmm_w                    ' replace lower byte
fcc98     f007c008                 ror     lmm_x, #8                       ' next byte
fcc9c     fb6fc3f6                 djnz    lmm_f, #.convert                ' (lmm_f as temp byte counter)
fcca0     fdbffe20               CALL      #_HubTx                         ' 4 ascii bytes         < call: transmit char(s)>
fcca4     fb6fc9f2                 djnz    lmm_c, #.asciiloop              ' (longs count)--
                   
fcca8     f607c027                 mov     lmm_x, #"'"                     ' "'"
fccac     fdbffe14               CALL      #_HubTx                         '                       < call: transmit char(s)>
                   '               ----------------------------------------
                   ' ===END OF LINE===
fccb0     ff000005                 mov     lmm_x, ##(_CR_ + _LF_<<8)       ' <cr><lf>
fccb4     f607c00d 
fccb8     fdbffe08               CALL      #_HubTx                         '                       < call: transmit char(s)>
fccbc     f603d9e2               MOV       lmm_lp, lmm_p                   ' save new 'addr'
                   '               ----------------------------------------
                   ' ===MULTIPLE LINES ?===
fccc0     f213c5e3                 cmp     lmm_p, lmm_p2           wc      ' c if addr < addr2
fccc4     cd9fff4c         if_b    jmp     #_HubListLoop                   ' n: another line
                   '               ----------------------------------------
                   ' we need to calculate how far 'addr' advanced and advance 'addr2' by the same amount
fccc8     f183c7ed                 sub     lmm_p2,lmm_lp2                  ' {addr2} - orig  {addr}
fcccc     f103c7e2                 add     lmm_p2,lmm_p                    '         + final {addr}
                   '               ----------------------------------------
fccd0     f603c1ea               MOV       lmm_x, lmm_lx                   '\ restore params
fccd4     f603c3eb               MOV       lmm_f, lmm_lf                   '|
                   ''            MOV       lmm_p, lmm_lp                   '| (already done)
                   ''            MOV       lmm_p2,lmm_lp2                  '|
fccd8     f603c9ee               MOV       lmm_c, lmm_lc                   '/
fccdc     f527c204                 andn    lmm_f, #_HDG                    ' & turn _HDG off
                   '               ----------------------------------------
fcce0     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''--------------------------------------------------------------------------------------------------
                   
                   ''-------[ Read Cog/Hub Long ]------------------------------------------------- <--- read: cog/hub long --->
                   ''_RdLongCogHub
                   '' On Entry:
                   ''      lmm_x   = -anything-                            ' 'long':
                   ''      lmm_p   = 'addr'                                ' 'addr':  cog addr / hub ptr
                   '' Call Format:
                   ''              CALL    #_RdLongCogHub                  '                       < call: read cog/hub long >
                   '' On Return:
                   ''      lmm_x   = 'long'                                ' 'long':  read from cog/hub
                   ''      lmm_p   = 'addr++'                              ' 'addr++' cog addr++ / hub ptr++
                   '---------------------------------------------------------------------------------------------------
fcce4              _RdLongCogHub                                           '                       <--- read: cog/hub long --->
fcce4     ff000001                 cmp     lmm_p, ##$3FF           wcz     ' z|c if =<$3FF = cog/lut mode?
fcce8     f21fc5ff 
                   ' read the 'long' into lmm_x from hub 'addr' in lmm_p
fccec     1b03c1e2         if_a    rdlong  lmm_x, lmm_p                    '\ read a long (hub)
fccf0     1107c404         if_a    add     lmm_p, #4                       '| PTR++
fccf4     1d7c002d         if_a    RET                             WCZ     '/
                   
fccf8     f21fc5ff                 cmp     lmm_p, #$1FF            wcz     ' z|c if =<$3FF = cog mode?
                   ' read the 'long' into lmm_x from lut 'addr' in lmm_p
fccfc     1aa3c1e2         if_a    rdlut   lmm_x, lmm_p                    '\ read a long (lut)
fcd00     1107c401         if_a    add     lmm_p, #1                       '| PTR++
fcd04     1d7c002d         if_a    RET                             WCZ     '/
                   
                   ' read the 'long' into lmm_x from cog 'addr' in lmm_p..
                   '   don't forget we are executing from hub (hubexec)
fcd08     e997c400         if_be   alts    lmm_p                           '\ set PTR
fcd0c     e603c000         if_be   mov     lmm_x, 0-0                      '| read a long (cog)
fcd10     e107c401         if_be   add     lmm_p, #1                       '| PTR++
fcd14     fd7c002d                 RET                             WCZ     '/
                   ''--------------------------------------------------------------------------------------------------
                   
                   
                   ''-------[ Receive String ]---------------------------------------------------- <--- receive string --->
                   ''_HubRxString
                   '' On Entry:
                   ''      lmm_f = #_RXSTRING [+options]                   ' mode:   #_RXSTRING[+_ECHO][+_PROMPT][+_ADDR][+_NOLF]
                   ''      lmm_x = char(s)                 (optional)      ' prompt: char(s)
                   ''      lmm_p = 'bufad'                 (optional)      ' addr:   input string (hub ptr)
                   ''      lmm_bufad = 'bufad'             (default)       ' addr:   input string (hub ptr)
                   '' Call Format:
                   ''            CALL      #_HubRxString                   '                       < call: receive string >
                   '' On Return:
                   ''      lmm_f = -same-                                  ' mode:   (unchanged)
                   ''      lmm_x = -same-                                  '
                   ''      lmm_p = 'addr'                                  ' addr:   input string (hub ptr)
                   ''      lmm_c = 'count'                                 ' count:  char(s) entered (incl <cr>, excl <nul>)
                   ''--------------------------------------------------------------------------------------------------
fcd18     f607c02a _HubRxStrMon    mov     lmm_x, #"*"                                ' prompt
fcd1c     f607c2ba                 mov     lmm_f, #_RXSTRING+_ECHO_+_PROMPT+_NOLF     ' params
fcd20              _HubRxString                                            '                       <--- receive string --->
fcd20     f603cfe0               MOV       lmm_hx, lmm_x                   '                       < push: 'x'    #0 >
                   '               ----------------------------------------
fcd24     f7cfc208                 test    lmm_f, #_PROMPT         wz      ' prompt ?
fcd28     ad900004         if_z    jmp     #.noprompt                      ' n:
                   ' Display prompt char(s) in lmm_x
fcd2c     fdbffd94               CALL      #_HubTx                         '                       < call: transmit char(s) >
                   ' setup the hub string address ptr
fcd30     f7cfc204 .noprompt       test    lmm_f, #_ADDR           wz      ' addr supplied option ?
fcd34     a603c5ef         if_z    mov     lmm_p, lmm_bufad                ' n: use default hub buffer
                   ' receive char(s) terminated in <cr>
fcd38     f607c800                 mov     lmm_c, #0                       ' set char count=0
                   
fcd3c     fdbffda4 .loop         CALL      #_HubRx                 '       < call: receive char >
fcd40     f20fc008                 cmp     lmm_x, #_BS_            wz      ' <bs> ?
fcd44     a20fc800         if_z    cmp     lmm_c, #0               wz      ' start of input ?
fcd48     ad9ffff0         if_z    jmp     #.loop                  ' y: skip
fcd4c     f217c84e                 cmp     lmm_c, #_HUBBUFSIZE-2   wc      ' c if < end-of-buf ?
fcd50     320fc008         if_nc   cmp     lmm_x, #_BS_            wz      ' <bs> ?
fcd54     120fc00d    if_nc_and_nz cmp     lmm_x, #_CR_            wz      ' <cr> ?
fcd58     1d9fffe0    if_nc_and_nz jmp     #.loop                  ' j if buf full + not <bs> not <cr> (ignore)
fcd5c     fc43c1e2                 wrbyte  lmm_x, lmm_p                    ' push input char to buf (don't inc ptr yet)
fcd60     f7cfc210                 test    lmm_f, #_ECHO_          wz      ' echo?
fcd64     ad900014         if_z    jmp     #.noecho                        ' n:
fcd68     f20fc008                 cmp     lmm_x, #_BS_            wz      ' <bs> ?
fcd6c     af000410         if_z    mov     lmm_x, ##(_BS_+" "<<8+_BS_<<16) ' y: echo <bs>" "<bs>
fcd70     a607c008 
fcd74     fdbffd4c               CALL      #_HubTx                 '       < call: transmit char(s) >
fcd78     fac3c1e2                 rdbyte  lmm_x, lmm_p                    ' restore input char
fcd7c     f20fc00a .noecho         cmp     lmm_x, #_LF_            wz      ' <lf> ?
fcd80     5d900008         if_nz   jmp     #.notlf                 ' n:
fcd84     f7cfc202                 test    lmm_f, #_NOLF           wz      ' strip <lf> ?
fcd88     5d9fffb0         if_nz   jmp     #.loop                  ' j if strip <lf>
fcd8c     f20fc008 .notlf          cmp     lmm_x, #_BS_            wz      ' <bs> ?
fcd90     a187c401         if_z    sub     lmm_p, #1                       ' y: PTR--
fcd94     a187c801         if_z    sub     lmm_c, #1                       ' y: CTR--
fcd98     ad9fffa0         if_z    jmp     #.loop                  ' y: j
fcd9c     f107c401 .notbs          add     lmm_p, #1                       ' PTR++
fcda0     f107c801                 add     lmm_c, #1                       ' CTR++
fcda4     f20fc00d                 cmp     lmm_x, #_CR_            wz      ' <cr> ?
fcda8     5d9fff90         if_nz   jmp     #.loop                  ' n: if not <cr>
                   ' have a buffer with <cr> followed by <nul> terminated
fcdac     f607c000                 mov     lmm_x, #0                       '\ load $0 (nul)
fcdb0     fc43c1e2                 wrbyte  lmm_x, lmm_p                    '/ push to buf
fcdb4     f183c5e4                 sub     lmm_p, lmm_c                    ' reset PTR to start of string
                   '               ----------------------------------------
fcdb8     f603c1e7               MOV       lmm_x, lmm_hx                   '                       < pop:  'x'    #0 >
fcdbc     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   '---------------------------------------------------------------------------------------------------
                   
                   
                   ''-------[ Monitor: DebugMonitor]---------------------------------------------- <--- monitor/debug --->
                   ''_HubMonitor
                   '' Call Format:                                         '
                   ''            CALL      #_HubMonitor                    '                       < call: monitor/debug>
                   ''--------------------------------------------------------------------------------------------------
fcdc0     fdbfff54 _HubMonitor   CALL      #_HubRxStrMon                              '            < call: recv string >
                                   '---------------------------------------------------------------
                                   ' returns: lmm_p =str ptr, lmm_c=count of chars
                                   '---------------------------------------------------------------
                   ' get 1st param: [xxxxxx]  hex/addr {addr} followed by "-",".","G","L","Q",<esc>
fcdc4     fdb00194               CALL      #_ParseHex                      '                       < call: parse hex >
                                   '---------------------------------------------------------------
                                   ' returns: lmm_x=addr(hex), lmm_c=digitcount, lmm_p=ptrnextchar
                                   '          lmm_w=next non-hex char with lcase converted to ucase
                                   '---------------------------------------------------------------
fcdc8     f603dde4                 mov     lmm_lc, lmm_c                   ' save digitcount of {addr}
fcdcc     f603d9e0                 mov     lmm_lp, lmm_x                   ' save {addr}
fcdd0     f607da00                 mov     lmm_lp2, #0                     ' set  {addr2} =0
fcdd4     f20fca2d                 cmp     lmm_w, #"-"             wz      ' "-" ?    Download
fcdd8     ad9000f0         if_e    jmp     #_Download                      '
fcddc     f20fca2e                 cmp     lmm_w, #"."             wz      ' "." ?    {addr2}
fcde0     ad9000b4         if_e    jmp     #_Cmd_L2                        '
fcde4     f20fca47                 cmp     lmm_w, #"G"             wz      ' "G" ?    GOTO
fcde8     ad900030         if_e    jmp     #_Cmd_G                         '
fcdec     f20fca4c                 cmp     lmm_w, #"L"             wz      ' "L" ?    LIST
fcdf0     ad9000b4         if_e    jmp     #_Cmd_L                         '
fcdf4     f20fca51                 cmp     lmm_w, #"Q"             wz      ' "Q" ?    QUIT
fcdf8     ad900038         if_e    jmp     #_Cmd_Quit                      '
fcdfc     f20fca52                 cmp     lmm_w, #"R"             wz      ' "R" ?    RUN
fce00     ad900034         if_e    jmp     #_Cmd_Run                      '
fce04     f20fca1b TAQQ            cmp     lmm_w, #_TAQOZ_         wz      ' <esc>?   TAQOZ
fce08     ad9001d6         if_e    jmp     #@_Start_TAQOZ
                   '-------------------------------------------------------
fce0c     ff000506 _Cmd_What       mov     lmm_x, ##("?"+_CR_<<8+_LF_<<16) ' <cr> or unknown
fce10     f607c13f 
fce14     fdbffcac               CALL      #_HubTx                         '
fce18     fd9fffa4                 jmp     #_HubMonitor                    '
                   '-------------------------------------------------------
fce1c              _Cmd_G        ' xxxxxxG<cr>    Goto cog/lut/hub address
fce1c     fd63ca2b               POP       lmm_w                           ' pop stack
fce20     ff0007e0                 cmp     lmm_x, ##$FC000         wz      ' is it a ROM reboot?
fce24     f20fc000 
fce28     af0007e0     if_z        coginit #0, ##$FC000                    ' Y: restart
fce2c     acec0000 
fce30     fd63c02c                 jmp     lmm_x                           ' j to cog/lut/hub addr in lmm_x (not #lmm_x)
                   '-------------------------------------------------------
fce34              _Cmd_Quit     ' Q<cr>          Return to user program
fce34     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   '-------------------------------------------------------
fce38              _Cmd_Run      ' Rfilename.xtn<cr>                       ' Run filename "ffffffff.xxx" from SD
                   
fce38     fdb00030 		call	#Parsefilename			' get filename..
fce3c     f603b7e0 		mov	fname,	lmm_x		'
fce40     fdb00028 		call	#Parsefilename			'
fce44     f603b9e0 		mov	fname+1,	lmm_x		'
fce48     f20fca2e 		cmp	lmm_w,	#"."	wz	' skipover "." ?
fce4c     a107c401 	if_z	add	lmm_p,	#1		'
fce50     fdb00018 		call	#Parsefilename			'
fce54     f603bbe0 		mov	fname+2,	lmm_x		'
                   
fce58     fdbff710 		CALL     #@_Run_SDfile                  ' run <filename> from SD
                   
fce5c     ff000506                 mov     lmm_x, ##("!"+_CR_<<8+_LF_<<16) ' failed to run!
fce60     f607c121 
fce64     fdbffc5c               CALL      #_HubTx                         '
fce68     fd9fff54 		jmp	#_HubMonitor
                   '               ----------------------------------------
fce6c     f607c804 Parsefilename	mov	lmm_c,	#4		' 4 chars per call
fce70     f607c000 		mov	lmm_x,	#0
fce74     fac3cbe2 .loop		rdbyte	lmm_w,	lmm_p		' get a char
fce78     f20fca2e 		cmp	lmm_w,	#"."	wz
fce7c     520fca0d 	if_ne	cmp	lmm_w,	#_CR_ wz
fce80     5543c1e5 	if_ne	or	lmm_x,	lmm_w		' insert char..
fce84     a547c020 	if_e	or	lmm_x,	#" "		' .. or space..
fce88     f007c008 		ror	lmm_x,	#8		' .. & rotate byte
fce8c     5107c401 	if_ne	add	lmm_p,	#1		' PTR++
fce90     5ac3cbe2 	if_ne	rdbyte	lmm_w,	lmm_p		' get a char
fce94     0b6fc9f7 	_ret_	djnz	lmm_c,	#.loop	' <4 chars
                   '-------------------------------------------------------
                   ' LIST memory:
                   ' get 2nd param: [.yyyyyy]  {addr2} followed by "L"
fce98              _Cmd_L2
fce98     fdb000c0               CALL      #_ParseHex                      '                       < call: parse hex >
                                   '---------------------------------------------------------------
                                   ' returns: lmm_x=addr(hex), lmm_c=digitcount, lmm_p=ptrnextchar
                                   '          lmm_w=next non-hex char with lcase converted to ucase
                                   '---------------------------------------------------------------
fce9c     f603dbe0                 mov     lmm_lp2, lmm_x                  ' save {addr2}
fcea0     f20fca4c                 cmp     lmm_w, #"L"             wz      ' "L" ?    LIST
fcea4     5d9fff64         if_ne   jmp     #_Cmd_What                      ' n: unknown
                                   '-------------------------------------------------------
                   ' LIST memory:  lmm_lp='addr', lmm_lp2='addr2', lmm_lc='digitcount of param1
fcea8     f107c401 _Cmd_L          add     lmm_p, #1                       ' n: PTR++ (skip over non-hex char)
fceac     f603c5ec                 mov     lmm_p,  lmm_lp                  ' {addr}
fceb0     f603c7ed                 mov     lmm_p2, lmm_lp2                 ' {addr2}
fceb4     f217dc04                 cmp     lmm_lc, #4              wc      ' c if digitcount <4 ?
fceb8     3427c414         if_nc   bith    lmm_p,  #20                     ' $1_xxxxx trick forces hub :)
fcebc     3427c614         if_nc   bith    lmm_p2, #20                     ' $1_xxxxx trick forces hub :)
                                   '---------------------------------------
fcec0     f607c274                 mov     lmm_f,  #_LIST+_ADDR2+_HDG      ' list addr2 w heading monitor
fcec4     fdbffcd4               CALL      #_HubList                       '
fcec8     fd9ffef4                 jmp     #_HubMonitor                    '
                   '------------------------------------------------------------------------------------------------------------------
                   
                   
                   ''-------[ Download Command ]-------------------------------------------------- <--- download command --->
                   '' On Entry:
                   ''      '---------------------------------------------------------------
                   ''      ' lmm_x=addr(hex), lmm_c=digitcount, lmm_p=ptrnextchar
                   ''      '---------------------------------------------------------------
                   ''      lmm_x   = 'addr(hex)'                           ' addr(hex):  download addr in cog/hub
                   ''      lmm_c   = 'count'                               ' count:  count of chars in 'addr' for cog/hub
                   ''      lmm_p   = 'addr'                                ' addr:   ptr to string (hub)
                   ''      lmm_p2  = ????                                  ' addr2:
                   '' Call Format:
                   ''             CALL     #_Download                      '                       < call: download command >
                   '' On Return:
                   ''      ????
                   ''--------------------------------------------------------------------------------------------------
                   ''      [xx]xxx - xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx xx ['xxxxxxxxxxxxxxxx'] <cr>
                   ''--------------------------------------------------------------------------------------------------
fcecc     f603c7e0 _Download       mov     lmm_p2,           lmm_x         ' save download addr(hex)
fced0     f217c804                 cmp     lmm_c,            #4        wc  ' c if <4 digits (cog/lut?)
fced4     3427c61f         if_nc   bith    lmm_p2,           #31           ' n: set 'hub'
fced8     fdb00080 .loop         CALL      #_ParseHex                      ' get next hex value
                                   '---------------------------------------------------------------
                                   ' returns: lmm_x=value(hex), lmm_c=digitcount, lmm_p=ptrnextchar
                                   '          lmm_w=next non-hex char with lcase converted to ucase
                                   '---------------------------------------------------------------
fcedc     f20fc800                 cmp     lmm_c, #0                   wz  ' any input?
fcee0     ad9ffedc         if_z    jmp     #_HubMonitor                    ' n: done so back to monitor
fcee4     f417c61f                 testb   lmm_p2,           #31       wc  ' hub?
fcee8     cd900044         if_c    jmp     #.hub                           ' y:
                   ' cog/lut
                   ' get a long or 4 bytes for cog/lut
fceec     f217c808                 cmp     lmm_c,            #8        wc  ' c if <8 chars?
fcef0     3d900018         if_nc   jmp     #.gotlong                       ' n:
fcef4     fdb0006c .getmore      CALL      #_ParseHex2                     ' get another hex byte
fcef8     f217c808                 cmp     lmm_c,            #8        wc  ' c if <8 chars?
fcefc     3d900008         if_nc   jmp     #.got4bytes                     ' n:
fcf00     f20fca0d                 cmp     lmm_w,            #_CR_     wz  ' <cr>?
fcf04     5d9fffec         if_ne   jmp     #.getmore                       ' n:
fcf08     f9ffc01b .got4bytes      movbyts lmm_x,            #%%0123       ' reverse bytes
fcf0c     f21fc7ff .gotlong        cmp     lmm_p2,           #$1FF     wcz ' c|z if <$200 (cog?)
fcf10     ed90000c      if_c_or_z  jmp     #.cog                           ' y:
                   
fcf14     fc33c1e3 .lut            wrlut   lmm_x,            lmm_p2        ' write a long to lut
fcf18     f107c601                 add     lmm_p2,           #1            ' PTR++
fcf1c     fd9fffb8                 jmp     #.loop
                   
                   ' write 'long' from lmm_x into cog 'addr' in lmm_p2..   don't forget we are in hubexec!
fcf20     f98fc600 .cog            altd    lmm_p2                          '\ set PTR
fcf24     f60001e0                 mov     0-0,              lmm_x         '/ write a long to cog
fcf28     f107c601                 add     lmm_p2,           #1            ' PTR++
fcf2c     fd9fffa8                 jmp     #.loop
                   
fcf30     f217c803 .hub            cmp     lmm_c,            #3        wc  ' c if <3 chars (byte)
fcf34     cc43c1e3         if_c    wrbyte  lmm_x,            lmm_p2        ' write a byte to hub
fcf38     c107c601         if_c    add     lmm_p2, #1              ' PTR++ (+1)
fcf3c     cd9fff98         if_c    jmp     #.loop
fcf40     f217c805                 cmp     lmm_c,            #5        wc  ' c if <5 chars (word)
fcf44     cc53c1e3         if_c    wrword  lmm_x,            lmm_p2        ' write a word to hub
fcf48     c107c602         if_c    add     lmm_p2, #2            ' PTR++ (+2)
fcf4c     cd9fff88         if_c    jmp     #.loop
fcf50     fc63c1e3                 wrlong  lmm_x,  lmm_p2        ' write a long to hub
fcf54     f107c604                 add     lmm_p2, #4            ' PTR++ (+4)
fcf58     fd9fff7c                 jmp     #.loop
                   ''--------------------------------------------------------------------------------------------------
                   
                   
                   ''-------[ Parse hex input ]--------------------------------------------------- <--- parse hex input --->
                   ''_ParseHex
                   '' On Entry:
                   ''      lmm_x   = -anything-/'hex'                      ' 'hex':   ---/prev hex value
                   ''      lmm_c   = -anything-/'count'                    ' 'count': ---/prev count
                   ''      lmm_p   = 'addr'                                ' 'addr':  ptr to string (hub)
                   ''      lmm_w   = -anything-                            '
                   '' Call Format:
                   ''             CALL     #_ParseHex                      '                       < call: parse hex >
                   '' On Return:
                   ''      lmm_x   = 'hex'                                 ' 'hex':   hex value
                   ''      lmm_c   = 'count'                               ' 'count': of hex digits
                   ''      lmm_p   = 'addr++'                              ' 'addr':  ptr past next non-hex char
                   ''      lmm_w   = 'ucase'                               ' 'ucase': next non-hex char in ucase
                   ''--------------------------------------------------------------------------------------------------
fcf5c              _ParseHex                                               '                       <--- parse hex input --->
fcf5c     f607c000                 mov     lmm_x, #0                       ' preset hex=0
fcf60     f607c800                 mov     lmm_c, #0                       ' preset count=0
                   
fcf64     fac3cbe2 _ParseHex2      rdbyte  lmm_w, lmm_p                    '\ read a char from string
fcf68     f20fca20                 cmp     lmm_w, #" "             wz      '| " " ?
fcf6c     a107c401         if_e    add     lmm_p, #1                       '| y: PTR++
fcf70     ad9ffff0         if_e    jmp     #_ParseHex2                     '/    skip <spaces>
                   
fcf74     fac3cbe2 .loop           rdbyte  lmm_w, lmm_p                    ' read a char from string
fcf78     f217ca30                 cmp     lmm_w, #"0"             wc      ' c if <"0"
fcf7c     cd900044         if_b    jmp     #.done                          ' j if not hex
fcf80     f217ca3a                 cmp     lmm_w, #"9"+1           wc      ' c if "0"-"9"
fcf84     cd900018         if_b    jmp     #.num                           ' y: 0-9
fcf88     f547ca20                 or      lmm_w, #$20                     ' force lower case a-z
fcf8c     f217ca61                 cmp     lmm_w, #"a"             wc      ' c if <"a"
fcf90     cd900024         if_b    jmp     #.nothex                        ' j if not hex
fcf94     f217ca67                 cmp     lmm_w, #"f"+1           wc      ' c if <"g"
fcf98     3d90001c         if_nc   jmp     #.nothex                        ' j if not hex
fcf9c     f187ca07                 sub     lmm_w, #("A"-"9"-1)             ' convert from A-F/a-f
fcfa0     f507ca0f .num            and     lmm_w, #$0F                     ' extract valid nibble
fcfa4     f067c004                 shl     lmm_x, #4                       ' shift nibbles
fcfa8     f543c1e5                 or      lmm_x, lmm_w                    '   and add nibble
fcfac     f107c401                 add     lmm_p, #1                       ' PTR++
fcfb0     f107c801                 add     lmm_c, #1                       ' CTR++
fcfb4     fd9fffbc                 jmp     #.loop                          '
                   '               ----------------------------------------
fcfb8     fac3cbe2 .nothex         rdbyte  lmm_w, lmm_p                    ' re-read the non-hex char
fcfbc     f217ca60                 cmp     lmm_w, #$60             wc      ' c if < lower case columns
fcfc0     3527ca20         if_nc   andn    lmm_w, #$20                     ' converts to uppercase columns
fcfc4     f217c00d .done           cmp     lmm_x, #_CR_            wc      ' <cr>?    (don't skip over <cr>)
fcfc8     5107c401         if_ne   add     lmm_p, #1                       ' n: PTR++ (skip over non-hex char)
fcfcc     fd7c002d               RET                               wcz     '                       <--- return to calling routine --->
                   ''--------------------------------------------------------------------------------------------------
fcfd0     4d2d3250 _str_vers       byte    "P2-MONITOR V1.0",$0D,$0A,0
                   ''--------------------------------------------------------------------------------------------------
                   
                   
                   
                   
                   
                   
                   
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   ''%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                   
                   
                   
                   
                   
                   '*******************************************************************************
                   '*                                                                             *
                   '*          TAQOZ - Tachyon Forth for the Parallax P2 CPU ROM                  *
                   '*                                                                             *
                   '*******************************************************************************
                   {
                   $0200   RXBUF
                   $0400   NEW CODE
                   $B400   DICTIONARY
                   $FE00   REGISTERS
                   $FED0   TASKS
                   
                   }
                   
                   
                   con
                                           ' Version number encoded as a long
                           vernum          = 1_0
                           vertime         = 180516_0900
                           sys_clk         = 80_000_000
                   ''        baud_rate       = 115200
                   ''        baudval         = (sys_clk/baud_rate)<<16
                   
                           '''''''''''''' SERIAL BUFFERS ''''''''''
                   	rxbuffers       = $10
                   	rxrd		= rxbuffers-4
                   	rxwr		= rxbuffers-2
                           rxsize          = $FF0
                   
                           codeorg         = $1000
                           ramdict         = $B400                 ' dictionary can be moved elsewhere at runtime'
                   	registers       = $FE00                         'Variables used by kernel + general-purpose
                           tasks           = $FED0                         ' 2 longs/task * 8 cogs
                   
                           nscnt           = 100000/(sys_clk/1000000)
                   
                   
                   CON ' special wordcodes
                   
                           ex              =       1               ' EXITs (jump to hub wordcode instead of call)
                           _IF             =       $FC00           ' IF relative forward branch 0 to 127 words
                           _UNTIL          =       $FC80           ' UNTIL relative reverse branch 0 to 127 words
                           rg              =       $FD00           ' task/cog register 8-bit offset
                           w               =       $FE00           ' wordcode offset for 9-bit literals
                   
                           SKIPZ           =       _IF+01
                   
                           _FALSE          =       w+0
                           _0              =       w+0
                           _1              =       w+1
                           _2              =       w+2
                           _3              =       w+3
                           _4              =       w+4
                           _5              =       w+5
                           _6              =       w+6
                           _7              =       w+7
                           _8              =       w+8
                           _9              =       w+9
                           _13             =       w+13
                           _16             =       w+16
                           _32             =       w+32
                           _BL             =       w+32
                   
                   
                   CON
                   ' Offsets in LUT for stacks
                   datstk          = $000
                   brastk          = $020
                   lpstk           = $030
                   retstk          = $040
                   ' The LUT is essentially free from $80 onwards
                   
                   
                   CON
                   
                   lastkey         = $00F0         ' written to directly from serialrx to hub ram ( reuse blank "R1" location )
                   
                   
                   numpadsz        = 26            ' We really only need a large buffer for when long binary numbers with separators are used
                                                   ' 26 digits for double number 18,446,744,073,709,551,615
                   wordsz          = 39            ' any word up to 37 characters (1 count, 1 terminator)
                   tasksz          = 8             ' 8 bytes/task RUN[2] FLAG[1]
                   
                   ' fflags
                   echo            = 1
                   'linenums       = 2             ' prepend line number to each new line
                   ipmode          = 4             ' interpret this number in IP format where a "." separates bytes
                   
                   
                   prset           = $10           ' private headers set as default
                   sign            = $20
                   comp            = $40           ' force compilation of the current word - resets each time
                   defining        = $80
                   
                   
                   CON
                   
                   flashpins	= spi_cs<<24+spi_do<<16+spi_di<<8+spi_ck
                   sdpins		= sd_cs<<24+sd_do<<16+sd_di<<8+sd_ck
                   
                   WW		= $FFFF
                   
                   cntm    	= $1F           ' mask for nfa count byte to mask off atrs'
                   
                   ' Dictionary header attribute flags
                   pubatr  = 0
                   priatr  = 1
                   preatr  = 2
                   modatr  = 3
                   maxlen  = 15
                   
                   im      = preatr<<6           'lexicon immediate bit
                   pr      = priatr<<6           'private (can be removed from the dictionary)
                   
                   
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   
                   DAT
                   
fcfe2                              orgh
                   
                   ''-------[ Start TAQOZ ]----------------------------------------------------- <--- start TAQOZr --->
fcfe2     fdbffa66 _Start_TAQOZ    call    #@_reset_booter                 ' reset the booters interrupts and autobaud
                   
fcfe6              _Enter_TAQOZ
                   ''---------------------------------------------------------------------------------------------------
                   
                   
fcfe6     fedff016                 loc     PTRA,#_hubrom           ' copy all of ROM to low 64K'
fcfea     fef0f012                 loc     PTRB,#$C000
fcfee     ff000008                 rep     #2,##$1000
fcff2     fcdc0400 
fcff6     fb041761                 rdlong  fx,PTRA++
fcffa     fc6417e1                 wrlong  fx,PTRB++
                   
                   
                   		'mov	fx,##_ReEnter_TAQOZ & WW
                   		'wrlong	fx,#4
fcffe              _ReEnter_TAQOZ
fcffe     ff0007f6                 coginit #7,##@RESET
fd002     fcec0e7f 
fd006     ff0007f6                 coginit #6,##@RESET
fd00a     fcec0c7f 
fd00e     ff0007f6                 coginit #5,##@RESET
fd012     fcec0a7f 
fd016     ff0007f6                 coginit #4,##@RESET
fd01a     fcec087f 
fd01e     ff0007f6                 coginit #3,##@RESET
fd022     fcec067f 
fd026     ff0007f6                 coginit #2,##@RESET
fd02a     fcec047f 
fd02e     ff0007f6                 coginit #1,##@RESET
fd032     fcec027f 
fd036     ff0007f6                 coginit #0,##@RESET
fd03a     fcec007f 
                   
fd03e                              orgh
                   
                   { *** OUTPUT OPERATIONS *** }
                   
fd03e     fe20     SPACE   word    _BL
fd040     00defdad EMIT    word    rg+linenum,WFETCH
fd044     0071fc06         word    _IF+06,DUP,w+$0A,_EQ,_IF+02,DROP,_13
fd052     eb52fd10         word    rg+uemit,QJMP
fd056     0061017f         word    CONEMIT,EXIT
                   
fd05a     007bfe20 SPACES  word    _BL,SWAP        '''''FOR,SPACE,forNEXT,EXIT
                   '
                   ' EMITS ( ch cnt -- )
fd05e     fc040070 EMITS   word    QDUP,_IF+04,FOR,DUP,EMIT,forNEXT,DROPEX+ex
                   
                   ' ?EMIT ,( ch --  ) suppress emitting the character if echo flag is off
fd06c              QEMIT
fd06c     d0defe01         word    w+echo,CHKFLG,SKIPZ,EMIT+ex
fd074     00610067 DROPEX  word    DROP,EXIT
                   
                   
fd078     eb32fd10 _CON    word    rg+uemit,CLRL,EXIT
                   ' direct output to a smartpin (after init)
fd07e     013de9d2 _COM    word    _PIN,_WORD,WRACK
fd084     fd10     SETEMIT word    rg+uemit
fd086     006100e6 WSTOREX word    WSTORE,EXIT
fd08a     0067013d NONE    word    _WORD,DROP,SETEMIT+ex
fd090     d087fd12 SETKEY  word    rg+ukey,WSTOREX+ex
                   
fd094     d041fe0c CLS     word    w+$0C,EMIT+ex
fd098     d041fe07 BELL    word    w+7,EMIT+ex
                   
fd09c     00dbfdb1 SPINNER word    rg+spincnt,CFETCH,_3,_SHR,_3,_AND
fd0a8     d592             word    _STRING
fd0aa     5c2d2f7c         byte    "|/-\ ",0
fd0b0     00db0083         word    PLUS,CFETCH
fd0b4     fe08d040         word    EMIT,_8,EMIT,rg+spincnt,CINC,_1,ms+ex
                   
                   ' ACCEPTED
fd0c2     d5aa     OK      word    PRTSTR
fd0c4     006b6f20         byte    " ok",0
fd0c8     d0ce     CRLF    word    CR
fd0ca     d041fe0a LF      word    w+$0A,EMIT+ex
                   
fd0ce     d041fe0d CR      word    _13,EMIT+ex
                   
                   ' emit printable ASCII or a dot otherwise
fd0d2     00b5da12 AEMIT   word    QCHAR,_ZEQ
fd0d6     0067fc02         word    _IF+02,DROP
fd0da     d041fe2e DOT     word    w+".",EMIT+ex
                   
                   
                   
fd0de     eb1efd20 CHKFLG  word    rg+fflags,BITQ,EXIT
fd0e4     eb0efd20 CLRFLG  word    rg+fflags,CLR,EXIT
fd0ea     eafefd20 SETFLG  word    rg+fflags,SET,EXIT
                   
                   
                   ' U>    SWAP U< ;
fd0f0     ea1e007b UGT     word    SWAP,_ULT,EXIT
                   ' <=    ( n1 n2 -- flg )
fd0f6     007b     LTEQ    word    SWAP
                   ' =>    ( n1 n2 -- flg  )       1- > ;
fd0f8     ea0e0086 EQGT    word    DEC,GT,EXIT
                   
                   
fd0fe     00bf0074 DIVIDE  word    OVER,_ABS,OVER,_ABS,UDIVIDE,ROT2,_XOR,MNEGATE,EXIT
                   
                   
                   ' */ ( u1 u2 div1 -- res )
                   ' CLKHZ 1.333333 1,000,000 LAP */ LAP .LAP  35.200us ok
fd110     00c5007e MULDIV  word    ROT2,UMMUL,ROT,UMDIVMOD64,DROP,NIP,EXIT
                   
                   
                   ' C--
fd11e     d125013f CDEC    word    MINUS1,CINC+2+ex
                   ' C++
fd122     007bfe01 CINC    word    _1,SWAP,CPLUSST,EXIT
                   
                   ' W--
fd12a     d131013f WDEC    word    MINUS1,WINC+2+ex
                   ' W++
fd12e     007bfe01 WINC    word    _1,SWAP,WPLUSST,EXIT
                   
                   ' --
fd136     d13d013f LDEC    word    MINUS1,LINC+2+ex
                   ' ++
fd13a     007bfe01 LINC    word    _1,SWAP,PLUSST,EXIT
                   
                   
                   'BOOTQ  word    rg+bootsig
fd142     006100df FETCHX  word    FETCH,EXIT
                   
                   ''''''''''''''''''' SMARTPIN MODES '''''''''''''''''
                   
                   {
                   %AAAA_BBBB_FFF_PPPPPPPPPPPPP_TT_MMMMM_0
                    %AAAA:     A "! input selector
                    %BBBB:     B "! input selector
                    %FFF:     A "! and  B "! input logic/filtering (after  A "! and  B "! input selectors)
                    %P..P:    low-level pin control (needs final silicon to fully operate)
                    %TT:    pin DIR/OUT control (default = %00)
                    %MMMMM:    00000   = smart pin off (default)
                   ( * OUT signal overridden )
                   
                   00 100*  = pulse/cycle output
                   00 101*  = transition output
                   00 110*  = NCO frequency
                   00 111*  = NCO duty
                   01 000*  = PWM triangle
                   01 001*  = PWM sawtooth
                   }
                   
fd146     0178e9ca MUTE    word    _ATPIN,_FLOAT,_0,_WRPIN,EXIT
                   
fd150     00c3d20a MHZ     word    W1000,MUL16
fd154     00c3d20a KHZ     word    W1000,MUL16
fd158     d176     HZ      word    NCOCNT
fd15a     fe26     NCO     word    w+%01_00110
                   ' ( Y X mode -- )       mode    prescaler  value
                   ' SMART ( n mode -- )
fd15c     e9ca00ac SETNCO  word    _SHL1,_ATPIN,LOW,_WRPIN,_1,_WXPIN,_WYPIN,EXIT
                   
                   ' DUTY ( val -- ) $4E 100.1110
fd16c     d15dfe27 DUTY    word    w+%01_00111,SETNCO+ex
                   
                   ' -1/2 /CLKHZ/20000     == HZCON
                   ' NCOCNT ( freq -- ncocnt )     HZCON #10000 */ ;
fd170     014d     HZCON   word    CONL
fd172     00083126         long    536870
fd176     013dd170 NCOCNT  word    HZCON,_WORD,10000,MULDIV,EXIT
                   
                   ' BLINK ( pin -- )
fd180     fe02e9d2 BLINK   word    _PIN,_2,HZ+ex
                   
                   '--- TRIANGLE PWM MODE
                   ' PWM ( duty frame div -- )     @PIN LOW $50 WRPIN SWAP 16 << + WXPIN WYPIN ;
fd186     fe50     PWM     word    w+$50
fd188     0156016e PWM1    word    L,_WRPIN,SWAP,w+16,_SHL,PLUS,_WXPIN,_WYPIN,EXIT
fd19a     d189fe52 SAW     word    w+$52,PWM1+ex
                   ' SAW ( duty frame div -- )     @PIN LOW $50 WRPIN SWAP 16 << + WXPIN WYPIN ;
                   
                   
fd19e     04e2013d ns      word    _WORD,nscnt,UDIVIDE,EXIT
                   ' transistion mode
                   ' PW ( width -- )
fd1a6     fe4a016e PW      word    L,w+%01_00101_0,_WRPIN,_WXPIN,EXIT
fd1b0     fe01     PULSE   word    _1
fd1b2     0061015a PULSES  word    _WYPIN,EXIT
                   ' HILO ( high low -- )
fd1b6     fe48016e HILO    word    L,w+%01_00100_0,_WRPIN,SWAP,OVER,PLUS,SWAP,_16,_SHL,_OR,_WXPIN,EXIT
                   
                   
                   
                   
                   
                   
                   
                   
                   ''''''''''''''' SERIAL MODES ''''''''''''''''''
                   
fd1ce     eab6fe19 DL      word    w+tepin,COGFETCH,EXIT
                   ' BIT ( n -- ) Set bit length of serial smartpin interface
fd1d4     fe190086 BIT     word    DEC,w+tepin,COGSTORE,EXIT
                   
fd1dc     fe7c016d TXD     word    H,w+$7C
                   ' BAUD ( baud mode -- )
fd1e0     d2100156 BAUDST  word    _WRPIN,CLKHZ,SWAP,UDIVIDE,_SHL8,_SHL8,DL,_ZEQ,_IF+02,_8,BIT,DL,PLUS,_WXPIN,EXIT
fd1fe     d1e1fe3e RXD     word    w+$3E,BAUDST+ex
                   
                   { TRANSMITTING ASYNCH
                   TAQOZ# 34 PIN 8 BIT 115200 TXD  ok
                   TAQOZ# $55 WYPIN  ok
                   TAQOZ# $41 WYPIN  ok
                   TAQOZ# @NAMES 4 TXDAT  ok
                   }
                   '        1098 7654 321 0987654321098 76 54321 0
                   '           0 0001 000 0000000000000 01 11100 0
                   ' D/# = %AAAA_BBBB_FFF_PPPPPPPPPPPPP_TT_MMMMM_0
                   ' 11100*  = sync serial transmit         (A-data, B-clock)
                   ' SYNTX ( bits -- )             L $100.0078 WRPIN 1- $20 OR WXPIN ;
fd202     fe78     SYNTX   word    w+$78
                   
                   
                   {
                   pub TX		WYPIN ;
                   pub SERIAL ( pin -- )           PIN ' TX uemit W! ;
                   
                   }
                   
                   ''''''''''''''''''' CONSTANTS '''''''''''''''''''''
                   
fd204              W1000000
fd204     014d             word    CONL
fd206     000f4240         long    1000000
fd20a     014d     W1000   word    CONL
fd20c     000003e8         long    1000
                   
fd210     014d     CLKHZ   word    CONL
fd212     04c4b400         long    sys_clk
fd216     014d     CLKKHZ  word    CONL
fd218     00013880         long    sys_clk/1000
fd21c     014d     CLKMHZ  word    CONL
fd21e     00000050         long    sys_clk/1000000
                   
fd222     014d     BRORG	word	CONL
fd224     000f0000 	long	$F0000
                   
                   
fd228     014d     BUFFERS word    CONL
fd22a     0000f000         long    $F000
fd22e     014d     ROM     word    CONL
fd230     000fc000         long    $0F_C000
fd234     014d     IRQVEC  word    CONL
fd236     000fffe0         long    $0F_FFE0
                   
                   
                   {
                   %0000_000E_DDDD_DDMM_MMMM_MMMM_PPPP_CCSS     Set clock generator mode
                   %0001_0000_0000_0000_0000_0000_0000_0000     Hard reset, reboots chip
                   %001P_0000_0000_0000_0000_0000_0000_0000     Set write-protect of last 16KB RAM to P
                   %01RR_0000_0000_0000_0000_0000_0LLT_TTTT     Set filter R to length L and tap T
                   %1DDD_DDDD_DDDD_DDDD_DDDD_DDDD_DDDD_DDDD     Seed Xoroshiro128+ PRNG with D
                   }
                   
fd23a     d245fe01 REBOOT  word    w+1,HUBSW+ex
fd23e     d245fe02 WE      word    w+2,HUBSW+ex
fd242     fe03     WP      word    w+3
fd244     00a5fe1c HUBSW   word    w+28,_SHL,_HUBSET,EXIT
                   
                   ' 1=80MZ 2=40MHZ 3=20MHZ 4=10MHZ 5=5MHZ
fd24c     00d6fe01 CLKDIV  word    _1,_MAX,w+$1FF,SWAP,_SHR,_HUBSET,EXIT
fd25a     eb72fe01 RCSLOW  word    _1,_HUBSET,EXIT
                   
                   {
                   pub 50MHZ       $9F HUBSET ;
                   pub 45.4MHZ     $8F HUBSET ;
                   pub 62.5MHZ     $C7 HUBSET ;
                   }
                   
                   
                   
                   
                   
                   { *** NUMBER BASE *** }
                   
                   
                   ' change the default number bases
                   
fd260     fe02     BIN     word    w+2
fd262     fd16     SETBASE word    rg+base
fd264     006100e2 CSTOREX word    CSTORE,EXIT
fd268     d263fe0a DECIMAL word    w+10,SETBASE+ex
fd26c     d263fe10 HEX     word    w+16,SETBASE+ex
fd270     00dbfd16 GETBASE word    rg+BASE,CFETCH,EXIT
                   
                   
                   ' >UPPER  ( str1 --  ) Convert lower-case letters to upper-case
fd276     0089     TULP    word    INC
fd278     007000dc TOUPPER word    DUPCFT,QDUP,_IF+08                      ' end of string?
fd27e     fe7afe61         word    w+"a",w+"z",WITHIN
fd284     fc88             word    _UNTIL+08
fd286     0074fee0         word    w+$E0,OVER,CPLUSST,TULP+ex              ' convert case (subtract $20)
fd28e     d075             word    DROPEX+ex
                   
                   { *** STRING TO NUMBER CONVERSION *** }
                   
fd290     fe39fe30 DECQ    word    w+"0",w+"9",WITHIN+ex
fd296     fe46fe41 HEXQ    word    w+"A",w+"F",WITHIN+ex
                   
                   ' functional test for now - optimize later
                   ' Convert ASCII value as a digit to a numeric value - only interested in bases up to 16 at present
                   '
fd29c              TODIGIT ' ( char -- val true | false )
fd29c     d2900071         word    DUP,DECQ,_IF+04 ',td8           ' only work with 0..9,A..F
fd2a2     0082fe30         word    w+"0",MINUS
fd2a6     0061013f TRUEX   word    _TRUE,EXIT                      ' pass decimal digits
fd2aa     d2960071 td8     word    DUP,HEXQ,_IF+03 ',td2
fd2b0     0082fe37         word    w+$37,MINUS,TRUEX+ex            ' pass hex digits
fd2b6     0067     td2     word    DROP
fd2b8     0061fe00 FALX    word    _FALSE,EXIT
                   
                   {  Try to convert a string to a number
                   Allow all kinds of symbols but these are the rules for it to be treated as a number.
                   1. Leading character must be either a recognized prefix or a decimal digit
                   2. If trailing character is a recognized suffix then the first character must be a decimal digit
                   Acceptable forms are:
                   $1000   hex number
                   1000h
                   #1000   decimal number
                   1000d
                   %1000   binary number
                   1000b
                   
                   Also as long as the first character and last character are valid (0..9,prefix,suffix) then any symbols me be mixed in the number i.e.
                   11:59  11.59  #5_000_000
                   }
                   
fd2bc              _NUMBER ' ( str -- value digits | false )
fd2bc     eb32fd04         word    rg+4,CLRL                                               ' REG0L = 0
fd2c0     d0e4fe20         word    w+sign,CLRflg                                           ' clear sign
fd2c4              snlp
fd2c4     00540071         word    DUP,STRLEN,OVER,PLUS,DEC,CFETCH,rg+suffix,CSTORE                        ' save suffix (assume string has count byte)
fd2d4     fe2d00dc         word    DUPCFT,w+"-",_EQ,_IF+03                                 ' save SIGN
fd2dc     d0eafe20         word    w+sign,SETFLG,INC                               ' and use string without sign
                                                                                           ' prefix may come after the sign
fd2e2     007100dc         word    DUPCFT,DUP,rg+prefix,CSTORE                             ' save prefix (it may or may not be)
                   
                           ' PREFIX HANDLER
                           '       ( str ch )
fd2ea     fe00             word    _FALSE                                                  ' preset prefix flag = false
                   '               $nnnn - set hex base - flag true
fd2ec     fe240074         word    OVER,w+"$",_EQ,_IF+02,HEX,INC
fd2f8     fe230074         word    OVER,w+"#",_EQ,_IF+02,DECIMAL,INC                       ' as does # - also set decimal base
fd304     fe250074         word    OVER,w+"%",_EQ,_IF+02,BIN,INC                           ' as does % - also set binary base
fd310     fe260074         word    OVER,w+"&",_EQ,_IF+05,DECIMAL,INC                       ' as does & - also set decimal base and IP notation
fd31c     fd86fe80         word    w+$80,rg+bnumber+3,CSTORE                               ' this forces "." symbols to work the same as ":"
                           '       ( str ch flg )
fd322     fc030071         word    DUP,_IF+03,ROT,INC,ROT2                                 ' adjust string pointer to skip prefix
                           '       ( str ch flg )
fd32c     d290007b         word    SWAP,DECQ,_OR                                           ' 0..9 forces processing as a number
                           ''      ( str flg ) flg is true if a prefix is found OR the first character is 0..9
fd332     dda7ea02         word    SKIPNZ,DROPFEX+ex ' ( -- false )                                ' Give up now, it isn't a candiate
                           ''      ( str )                                                 ' so far, so good, now check suffix
                           ' SUFFIX HANDLER  - must end in 0..9 or A..F or valid suffix
fd336     00dbfd77         word    rg+suffix,CFETCH
fd33a     d2900071         word    DUP,DECQ                                                ' 0..9
fd33e     d2960074         word    OVER,HEXQ,_OR                                           ' A..F ( str sfx flg ) true if still a digit
fd344     fe680074         word    OVER,w+"h",_EQ,_IF+02,HEX,INC                           ' h = HEX
fd350     fe620074         word    OVER,w+"b",_EQ,_IF+02,BIN,INC                           ' b = BINARY
fd35c     fe64007b         word    SWAP,w+"d",_EQ,_IF+02,DECIMAL,INC                       ' d = DECIMAL
fd368     dda7ea02         word    SKIPNZ,DROPFEX+ex                                               ' bad suffix, no good
                           ' so far the prefix and suffx have been checked prior to attempt a number conversion
                           ' From here on there must be at least one valid digit for a number to be accepted
                           ' DIGIT EXTRACTION & ACCUMULATION
fd36c              nmlp
fd36c     007100dc         word    DUPCFT,DUP,_IF+(nmend-nm1)/2                    ' while there is another character
fd372     fc12d29c nm1     word    TODIGIT,_IF+(nmsym-nm2)/2                               ' convert to a digit? or else check symbol
                           ' a digit has been found but is it valid for this base? ' ( str val )
fd376     d2700071 nm2     word    DUP,GETBASE,DEC,GT,_IF+02
fd380     d2b90066 FALX2   word    DROP2,FALX+ex                                           ' a digit but exceeded base
fd384     00dffd7f nmok    word    rg+anumber,FETCH,GETBASE,_MUL                           ' shift anumber left one digit (base)
fd38c     fd7f0083         word    PLUS,rg+anumber,STORE                                   ' and merge in new digit
fd392     d122fd87         word    rg+digits,CINC                                          ' update number of digits
fd396     d36d0089 nmnxt   word    INC,nmlp+ex                                             ' update str and loop
                   
                           ' character was not a digit - check for valid symbols (keep it simple for now)
                           ' SYMBOLS
fd39a     fe3a00dc nmsym   word    DUPCFT,w+":",_EQ                                        ' : ENTER
fd3a0     00db0074         word    OVER,CFETCH,w+".",_EQ                                   '  . dot
fd3a8     fc040071         word    DUP,_IF+04,rg+digits,CFETCH,rg+dpl,CSTORE               ' remember last decimal place
fd3b4     00dffd83 ns01    word    rg+bnumber,FETCH,_ZNE,_AND,_OR
fd3be     fc0a             word    _IF+10                                                  ' Use : as special byte shift for IP notation etc
fd3c0     00dffd83 nmsym1  word    rg+bnumber,FETCH
fd3c4     00dffd7f         word    rg+anumber,FETCH,PLUS,_SHL8
fd3cc     00eafd83         word    rg+bnumber,STORE,rg+anumber,CLRL                        ' accumulate & number in bnumber
fd3d4     d397     nmsym2  word    nmnxt+ex                                                ' just ignore other symbols for now
                           '
fd3d6              nmend   ' end of string - check
fd3d6     fd870066         word    DROP2,rg+digits,CFETCH,DUP,ZEXIT                        ' return with false if there are no digits
fd3e0     00dffd7f         word    rg+anumber,FETCH,rg+bnumber,FETCH,PLUS
fd3ea     d0defe20         word    w+sign,CHKFLG,QNEGATE
fd3f0     0061007b         word    SWAP,EXIT                                               ' all good, return with number and true
                   
                   ' NUMBER processing -try to convert a string to a number
fd3f4              NUMBER  ' ( str -- value digits | false )
                           ' process control prefix i.e. ^A
fd3f4     00540071         word    DUP,STRLEN,_2,_EQ
fd3fc     00db0074         word    OVER,CFETCH,w+"^",_EQ,_AND,_IF+06                       ' ^ch  Accept caret char as <control> char
fd408     00db0089         word    INC,CFETCH,w+$1F,_AND,_1,EXIT                           ' control character processed - single digit
                           ' process character literal i.e. "A"
fd414     00540071 ch01    word    DUP,STRLEN,_3,_EQ
fd41c     00db0074         word    OVER,CFETCH,DUP,w+$22,_EQ,SWAP,w+$27,_EQ
fd42c     00900094         word    _OR,_AND,_IF+04                                 ' "ch" or 'ch' Accept as an ASCII literal
fd432     00db0089 ascch   word    INC,CFETCH,_1,EXIT
                   
                                                                                           ' It wasn't an ASCII literal, process as a number
fd43a     fe0afd7f ch02    word    rg+anumber,w+10,ERASE                                   ' zero out assembled number (double), digits, dpl
fd440     fd17d270         word    GETBASE,rg+base+1,CSTORE                                ' backup current base as it may be overridden
fd446     d2bc             word    _NUMBER '( str -- digits num | false )
fd448     00dbfd17 nmb1    word    rg+base+1,CFETCH,SETBASE+ex                             ' restore default base before returning
                   
                   
                   
                   ' QFNUM ( -- flg ) Test if word is a fast prefixed number
fd44e              QFNUM   'word   _TRUE,rg+wordbuf,DUP,STRLEN,ADO,IX,CFETCH,DECQ,_AND,LOOP,QDUP,IFEXIT
fd44e     00dbfd24         word    rg+wordbuf,CFETCH,w+"#",w+"%",WITHIN                    ' Numeric prefixes?
fd458     00dbfd23         word    rg+wordbuf-1,CFETCH,_2,GT,_AND                          ' and more than 2 characters? (inc term)
fd462     00dcfd23         word    rg+wordbuf-1,DUPCFT,PLUS,CFETCH                 ' and last char is a digit or hex digit?
fd46a     d2900071         word    DUP,DECQ                                                ' decimal digit?
fd46e     d296007b         word    SWAP,HEXQ,_OR,_AND                                      ' hex digit?
fd476     0061             word    EXIT
                   
                   
                   
                   { *** COMPILER EXTENSIONS *** }
                   
                   
                   
                   ' Most of these words are acted upon immediately rather than compiled as they are
                   ' part of the "compiler" in that they create the necessary structures
                   '
                   
                   ''' dumb compiler for literals - improve later - just needs to optimize the number of bytes needed
fd478              LITCOMP ' ( n -- ) compile the literal according to size
fd478     009c0071         word    DUP,_SHR16,_IF+08
                           ' Compile long
fd47e     013b013d         word    _WORD,_LONG,COMPW                               ' compile the _LONG instruction
fd484     009c0071         word    DUP,_SHR16,SWAP,COMPW,COMPW+ex                                  ' compile the long itself
                           ' Compile 2 bytes - 16bits
fd48e     009d0071 .L1     word    DUP,_SHR9,_IF+04
fd494     013d013d         word    _WORD,_WORD,COMPW,COMPW+ex
fd49c              .L2     ' Compile short literal directly
fd49c     fe00013d         word    _WORD,w,PLUS,COMPW+ex
                   
                   
                   ''''    BEGIN as in BEGIN...AGAIN or BEGIN...UNTIL  generate branch for BEGIN
fd4a4     febed690 _BEGIN_ word    ATCODES,w+$BE
                   '''
                   ''' MARK ( addr tag -- tag&addr ) Merge tag and addr by shifting tag into hi word
fd4a8     00a5fe18 MARK    word    w+24,_SHL,_OR,EXIT
                   
                   ' UNMARK        ( tag&addr -- addr tag )
fd4b0     013f0071 UNMARK  word    DUP,MINUS1,_SHR8,_AND,SWAP,w+24,_SHR,EXIT
                   
                   
                   
                   ''' REPEAT if mark is $1F preceded by $BE mark
fd4c0              _REPEAT_
fd4c0     d4c6007b         word    SWAP,_AGAIN_,_THEN_+ex
                   
                   ''' AGAIN if mark is $BE
fd4c6              _AGAIN_
fd4c6     d4b0     __AGAIN word    UNMARK
fd4c8     00b3febe         word    w+$BE,_EQ,_IF+(badthen-ag1)/2
                           ' ( addr bc -- ) compile the wordcode and calculate the branch back
fd4ce     d5f10089 ag1     word    INC,COMPW+ex
                   
                   ''' UNTIL ( flg -- )
fd4d2     d4b0     _UNTIL_ word    UNMARK
fd4d4     00b3febe unt00   word    w+$BE,_EQ,_IF+(badthen-unt1)/2
fd4da     007bd690 unt1    word    ATCODES,SWAP,MINUS,_SHR1,INC
fd4e4     fc80013d         word    _WORD,_UNTIL,_OR,COMPW+ex
                   
                   
                   
                   ''' IF as in IF...THEN or IF...ELSE...THEN
                   ''' WHILE
fd4ec              _IF_
fd4ec     fe1fd690         word    ATCODES,w+$1F,MARK
fd4f2     fc00013d         word    _WORD,_IF,COMPW+ex                      ' compile an IF and a dummy branch (else/then will set)
                   
fd4f8     fe1ed690 GOTO    word    ATCODES,w+$1E,MARK
                           ''      compile a dummy NOP to be replacd later with a goto (addr+ex)
fd4fe     006f013d         word    _WORD,_NOP,COMPW+ex
                   
                   ' ELSE
fd504              _ELSE_
fd504     d4b0             word    UNMARK ' ( addr tag )
                   ''              does this match an IF?
fd506     00b3fe1f         word    w+$1F,_EQ,_IF+(badthen-.L0)/2
                   ''              mark the else to be processed on a THEN
fd50c     d4f8     .L0     word    GOTO
                   '
                   ''              get the IF addr and proceed as if it were a THEN
fd50e     fe1f007b         word    SWAP,w+$1F,MARK
                   ' THEN
fd514     d4b0     _THEN_  word    UNMARK '( addr tag )
                           '
                           ' ( addr tag ) resolve structure branch
                           ''      ELSE THEN ?
fd516     fe1e0071         word    DUP,w+$1E,_EQ,_IF+05
fd51e     d6900067         word    DROP,ATCODES,INC,SWAP,WSTOREX+ex
                           ''      IF THEN ?
fd528     00b3fe1f         word    w+$1F,_EQ,_IF+8
                           ''      update IF's branch
fd52e     0074d690         word    ATCODES,OVER,MINUS,_SHR1,DEC,SWAP,CSTOREX+ex
                           '
fd53c     d5aa     badthen word    PRTSTR
fd53e     72745320         byte    " Structure mismatch! ",0
fd554     d075e00e         word    ERROR,DROPEX+ex
                   
                   
                   
                   
                   ''''''''''''''''''''' STRINGS ''''''''''''''''''''''''''
                   
                   
                   
                   
                   ' NULL$
fd558     00000153 NULLSTR word    VARB,0
                   
                   ' $! ( str1 str2 -- )
fd55c     00540074 STRST   word    OVER,STRLEN,INC,CMOVE,EXIT
                   
                   ' $= ( str1 str2 -- flg )
fd566     00540074 STREQ   word    OVER,STRLEN,OVER,STRLEN,_EQ
fd570     0071fc0e         word    _IF+14,DUP,STRLEN,ADO,CFETCHINC,IX,CFETCH,_NEQ,_IF+03,DROP,_0,LEAVE,LOOP,_ZNE,EXIT
fd58e     00010066         word    DROP2,FALSE+ex
                   
                   
                   ' STR ( -- n ) Leave address of inline string on stack and skip to next instruction
fd592     0071012b _STRING word    RPOP,DUP,STRLEN,OVER,PLUS,INC,WALIGN,AJMP       'PUSHR,EXIT
                   
                   
                   ' " string"     Compile a literal string - no length restriction - any codes can be included except the delimiter "
fd5a2              _STRING_
                           ''      compile wordcodes for string
fd5a2     d592013d         word    _WORD,_STRING,COMPW
fd5a8     d5c3             word    COMPSTR+ex
                   
                   
                   ' Print inline string
fd5aa     012b     PRTSTR  word    RPOP
fd5ac     007000d8 .lp     word    CFETCHINC,QDUP,_IF+02,EMIT,.lp+ex
fd5b6     0128d670         word    WALIGN,PUSHR,EXIT
                   
                   ' PRINT" HELLO WORLD"   Compile a literal print string - no length restriction - any codes can be included except the delimiter "
fd5bc     d5aa013d _PSTR_  word    _WORD,PRTSTR,COMPW
fd5c2     0071e116 COMPSTR word    WKEY,DUP,QEMIT          ' echo string
fd5c8     fe220071         word    DUP,w+$22,_NEQ,_IF+02,COMPC,COMPSTR+ex
                   ''              word align end of string with an extra null
fd5d4     fe01d690         word    ATCODES,_1,_AND,_ZEQ,_IF+02,_0,COMPC
fd5e2     fe000067         word    DROP,_0
fd5e6     00e6d690 COMPC   word    ATCODES,WSTORE
                   ''              advance code write address by 1
fd5ea     d13afda1         word    rg+codes,LINC,COMPX+ex
                   
                   
                   ' ( wordcode -- ) append this wordcode to next free code location + append EXIT (without counting)
fd5f0     d670d690 COMPW   word    ATCODES,WALIGN,WSTORE
fd5f6     fda1fe02         word    _2,rg+codes,WPLUSST
                   ''      word    WALIGN
                   ''              advance code write address by 2
                   ''      word    rg+codes,STORE
                   ''              compile an EXIT after the latest codes
fd5fc     0061013d COMPX   word    _WORD,EXIT,ATCODES,WSTOREX+ex
                   
                   ' C, or | ( n -- ) IMMEDIATE --- compile a byte into code and allocate
fd604     d5e6d632 CCOMP   word    GRAB,COMPC,rg+codes,WFETCH,_1,_AND,IFEXIT,ALLOCATED+ex
                   ' W, or || ( n -- )
fd614     d5f0d632 WCOMP   word    GRAB,COMPW,ALLOCATED+ex
                   
                   ' , ( n -- ) Compile a long literal
fd61a     d632     LCOMP   word    GRAB
fd61c     d5f00071 COMPL   word    DUP,COMPW,_SHR16
fd622     d62dd5f0 WCOMMA  word    COMPW,ALLOCATED+ex
                   
                   
                   
                   ' ALLOT ( bytes -- )
fd626     00e8fda1 ALLOT   word    rg+codes,PLUSST,ALLOCATED+ex
                   
                   ' lock in compiled code so far - do not release but set new "here" to the end of these codes
fd62c              ALLOCATED
fd62c     fd9dd690         word    ATCODES,rg+here,STOREX+ex
                   
                   ' GRAB ( -- ) \ IMMEDIATE --- executes preceding code to make it available for any immediate words following
fd632     0061013d GRAB    word    _WORD,EXIT,COMPW                                        ' append an EXIT
fd638     0071d686         word    ATHERE,DUP,rg+codes,STORE,ACALL                         ' execute and release preceding code in text line
fd642     0061             word    EXIT
                   
                   
fd644     0088d686 TWICE   word    ATHERE,INC2,COMPW,ALLOCATED+ex
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   ' NFA' ( <name> -- nfaptr )
                   ' COMPILE  ( not used in this version )
fd64c              NFATICK
fd64c     0086dd84         word    _GETWORD,DEC,SEARCH+ex
                   
fd652              _NFATICK
fd652     d479d64c         word    NFATICK,LITCOMP+ex
                   
                   ' The CPA is the address of the word code stored in the header that points to the code to execute
                   
                   ' 03,D,U,P,CPAL,CPAH'
                   ' CPA ( nfa -- cpa )
fd656              NFACPA
fd656     fe1f00d8 nclp    word    CFETCHINC,w+cntm,_AND,PLUS,EXIT
                   
                   
                   ' ' <name>  ( -- pfa ) Find the address of the following word - zero if not found or its CFA/PFA
fd660     d64c     TICK    word    NFATICK
                   ' CFA ( nfa -- cfa )'
fd662     005f0071 NFACFA  word    DUP,ZEXIT,NFACPA,WFETCH,EXIT
                   
fd66c     d479d660 ATICK   word    TICK,LITCOMP+ex
                   
                   
                   
                   
fd670     fe010089 WALIGN   word   INC,_1,_ANDN,EXIT
                   
                   ' ALIGN ( address align -- val00  )                                     1- SWAP OVER + SWAP ANDN ;
fd678     007b0086 _ALIGN  word    DEC,SWAP,OVER,PLUS,SWAP,_ANDN,EXIT
                   
                   
                   {HELP _HERE ( -- addr ) Address of next compilation location }
fd686     00defd9d ATHERE  word    rg+here,WFETCH,EXIT
                   ' ( -- atradr ) --- point to the attribute byte in the header of the latest name
fd68c              ATATR
fd68c     d143fd95 ATNAMES word    rg+names,FETCHX+ex
fd690     00defda1 ATCODES word    rg+codes,WFETCH,EXIT
                   
                   
                   '  CREATEWORD - create a name in the dictionary using the next word encountered
                   ''               cnt,name,atr,cpa
fd696              CREATEWORD
fd696     dd84             word    _GETWORD                                ' ( str ) read the next word
                   ' CREATE$ ( str -- )
fd698              CREATESTR
                           '       skip empty string '
fd698     ea0200dc         word    DUPCFT,SKIPNZ,DROPEX+ex
                   '       '       get attribute
                   '       word    rg+fflags,CFETCH,w+prset,_AND
                   '               setup CPA field right now '
fd69e     d68cd690         word    ATCODES,ATNAMES,DEC2,WSTORE
                           '       build up a header in the word buffer then copy across
                           '       get string count ( str )
fd6a6     00710086         word    DEC,DUP,CFETCH,INC  ' ( c+str size )'
                           '       ( str size ) update names ptr by backwards count + cpa field
fd6ae     00880071         word    DUP,INC2,NEGATE,rg+names,PLUSST
                           ''      copy it across
fd6b8     007bd68c         word    ATNAMES,SWAP,CMOVE
                           ''      check for dictionary full ( less than 64 bytes )
fd6be     d686d68c         word    ATNAMES,ATHERE
fd6c2     0083fe40         word    w+64,PLUS,LT,ZEXIT,PRTSTR
fd6cc     69442020         byte    "  Dictionary full! ",0
fd6e0     e00f             word    ERROR+ex
                   
                   ' CREATE <name> - Create a name in the dictionary and also a VARIABLE code entry - or revectored through NOP
fd6e2     d696006f CREATE  word    _NOP,CREATEWORD,_WORD,VARB,COMPW,_0,ALLOT+ex
                   
                   ' Change the value of a constant
                   ' pub ==! ( val 'con -- )               2+ ! ;
fd6f0     d76f0088 CONST   word    INC2,STOREX+ex
                   
                   
                   
fd6f4     fe00d6e2 _VAR    word    CREATE,_0,COMPL+ex
                   
                   ' :=
fd6fa     d696d632 _CON9   word    GRAB,CREATEWORD,BITS9,_WORD,w,PLUS,ATNAMES,NFACPA,WSTOREX+ex
                   
                   ' ==
fd70c     d696d632 _CONST  word    GRAB,CREATEWORD,_WORD,CONL
fd714     d61cd5f0 DCOMP   word    COMPW,COMPL,_0,ALLOT+ex
                   
                   ' Identical to a constant except the call address is slightly different so a FORGET can release the data area
fd71c     d696d632 _DATCON word    GRAB,CREATEWORD
fd720     014c013d         word    _WORD,DATCON,DCOMP+ex
                   
                   
                   
                   ' GETATR ( -- code )
fd726     fe06d68c GETATR  word  ATNAMES,_6,_SHR,EXIT
                   
                   ' Create a new entry in the dictionary but also prevent any execution of code
                   ' : <name>
                   
fd72e     d696     NEWDEF  word    CREATEWORD
fd730     d0eafe80         word    w+defining,SETFLG,EXIT                  ' flag that we have entered a definition
                   
fd736     0061d72e PUBDEF  word  NEWDEF,EXIT
                   
                   
fd73a     d745fe03 MODDEF  word    w+modatr,SDEF+ex
fd73e     d745fe02 PREDEF  word    w+preatr,SDEF+ex
fd742     fe01     PRIDEF  word    w+priatr
fd744     d72e     SDEF    word    NEWDEF
                   ' SETATR ( code -- )
fd746     00a5fe06 SETATR  word  _6,_SHL,ATNAMES,CFETCH,w+cntm,_AND,_OR,ATNAMES,CSTORE,EXIT
                   
                   
                           { auto jump for exit method from V4.7 DAWN
                           ' Compile an EXIT normally but if the previous wordcode allows for a JUMP bit then use that method
                           aRETURN
                                   word  w+ucomp,WFETCH,DUP,w+$200,w+varram,@WITHIN+s,SWAP,_1,_AND,_ZEQ,_AND
                                   '              fetch last wordcode and make sure it is not a string term.
                                   word  _IF+12,@ATTHERE+s,@SUB2+s,DUP,WFETCH
                                   ' set lsb if wordcode >$FF (not a null term)
                                   word  DUP,_SHR8,_IF+05,_1,_OR,SWAP,WSTORE,EXIT ''''''''@NEWPUB+t
                                   ' otherwise just compile an EXIT as normal
                                   word  DROP2,w+EXIT,@WCOMPK+s,@ALLOCATED+t
                           }
                   
                   ' Update "here" pointer to point to current free position which "codes" pointer is now at
                   ' Also unsmudge the headers tag
                   '
fd75a              ENDDEF
                   '''''   word    ATCODES,DEC2,WFETCH,_WORD,$200,LT,_IFXX
fd75a     0061013d         word    _WORD,EXIT,COMPW                                        ' compile an EXIT
fd760     d0e4fe80 UNDEF   word    w+defining,CLRFLG,ALLOCATED,EXIT                        ' end definition and lock allocated bytes
                   
                   
                   ' [C] force compilation of the next word
fd768              COMPILES
fd768     d0ebfe40         word    w+comp,SETFLG+ex
                   
                   
                   
                   ' ************** CASE STATEMENTS *********************8
                   
                   ' SWITCH ( val -- )
fd76c     fd1c     _SWITCH word    rg+uswitch
fd76e     006100ea STOREX  word    STORE,EXIT
                   
                   ' SWITCH@ ( -- val )
fd772     d143fd1c SWFETCH word    rg+uswitch,FETCHX+ex
                   
                   ' SWITCH= ( val -- flg )
fd776              ISEQ
fd776     00b3d772         word    SWFETCH,_EQ,EXIT
                   
                   ' CASE ( compare -- )
fd77c     d776013d _CASE   word    _WORD,ISEQ,COMPW,_IF_+ex
                   
                   ' BREAK
fd784     0061013d ISEND   word    _WORD,EXIT,COMPW,_THEN_,ALLOCATED+ex
                   
                   
                   ' SWITCH>< ( from to -- flg )..
fd78e              ISWITHIN
fd78e     007ed772         word    SWFETCH,ROT2,WITHIN+ex
                   
                   
                   {  Table vectoring -
                   index a table of vectors and jump to that vector
                   A table limit is supplied as well as a default vector
                   
                    Usage:
                           <limit> VECTORS <vector if over>
                           <vector0> <vector1> ...... <vectorx>)
                   Sample:
                           4 LOOKUP BELL                   \ an index of 4 or more will default to BELL
                           INDEX0 INDEX1 INDEX2 INDEX3     \ 0 to 3 will execute corresponding vectors
                   
                   }
                   {
                   ' LOOKUP
                   ' VECTORS ( index range -- )
                   VECTORS
                           word    OVER,GT,_ZEQ,_IF+02,DROP,MINUS1         ' limit index to range or -1 (.>0)
                   .L0     word    INC,_SHL1,RPOP,PLUS,WFETCH,ACALL,EXIT
                   
                   }
                   
                   
                   
                   ' ( n lo hi -- flg ) true if n is within range of low and high inclusive
fd794     00740089 WITHIN  word    INC,OVER,MINUS,PUSHR
fd79c     012b0082         word    MINUS,RPOP,_ULT
fd7a2     006100b7 WT1     word    _ZNE,EXIT
                   
                   
                   
                   
                   { *** MOVES & FILLS *** }
                   ' <CMOVE ( src dst cnt -- ) byte move in reverse from the ends to the start
fd7a6     0074007f RCMOVE  word    ROT,OVER,PLUS,DEC,ROT,THIRD,PLUS,DEC,ROT,pRCMOVE,EXIT
                   
                   
                   { *** TIMING *** }
                   
fd7bc     00c3d20a secs    word    W1000,MUL16
                   ' ms ( n -- ) Wait for n milliseconds
fd7c0     005f0070 ms      word    QDUP,ZEXIT,_LONG
fd7c6     00013880         long    sys_clk/1000
fd7ca     e9ba00c0         word    _MUL,WAIT,EXIT
                   
fd7d0     00c3d21c us      word    CLKMHZ,MUL16,w+485,MINUS,WAIT,EXIT
                   
                   
                   
                   
                   
                   { debug print routines - also used by DUMP etc }
                   
                   {HELP  .HEX ( n -- ) print nibble n as a hex character }
fd7dc              PRTHEX  ' ( n -- ) print n (0..$0F) as a hex character
fd7dc     0090fe0f         word    w+$0F,_AND,w+"0",PLUS,DUP,w+$39,GT,_IF+02,_7,PLUS,EMIT+ex
                   
fd7f2     d041fe24 HEXSYM  word    w+"$",EMIT+ex
                   
fd7f6     d7f2     PRTB    word    HEXSYM
                   {HELP  .BYTE ( n -- ) print n as 2 hex characters }
fd7f8     fe040071 PRTBYTE word    DUP,_4,_SHR,PRTHEX,PRTHEX+ex
                   
fd802     d7f2     PRTW    word    HEXSYM
                   {HELP  .WORD ( n -- ) print n as 4 hex characters }
fd804     009e0071 PRTWORD word  DUP,_SHR8
fd808     d7f9d7f8         word  PRTBYTE,PRTBYTE+ex
                   
fd80c     d03fd812 PRINTSP word    PRTLONG,SPACE+ex
                   
fd810     d7f2     PRTL    word    HEXSYM
                   {HELP .LONG ( n -- ) print n as 8 hex characters }
fd812     009c0071 PRTLONG word  DUP,_SHR16,PRTWORD
fd818     d805d0da         word  DOT,PRTWORD+ex
                   
                   
fd81c     00defd89 DCFETCH word    rg+dmm,WFETCH,QDUP,_IF+02,ACALL,EXIT
fd828     006100db .L0     word    CFETCH,EXIT
fd82c     00defd8b DWFETCH word    rg+dmm+2,WFETCH,QDUP,_IF+02,ACALL,EXIT
fd838     006100de .L0     word    WFETCH,EXIT
fd83c     00defd8d DFETCH  word    rg+dmm+4,WFETCH,QDUP,_IF+02,ACALL,EXIT
fd848     d143     .L0     word    FETCHX+ex
                   
fd84a     fe06fd89 RAM     word    rg+dmm,_6,ERASE,EXIT
                   
fd852     fd89012b SETDMP  word  RPOP,rg+dmm,_6,CMOVE,EXIT
                   
                   
fd85c     00defd8f DUMP    word    rg+dmp,WFETCH,rg+dmp,CLRW,QDUP,SKIPZ,AJMP,DUMPB+ex
                   
                   { QUICK DUMP }
fd86c     fe20     QD      word    w+$20
                   {HELP DUMP ( addr cnt -- ) Hex dump of hub RAM - }
fd86e     0108     DUMPB   word    ADO
fd870     d8e6             word      PRTADR
fd872     fe100101         word      IX,_16,ADO,IX,DCFETCH,PRTBYTE,SPACE,LOOP
fd882     d8fa             word      DUMPASC
fd884     0111fe10         word    _16,PLOOP
fd888     d84b             word    RAM+ex
                   { DUMP as WORDs }
fd88a     0108     DUMPW   word    ADO
fd88c     d8e6             word      PRTADR
fd88e     fe100101         word      IX,_16,ADO,IX,DWFETCH,PRTWORD,SPACE,_2,PLOOP
fd8a0     d8fa             word      DUMPASC
fd8a2     0111fe10         word    _16,PLOOP
fd8a6     d84b             word    RAM+ex
                   
                   { DUMP as LONGs }
fd8a8     0108     DUMPL   word    ADO
fd8aa     d8e6             word      PRTADR
fd8ac     fe100101         word      IX,_16,ADO,IX,DFETCH,PRINTSP,_4,PLOOP
fd8bc     d8fa             word      DUMPASC
fd8be     0111fe10         word    _16,PLOOP
fd8c2     d84b             word    RAM+ex
                   
                   { DUMP as ASCII WIDE }
fd8c4     d8cbfe80 DUMPAW  word    w+128,DUMPS+ex
                   { DUMP as ASCII }
fd8c8     fe40     DUMPA   word    w+64
fd8ca     007e     DUMPS   word    ROT2
fd8cc     0108             word    ADO
fd8ce     d8e6             word      PRTADR
fd8d0     00740101         word      IX,OVER,ADO,IX,DCFETCH,AEMIT,LOOP
fd8de     01110071         word    DUP,PLOOP,DROP
fd8e4     d84b             word    RAM+ex
                   
                   
fd8e6     0101d0c8 PRTADR  word    CRLF,IX,DUP,_SHR16,PRTBYTE,DOT,PRTWORD,w+":",EMIT,SPACE+ex
                   
fd8fa     d05afe03 DUMPASC word      _3,SPACES,IX,_16,ADO,IX,DCFETCH,AEMIT,LOOP,EXIT
                   
                   
fd90e     00ec013d _LUT    word    _WORD,LUTFETCH,COGSET+ex
fd914     eab6013d _COG    word    _WORD,COGFETCH
fd918     d93e013d COGSET  word    _WORD,COGLUT,WSTORE,_WORD,COGDUMP,rg+dmp,WSTOREX+ex
                   
fd926              COGDUMP
fd926     01010108         word    ADO,IX,_7,_AND,SKIPNZ,PRTADR
fd932     fe030101         word    IX,_3,_AND,SKIPNZ,SPACE,IX
fd93e     d812eab6 COGLUT  word    COGFETCH,PRTLONG,SPACE,LOOP,EXIT
                   
                   
                   
                   ' Print the stack(s) and dump the registers - also called by hitting <ctrl>D during text input
fd948     e086     DEBUG   word    PRTSTKS
fd94a     d5aa             word    PRTSTR
fd94c     45520a0d         byte    $0D,$0A,"REGS ",0
fd954     ff00fd00         word    rg+temp,w+$100,DUMPW
fd95a     d5aa             word    PRTSTR
fd95c     4f430a0d         byte    $0D,$0A,"CODE ",0
fd964     fe20d686         word    ATHERE,_32,MINUS,w+64,DUMPW
fd96e     d5aa             word    PRTSTR
fd970     4f570a0d         byte    $0D,$0A,"WORDS",0
fd978     fe40d68c         word    ATNAMES,w+$40,DUMPB
fd97e     d984d0c8         word    CRLF,lsio
fd982     d0c9             word    CRLF+ex
                   
                   
fd984              lsio
                   
fd984     d0c8             word    CRLF
                   ''	word 	PRTSTR
                   ''        byte    "PINS "
                   ''        byte    $0D,$0A,"P:",0
fd986     fe00fe3e         word    w+62,_0,DO,IX,w+10,DIVIDE,PRINT,LOOP
fd996     d5aad0c8         word    CRLF,PRTSTR
fd99a     003a500d         byte    $0D,"P:",0
fd99e     fe00fe3e         word    w+62,_0,DO,IX,w+10,UMOD,PRINT,LOOP
fd9ae     d5aad0c8         word    CRLF,PRTSTR
fd9b2     003a3d0d         byte    $0D,"=:",0
fd9b6     fe00fe3e         word    w+62,_0,DO
fd9bc     01760101         word    IX,LOW,w+200,WAIT,IX,_FLOAT,w+200,WAIT,IX,PINTEST,_1,_AND,_SHL1
fd9d6     01740101         word    IX,HIGH,w+200,WAIT,IX,_FLOAT,w+200,WAIT,IX,PINTEST,_1,_AND,_OR
fd9f0     d592             word    _STRING
fd9f2     68637e64         byte    "d~ch ",0
fd9f8     00db0083         word    PLUS,CFETCH,EMIT,LOOP
fda00     0061             word    EXIT
                   
fda02     00c0d204 M       word    W1000000,_MUL,EXIT
fda08     00a5fe0a MB      word    w+10,_SHL
fda0c     00a5fe0a KB      word    w+10,_SHL,EXIT
                   
                   
                   
                   
fda12     fe200071 QCHAR   word    DUP,_BL,w+$7E,WITHIN+ex
                   'QCHAR  word    DUP,_BL,LT,OVER,w+$7E,GT,_OR,EXIT
fda1a     00b5da12 TOCHAR  word    QCHAR,_ZEQ,_IF+02,DROP,w+$20,EXIT
                   
                   ' @PAD ( -- addr ) pointer to current position in number pad
fda26     00dbfd65 ATPAD   word    rg+padwr,CFETCH,rg+numpad,PLUS,EXIT
                   
                   ' >CHAR  ( val -- ch ) convert binary value to an ASCII character
fda30     0090fe3f BINASC  word    w+$3F,_AND,w+"0",PLUS,DUP,w+"9"                 ' convert to "0".."9"
fda3c     fe07ea0e         word    GT,_7,_AND,PLUS                                         ' convert to "A"..
fda44     fe5d0071         word    DUP,w+$5D,GT,ZEXIT,_3,PLUS,EXIT                 ' skip symbols to go to "a"..
                   
                   ' <#    ' resets number pad write index to end of pad
fda52     fd65fe1a LHASH   word    w+numpadsz,rg+padwr,CSTORE,_0
                   '''
                   ' HOLD ( char -- )
fda5a     d11efd65 HOLD    word    rg+padwr,CDEC,ATPAD,CSTOREX+ex
                   
                   
                   ' # ( n1 -- n2 ) convert the next ls digit of a double to a char and prepend to number string
fda62     00dffd0c HASH    word    rg+double,FETCH,GETBASE,UMDIVMOD64,rg+double,STORE
fda6e     da30007b         word    SWAP,BINASC,HOLD+ex
                           ' conversion digits exhausted, use zeros or spaces
                   
                   ' #S ( d1 -- 0 ) Convert all digits
fda74     0071da62 HASHS   word    HASH,DUP,_ZEQ,_UNTIL+04,EXIT
                   
                   ' #> ( n1 -- caddr )
fda7e     da260067 RHASH   word    DROP,ATPAD,rg+double,CLRL,EXIT
                   
                   ' <D> ( d1 -- n1 ) ' Store high long of double for formating
fda88     d76ffd0c DNUM    word    rg+double,STOREX+ex
                   
                   
                   ' . ( n -- ) Print the number off the stack
fda8c              PRINT
fda8c     00bd0071 PRT     word    DUP,_ZLT,_IF+03,w+"-",EMIT,NEGATE
                   '''
                   ' U. ( n -- ) Print an unsigned number
fda98     da74da52 UPRT    word    LHASH,HASHS,RHASH
                   '''
                   
                   ' PRINT$ ( adr -- ) Print the null or 8th bit terminated string - stops on any non-printable character
fda9e     da1200d8 PSTR    word    CFETCHINC,QCHAR,_IF+02,EMIT,PSTR+ex
fdaa8     00610066 pstrxt  word    DROP2,EXIT
                   
                   ' since printing a 32-bit binary number with formatting can be quite long, this one prints directly
fdaac     d040fe25 PRTBIN  word    w+"%",EMIT,_BL,FOR,DUP,w+31,_SHR,w+"0",PLUS,EMIT,_SHL1,forNEXT,DROPEX+ex
                   
                   
                   
                   
                   
                   {
                   .AS" Format string spec:
                   #       Convert one digit (default is decimal)
                   ~       Toggle leading zero suppression
                   `       pad leading zeros with spaces
                   $|      Hexadecimal
                   *|      Convert all remaining digits
                   4|      Convert 4 digits
                   }
fdac6     00940073 DZEQ    word    DUP2,_OR,_ZEQ,EXIT
                   
fdace     fe02dac6 AHASH   word    DZEQ,_2,rg+pflg,BITQ,_AND,_IF+02,w+$20,HOLD+ex,rg+pbase,CFETCH,UMDIVMOD64,ROT,BINASC,HOLD+ex
                   
fdaea     fe04d76c ASHASH  word    _SWITCH,_4,rg+pflg,BITQ,_NOT,_4,rg+pflg,CLR,_IF+(ASCMD-.L3)/2
fdafc     d776fe7c .L3     word    w+"|",ISEQ,_IF+04,_4,rg+pflg,SET,EXIT
fdb0a     d776fe7e         word    w+"~",ISEQ,_IF+03,rg+pflg,CINC,EXIT
fdb16     d776fe60         word    w+"`",ISEQ,_IF+04,_2,rg+pflg,SET,EXIT
fdb24     fe01dac6         word    DZEQ,_1,rg+pflg,BITQ,_AND,IFEXIT
fdb30     d776fe23         word    w+"#",ISEQ,_IF+(ASONE-.L0)/2
fdb36     dacf     .L0     word    AHASH+ex
                           ''      $| command - hexadecimal
fdb38     d776fe24 ASCMD   word    w+"$",ISEQ,_IF+03,_16,rg+pbase,CSTOREX+ex
                           ''      n| multiple # command
fdb44     fe33d772         word    SWFETCH,w+"3",w+"9",WITHIN,_IF+07,SWFETCH,w+"0",MINUS,FOR,AHASH,forNEXT,EXIT
                           ''      *| Convert remaining digits
fdb5c     d776fe2a .L2     word    w+"*",ISEQ,_IF+05,DUP2,_OR,ZEXIT,AHASH,.L2+ex
                           ''      [| send an escape
fdb6c     d776fe5b         word    w+"[",ISEQ,_IF+02,w+$1B,AHOLD+ex
                           ''      @| treat simply as ASCII
fdb76     d776fe40         word    w+"@",ISEQ,_IF+03,OVER,BITS8,AHOLD+ex
                           ''      literal character
fdb82     da5bd772 ASONE   word    SWFETCH,HOLD+ex
                   
                   
fdb86     da5bda1a AHOLD   word    TOCHAR,HOLD+ex
                   
                   
fdb8a     0071012b PRTAST  word    RPOP,DUP,STRLEN,INC2,_1,_ANDN,OVER,PLUS,PUSHR
fdb9c     eb4afd66 PRTAS   word    rg+pflg,CLRC,w+10,rg+pbase,CSTORE
fdba6     00dffd0c         word    rg+double,FETCH,SWAP,LHASH,DUP,STRLEN
fdbb2     00740086         word    DEC,OVER,PLUS,rg+pfmt,STORE,STRLEN
fdbbe     fd68010b         word    FOR,rg+pfmt,FETCH,CFETCH,ASHASH,rg+pfmt,LDEC,forNEXT
fdbce     da7e0067         word    DROP,RHASH,PSTR+ex
fdbd4     db8a013d PRTASR  word    _WORD,PRTAST,COMPW,COMPSTR+ex
                   
fdbdc     db8a     PRTDECL word    PRTAST
fdbde     232c2323         byte    "##,###,###,##~#",0
fdbee     0061             word    EXIT
                   
fdbf0     db8a     PRTDEC4 word    PRTAST
fdbf2     60232323         byte    "###`#",0
fdbf8     0061             word    EXIT
                   
fdbfa     db8a     PRTDEC2 word    PRTAST
fdbfc     00202323         byte    "## ",0
fdc00     0061             word    EXIT
                   {
                   PRTDEC2D
                           word    PRTAST
                           byte    "##.",0
                           word    EXIT
                   }
                   ' Print decimal with at least a single digit
fdc02     db8a     PRTDEC  word    PRTAST
fdc04     00237c2a         byte    "*|#",0
fdc08     0061             word    EXIT
                   
                   
                   
                   
                   
                   
                   
                   
                   '---------------------------------------------------
                   
                   
                   
                   { *** CONSOLE INPUT HANDLERS *** }
                   
                   {
                   Replaced traditional parse function with realtime stream parsing
                   Each word is acted upon when a delimiter is encountered and this also allows for
                   interactive error checking and even autocompletion.
                   }
                   
                   ' SCRUB --- scrub out any temporary compiled code, restore the code pointers etc.
fdc0a     fda1d686 SCRUB   word    ATHERE,rg+codes,STORE
fdc10     eb4afd23         word    rg+wordcnt,CLRC,rg+wordbuf,CLRC
                   ''      restore end-of-line delimiter to a CR
fdc18     fd6dfe0d         word    _13,rg+delim+1,CSTORE
                   ''      print long line of dashes
fdc1e     fe2dd0ce PRTDASH word    CR,w+"-",w+64,EMITS+ex
                   
                   ' ( ch -- ) write a character into the next free position in the word buffer
fdc26     00d8fd23 PUTCHAR word    rg+wordcnt,CFETCHINC,PLUS,CSTOREX+ex
                   
fdc2e              PUTCHARPL
fdc2e     fd23dc26         word    PUTCHAR,rg+wordcnt,DUPCFT,INC
fdc36     00cbfe27         word    w+wordsz,UMOD,SWAP,CSTOREX+ex
                   
                   ' As characters are accepted from the input stream, checks need to be made for delimiters,
                   ' editing commands etc. 123us/CHAR, 184us/CTRL
fdc3e              doCHAR  ' ( char -- flg ) Process char into wordbuf and flag true if all done
                   '       ignore null
fdc3e     005f0071         word    DUP,ZEXIT
                   '       delimiter is always last character
fdc42     fd6d0071         word    DUP,rg+delim+1,CSTORE
                   '       Replace DEL with BS
fdc48     0074fe7f         word    w+$7F,OVER,_EQ,_IF+02,DROP,_8
                   '       only check for control characters
fdc54     fe200071 dch1    word    DUP,_BL,LT,_IF+(ischar-ctrls)/2
                   '
                   ' PROCESS CONTROL CHARACTERS
                   '
fdc5c              ctrls
                   ''              discard LF
fdc5c     0074fe0a         word    w+$0A,OVER,_EQ,SKIPZ,DROPFEX+ex
                   ''              ^W WORDS
fdc66     0074fe17         word    w+$17,OVER,_EQ,_IF+04,DROP,WORDS,CRLF,FALX+ex
                   ''              ^R FIXDICT
                   ''      word    w+$12,OVER,_EQ,_IF+03,DROP,FIXDICT,FALX+ex
                   
                   '               ^X reeXecute previous compiled line
fdc76     0074fe18         word    w+$18,OVER,_EQ,_IF+02,DROP,TRUEX+ex
                   ''              ^C RESET
fdc82     0074fe03         word    _3,OVER,_EQ,SKIPZ,RESET
                   '               ^R RESTORE
fdc8c     0074fe12         word    w+$12,OVER,_EQ,_IF+03,DROP,RESTORE,TERMINAL
                   ''              ^V VERSION
fdc9a     0074fe16         word    w+$16,OVER,_EQ,_IF+02,PRTVER,CONSOLE+ex
                   '               ^D DEBUGGER
fdca6     0074fe04         word    _4,OVER,_EQ,_IF+03,DROP,DEBUGGER,FALX+ex
                   '               ^? DEBUG
fdcb4     0074fe1f         word    w+$1F,OVER,_EQ,_IF+03,DROP,DEBUG,FALX+ex
                   
                   '               ^Q print top stack
fdcc2     0074fe11         word    w+$11,OVER,_EQ,_IF+04,DROP,PRTSTK,CRLF,FALX+ex
                   '               ^S clear Stack
fdcd2     0074fe13         word    w+$13,OVER,_EQ,_IF+03,DROP,INITSP,FALX+ex
                   '               ^B Block dump
fdce0     0074fe02         word    _2,OVER,_EQ,_IF+06,DROP
fdcea     ff00fe00         word    _0,w+$100,_SHL8
fdcf0     d2b9d86e         word    DUMPB,FALX+ex
                   '               ^Z^Z cold start
fdcf4     0074fe1a         word    w+$1A,OVER,_EQ          '''rg,prevch+1,CFETCH,w+$1A,_EQ,_AND
fdcfa     0067fc03         word    _IF+03,DROP,COLDST,RESET        '''SCRUB,FALX+ex
fdd02              ignore2
fdd02     0074fe1b         word    w+$1B,OVER,_EQ,_IF+03,DROP,SCRUB,TRUEX+ex                               ' ESC will cancel line
fdd10     0074fe09 ig01    word    _9,OVER,_EQ,_IF+02,EMIT,_BL                                             ' TAB - substitute with a space
fdd1c     0074fe1c ig02    word    w+$1C,OVER,_EQ,_IF+03,DROP,CRLF,_BL                                     ' ^| - multi-line interactive
fdd2a     0074fe0d ig03    word    _13,OVER,_EQ,_IF+02,DROP,TRUEX+ex                                       ' CR - Return & indicate completion
fdd36              ig04    '
fdd36     0074fe08         word    _8,OVER,_EQ,_IF+(ischar-bksp1)/2                                        ' BKSP - null out last char
fdd3e     00dbfd23 bksp1   word    rg+wordcnt,CFETCH,_IF+09                                                ' don't backspace on empty word
fdd44     d03ed040 bksp2   word    EMIT,SPACE,_8,EMIT                                                      ' backspace and clear
fdd4c     d11efd23         word    rg+wordcnt,CDEC,_0,PUTCHAR                                              ' null previous char
fdd54     d2b9             word    FALX+ex
                           ''                      '
fdd56     d040fe07 bksp3   word    _7,EMIT,DROPFEX+ex                                                      ' can't backspace anymore, bell
                           '
fdd5c     d0defe01 ischar  word    w+echo,CHKFLG,_IF+02,DUP,EMIT                                           ' don't echo if we don't want it
fdd66     00dbfd6c .L0     word    rg+delim,CFETCH,OVER,_EQ                                                ' delimiter? (always accept a blank)
fdd6e     fe200074         word    OVER,_BL,_EQ,_OR,_IF+04,DROP,rg+wordcnt,CFETCH,EXIT                     ' true if trailing delimiter - all done (flg=cnt)
                           '
                           ' otherwise build text in wordbuf - null terminated with a preceding count .....
fdd80     d2b9dc2e .L1     word    PUTCHARPL,FALX+ex                                                       ' put a character into the word buffer
                   
                   ' Build a delimited word in wordbuf for wordcnt and return immediately upon a valid delimiter
fdd84              _GETWORD        ' ( -- str )
                   '       Erase the word buffer & preceding count
fdd84     fe27fd23         word    rg+wordcnt,w+wordsz,ERASE
                           'word   w+6,PEN
                   '       get another character
fdd8a     dc3ee116         word    WKEY,doCHAR,_UNTIL+03
                           'word   PLAIN
fdd90     0061fd24         word    rg+wordbuf,EXIT
                   
                   
                   { ****************** DICTIONARY SEARCH ********************** }
                   
                   ' SEARCH ( cstr -- nfaptr )                                             ' cstr points to the count+strinw+null
fdd94              SEARCH
fdd94     eb52fd7d         word    rg+ufind,QJMP                                           ' use alternative method if enabled (hash search)
fdd98     d68c0071         word    DUP,ATNAMES,FINDSTR
fdd9e     fc020070         word    QDUP,_IF+02,NIP,EXIT                                    ' found it - return now with result
fdda6     d2b90067 DROPFEX word    DROP,FALX+ex                                            ' not found in dictionary
                   
                   
                   
                   
                   
                   ' COLD  Force factory defaults
fddaa     d5aa     COLDST  word    PRTSTR
fddac     6c6f4320         byte    " Cold start",0
                   ''              initialize task registers
                   ''        word    CRLF
fddb8     ff00fd00 	word	rg+temp,w+$100,ERASE
                   ''              free memory                   backup
fddbe     1000013d         word    _WORD,codeorg
fddc2     fd9d0071         word    DUP,rg+here,STORE,rg+here-4,STORE
fddcc     ec7f013d 	word	_word,endcode,DATORG
fddd2     eb32fda5         word    rg+autovec,CLRL,rg+keypoll,CLRW
fddda              FIXDICT         ' Copy dictionary from ROM to area just before copied ROM in bank 0'
fddda     013b             word    _LONG
fdddc     000ff39b         long    romdict
fdde0     013b             word    _LONG
fdde2     0000b400         long    ramdict
fdde6     0b8b013d         word    _WORD,enddict-romdict,CMOVE
fddec     013b             word    _LONG
fddee     0000b400         long    ramdict
fddf2     fd950071         word    DUP,rg+names,STORE,rg+oldnames,STORE
                   '               reset cold start
fddfc     a55a013d         word    _WORD,$A55A,rg+cold,WSTOREX+ex
                   
                   
                   
                   ' Discard the current line
fde04              DISCARD
fde04     00b5e0c4 dslp    word    KEY,_ZEQ,_UNTIL+03                                              ' fast discard
fde0a     d7c0fe14 ds01    word    w+20,ms,KEY,_ZEQ,_UNTIL+08,EXIT                                ' pause and check and repeat if necessarys
                   
fde16     eaca     ATID    word    _COGID
                   ' TASK ( cog -- addr ) Return with address of task control register in "tasks"
fde18     00a5fe03 TASK    word    _3,_SHL,_WORD,tasks,PLUS,EXIT
                   
                   { TASK RECORD
                   0       ENTRY CODE ADDRESS
                   4       flags
                   
                   }
                   
fde24     e8ee     IDLE    word    INITSTKS
fde26     fe08de16         word    ATID,_8,ERASE
fde2c     de16fe01 idlp    word    _1,ATID,_3,PLUS,CPLUSST                         ' increment task+3 to indicate Tachyon running
fde36     d7c0fe0a         word    w+10,ms                                         ' do nothing for a bit - saves power
fde3a     00dede16         word    ATID,WFETCH                                     ' fetch cog's task variable
fde3e     fc8b0070         word    QDUP,_UNTIL+11                                  ' until it is non-zero
fde42     0032             word    ACALL                                           ' Execute
fde44     eb3ede16         word    ATID,CLRW                                       ' clear run address only if it has returned back to idle
fde48     de25             word    IDLE+ex
                   
                   
fde4a     fda5d660 AUTORUN word    TICK,rg+autovec,WSTOREX+ex
                   
fde50     33253130 radix   byte    "01%34567o9#BCDEF$ "
                   
                           ''      List line number if enabled
fde62              PROMPT
                           ''      execute user prompt code
fde62     00defd6f         word    rg+uprompt,WFETCH,QDUP,_IF+02,ACALL,trl1+ex
fde6e     00defdad         word    rg+linenum,WFETCH,_IF+09
                           ''      display line#
fde74     fdadd0ce         word    CR,rg+linenum,WFETCH,PRTDEC4,_4,SPACES
                           ''      increment line#
fde80     d12efdad         word    rg+linenum,WINC,EXIT
                           ''      Prompt with version and base
fde86     d5aa             word    PRTSTR
fde88     4f514154         byte    "TAQOZ",0
                           ''      prompt char = base %#$ etc
fde8e     013dd270         word    GETBASE,_WORD,radix,PLUS,CFETCH,EMIT,SPACE+ex
                   
                   
                   { *** MAIN TERMINAL CONSOLE ***  }
fde9c              TERMINAL
fde9c     e8a6e8fa         word    InitRP,INITSP                                           ' Init the internal stack and setup external stack space
fdea0     fe32d242         word    WP,w+50,ms                                                      ' a little startup delay (also wait for serial cog)
fdea6     d078             word    _CON
fdea8     eb3efd14         word    rg+keypoll,CLRW,rg+accept,CLRW
fdeb0     eb3efdad         word    rg+linenum,CLRW
fdeb4     fd20fe01         word    _1,rg+fflags,WSTORE
                           ''      performing a check for a saved session
fdeba     00defda9         word    rg+cold,WFETCH,_WORD,$A55A
                           ''      defaults
fdec2     fc0100ba         word    _NEQ,SKIPZ,COLDST
                   
                           ''      Show VERSION with optional CLS (default CR)
                           'word   w+3,PEN
fdec8     d0c8             word    CRLF
                           'word   REVERSE
fdeca     d0c8dc1e         word    PRTDASH,CRLF,PRTVER
                   ''      word    _GETRND,rg+bootsig,STORE
                   
                           ''      ^A abort autostart with ^A
fded0     00dbfef0         word    w+lastkey,CFETCH,_1,_NEQ,_IF+(CS1-.L0)/2
                           ''      check for an AUTORUN
fdeda     00defda5         word    rg+autovec,WFETCH,QDUP,SKIPZ,ACALL
                           ''      Set the rx buffer size
fdee4              .L0     ' word  _WORD,rxsize,rg+rxsz,WSTORE
                   ''''        word    DISCARD
fdee4     d268     	word	DECIMAL
                           ''      echo on
fdee6     fd20fe01         word    w+echo,rg+fflags,CSTORE
                           ''      default delimiter is a space character
fdeec     fd6cfe20         word    _BL,rg+delim,CSTORE
                   
                   ''	word	w+"!",w+rxbuffers,CSTORE
                           '
fdef2     dc0ae8fa CONSOLE word    InitRP,SCRUB,CRLF       '',PLAIN
                           ''      Stop compilation
fdef8     d0e4fe80 CS1     word    w+defining,CLRFLG
                           '
                           ' ***   Main console line loop - get a new line (word by word) ***
                           '
                   '-------------------------------------------------------------
                   
                   
fdefc     de62     LINELP  word    PROMPT
                           ''      reset temporary code compilation pointer
fdefe     fda1d686 trl1    word    ATHERE,rg+codes,STORE
                           '
                           ''      Main console loop - read a word and process
fdf04     dd84     WORDLP  word    _GETWORD
fdf06     fd21fe04         word    _4,rg+fflags+1,CLR
                           ''      ignore empty string
fdf0c     00b500db         word    CFETCH,_ZEQ,_IF+(EVAL-.L0)/2
                           ''      ^X then repeat last line
fdf12     00dbfd6d .L0     word    rg+delim+1,CFETCH,w+$18,_NEQ,_IF+(execinp-.L2)/2
                           ''      Otherwise process ENTER
fdf1c     00dbfd6d .L2     word    rg+delim+1,CFETCH,_13,_NEQ,_IF+(chkeol-EVAL)/2
                           ''      good, try to process this as a number first (for speed)
fdf26     00b5d44e EVAL    word    QFNUM,_ZEQ,_IF+(TRYNUM-trm4)/2
                           ''      otherwise search the dicitonary for a match (as a counted string)
fdf2c     0086fd24 trm4    word    rg+wordbuf,DEC,SEARCH
                           ''      found it
fdf32     fc360070         word    QDUP,_IF+(TRYNUM-foundword)/2
                           ''      found the word in the dictionary - compile or execute?
fdf36              foundword
                   '               point to attribute word (CNT,<NAME>,ATR,CPA)
fdf36     d6620071         word    DUP,NFACFA  ' ( cpa cfa )
                           ''      is the immediate bit set?
fdf3a     00db007b         word    SWAP,CFETCH,_6,_SHR,w+preatr,_EQ
                           ''      and comp flag off (not forced to compile with [COMPILE])
fdf46     d0defe40         word    w+comp,CHKFLG,_ZEQ,_AND
                           ''              Fetch and EXECUTE code immediately
fdf4e     0032fc02         word    _IF+02,ACALL,chkeol+ex
                   
fdf54              compword
                           ''      or else COMPILE the wordcode(s) for this word
fdf54     d5f0             word    COMPW
                           ''      reset any forced compile mode via [COMPILE]
fdf56     d0e4fe40         word    w+comp,CLRFLG
                           ''      *** END OF LINE CHECK ***
fdf5a     00dbfd6d chkeol  word    rg+delim+1,CFETCH,_13,_EQ
fdf62     fc040071         word    DUP,_IF+(eol01-.L0)/2
                           ''      Yes, put a space between any user input and response
fdf66     00defd71 .L0     word    rg+accept,WFETCH,SKIPNZ,SPACE
                   ''      word    PROMPT
                           ''      and are we in a definition or interactive?
fdf6e     fe800071 eol01   word    DUP,w+defining,CHKFLG,_AND
                           ''      If not interactive then CRLF (no other response)
fdf76     d0c8fc01         word    SKIPZ,CRLF
                           ''      do not execute if still defining
fdf7a     d0defe80 eol02   word    w+defining,CHKFLG,_ZEQ,_AND
                           ''      wait until CR to execute compiled codes
fdf82     fcc0             word    _UNTIL+(.L0-WORDLP)/2
fdf84              .L0
fdf84              execs   ''      EXECUTE CODE from user input (append an EXIT first)
fdf84     d5f0fe61         word    w+EXIT,COMPW
                           ''      execute wordcodes from beginning
fdf88     0032d686 execinp word    ATHERE,ACALL
                           ''      execute accept vector if 0<>
fdf8c     00defd71         word    rg+accept,WFETCH,QDUP,_IF+02,ACALL,LINELP+ex
fdf98     00defdad         word    rg+linenum,WFETCH,SKIPNZ,OK,LINELP+ex
                   '-------------------------------------------------------------
                   
fdfa2              TRYNUM  ''      Attempt to process this word as a number but check for special literals first (^ ' etc)
fdfa2     d3f4fd24         word    rg+wordbuf,NUMBER,_IF+02
                           ''      is it a number? ( value digits )
fdfa8     df5bd478 compnum word    LITCOMP,chkeol+ex
                   
                           ''      Unknown word or number - try converting case first time
fdfac     00dbfd21 UNKNOWN word    rg+fflags+1,CFETCH,_4,_AND,_ZEQ
fdfb6     fe04fc06         word    _IF+06,_4,rg+fflags+1,CPLUSST
fdfbe     d278fd24         word    rg+wordbuf,TOUPPER,trm4+ex
                           ''      UNKNOWN - try unum vector if set
fdfc4     00defd7b         word    rg+unum,WFETCH,QDUP,_IF+02,ACALL,chkeol+ex
                   '
                   ' Failed all searches and conversions!!!!
                   '
                           ''      interactive or in the middle of a definition?
fdfd0     fd20fe80         word    w+defining,rg+fflags,CFETCH,_AND,_IF+(HUH-nfdef)/2
                           ''      Display position in line of error
fdfda     d5aa     nfdef   word    PRTSTR
fdfdc     20200909         byte    9,9,"  error in ",0
fdfea     0089d68c         word    ATNAMES,INC,PSTR,PRTSTR
fdff2     74612020         byte    "  at ",0
                           ''      Spit out offending word
fdff8     da9efd24         word    rg+wordbuf,PSTR,SPACE
                           ''      discard but echo remainder of line
fdffe     0071e0c4 .L0     word    KEY,DUP,_13,_NEQ,_IF+02,EMIT,.L0+ex
fe00c     0067     .L1     word    DROP
                           ''      count errors and force a new line to display error
fe00e     d12efdab ERROR   word    rg+errors,WINC,w+$10A,EMIT
fe016     d5aa             word    PRTSTR
fe018     72652a20         byte    " *error* ",7,$0D,$0A,$0B,0
                           '
                           ''      force a new line to prevent overwrite then return to console
fe026     d040ff0a         word    w+$10A,EMIT,DISCARD,INITSP,_END,CONSOLE+ex
                   
                           ' as-you-go error prompt in interactive mode
fe032     d5aa     HUH     word    PRTSTR
fe034     3f3f3f20         byte    " ??? ",0
fe03a     df05             word    WORDLP+ex
                   
                   
fe03c     d5aad0c8 PRTSTK  word    CRLF,PRTSTR
fe040     54414420         byte    " DATA STACK (",0
fe04e     0071ec33         word    _DEPTH,DUP,PRINT1
fe054     005f             word    ZEXIT
fe056     0071ec33         word    _DEPTH,DUP,_0
fe05c     d0c80109         word    DO,CRLF,IX,INC,PRINT,_3,SPACES,DEC,DUP,INC4,LUTFETCH,DUP,PRTL,_3,SPACES,PRINT,LOOP
fe07e     d075             word    DROPEX+ex
fe080     fe29da8c PRINT1  word    PRINT,w+")",EMIT+ex
                   
fe086     e03c     PRTSTKS word    PRTSTK
fe088     d5aad0c8 PRTRET  word    CRLF,PRTSTR
fe08c     54455220         byte    " RETURN (",0
fe096     fe14fe40         word    w+retstk,w+retptr
fe09a     0073eab6 PRTSTKX word    COGFETCH,DUP2,SWAP,MINUS,PRINT1
fe0a4     d05afe03 DMPSTK  word    _3,SPACES,SWAP
fe0aa     00ba0073 .L0     word    DUP2,_NEQ,_IF+06,DUP,LUTFETCH,SPACE,PRTL,INC,.L0+ex,DROP2,EXIT
                   
                   
                   {
                   PRTLP   word    CRLF,PRTSTR
                           byte    " LOOP   x",0
                           word    w+lpstk,w+lpptr,PRTSTKX+ex
                   
                   PRTBRA  word    CRLF,PRTSTR
                           byte    " BRANCH x",0
                           word    w+brastk,w+braptr,PRTSTKX+ex
                   }
                   
                   
                   
                   {
                   ' The read and write index is stored as two words preceding the buffer
                   ' BKEY ( buffer -- ch )  byte size buffer is preceded with a read index, go and read the next character
                   ' read[2] write[2] buffer[rxsize]
                   '
                   ' READBUF ( buffer -- ch|$100 )
                   READBUF
                           word    _LONG
                           long    rxbuffers
                           word    DUP,DEC2,DUP,WFETCH                             ' point to read index ( buffer writeptr writeindex )
                           word    SWAP,DEC2,WFETCH,SWAP                           ' ( buffer readindex writeindex )
                           word    OVER,_EQ,_IF+03,DROP2,_0,EXIT                   ' empty, return with null
                           ' ( buffer read )
                   .L1     word    OVER,PLUS,CFETCH                                '  get (buf+rd) character from buffer
                                                                                   ' perform auto LF to CR subs (but not when it is part of a CRLF )
                           word    DUP,w+$0A,_EQ
                           word    rg+prevch,CFETCH,_13,_NEQ,_AND
                           word    _3,_AND,PLUS                                    ' convert the LF to a CR
                   '
                           word    DUP,rg+prevch,WFETCH,_SHL8,_OR,rg+prevch,WSTORE
                           'word   rg+prevch,CFETCH,rg+prevch+1,CSTORE,DUP,rg+prevch,CSTORE
                           word    _WORD,$0100,PLUS                                        ' get char ( buffer [buffer+read]+$100 )
                           word    SWAP,_4,MINUS                                   ' key readptr )
                           word    DUP,WFETCH,INC                                  ' update read index and wrap
                           word    DUP,_WORD,rxsize-1,GT,_IF+02,DROP,_0    ' wraparound'
                   .L2     word    SWAP,WSTOREX+ex
                   }
                   
                   ' KEY! ( ch -- ) Force a character as the next KEY read
fe0c0              PUTKEY
fe0c0     d76ffd73         word    rg+keychar,STOREX+ex
                   
                   ' KEY ( -- ch ) if ch is zero then no key was read
fe0c4              KEY
fe0c4     00dbfd73         word    rg+keychar,CFETCH,QDUP,_IF+06      		' read a "key" that was forced with KEY!
fe0cc     00dffd73         word    rg+keychar,FETCH,_SHR8,rg+keychar,STORE,CHKKEY+ex
fe0d8     00defd12         word    rg+ukey,WFETCH,_IF+06,rg+ukey,WFETCH,ACALL
fe0e4     005c0071 	word 	DUP,IFEXIT,DOPOLL+ex
fe0ea     e93a     CONKEY  word    READRX
fe0ec     fc070071 DOKEY   word    DUP,_IF+07
fe0f0     007100b1         word    BITS8,DUP,_ZEQ,ZEXIT                    	' return as if non-zero
fe0f8     0083ff00         word    w+$0100,PLUS,EXIT                            	' otherwise add $100 to a null
                          '
fe0fe     eb52fd14 DOPOLL  word    rg+keypoll,QJMP                         	' execute background polling while waiting for input
fe102     0061             word    EXIT
                   
                   ' keep a track of the position of the this key on the input line (useful for assembler etc)
fe104     d122fd22 CHKKEY  word    rg+keycol,CINC,DUP,_13,_EQ,ZEXIT,rg+keycol,CLRC,EXIT
                   
                                                           ' background polling while waiting for a key
                   
                   ' WKEY ( -- ch ) wait for a key and return with character
fe116     0070e0c4 WKEY    word    KEY,QDUP,_UNTIL+03,BITS8,EXIT
                   
                   
                   
                   { *** COMMENTING *** }
                   
                   ''      \       ( -- )
                   ''      Ignore following text till the end of line.
                   ''      IMMED
fe120              COMMENT
fe120     00dbfd6d         word    rg+delim+1,CFETCH,_13,_NEQ,ZEXIT                        ' ignore is this is an empty line
fe12a     fe0de0c4 .L0     word    KEY,_13,_EQ,_UNTIL+04                                   ' terminate comment on a CR
fe132     fd73fe0d         word    _13,rg+keychar,STOREX+ex                                ' force a CR back into the key stream on exit
                   
                   ''      (       stack or other short inline comments )
fe138              PAREN
fe138     0071e0c4 .L0     word    KEY,DUP,QEMIT,w+")",_EQ,_UNTIL+06,EXIT
                   
                   ' IFDEF
fe146              IFDEF
fe146     00b5d64c         word    NFATICK,_ZEQ,ZEXIT,BRACE+ex
                   
                   ' IFNDEF
fe14e              IFNDEF
fe14e     d64c             word    NFATICK
fe150     005f             word    ZEXIT
                           ''''
                   ' Block comments - allow nested  operation
                           ''''
fe152              BRACE
fe152     fe01             word    _1                                              ' allow nesting by counting braces
fe154     e116     .LP     word    WKEY                                            ' keep reading each char until we have a matching closing brace
fe156     fe7b0071         word    DUP,w+"{",_EQ,_IF+03,DROP,INC,.LP+ex    ' add up opening braces
fe164     00b3fe7d         word    w+"}",_EQ,SKIPZ,DEC                             ' count down closing braces
fe16c     00b50071         word    DUP,_ZEQ,_UNTIL+15,DROPEX+ex
                   
                   
                   
                   
                   
fe174     d632d64c FORGET  word    NFATICK,GRAB,QDUP,_IF+17
fe17c     00dc0071         word    DUP,DUPCFT,PLUS,INC4,rg+names,STORE
fe188     008300dc         word    DUPCFT,PLUS,INC2,WFETCH,DUP,rg+here,STORE
fe196     0061013d         word    _WORD,EXIT,SWAP,WSTOREX+ex
fe19e              NOTFOUND
fe19e     d5aa             word    PRTSTR
fe1a0     746f6e20         byte    " not found ",0
fe1ac     0061             word    EXIT
                   
                   ' >W
fe1ae     ffff013d TOW     word    _WORD,$FFFF,_AND,EXIT
                   ' L>W
fe1b6     e1ae0071 L2W     word    DUP,TOW,SWAP,_SHR16,EXIT
                   ' W>B ( word bytel byteh )
fe1c0     00b10071 W2B     word    DUP,BITS8,SWAP,_SHR8,BITS8,EXIT
                   
fe1cc     0134e1d6 B2L     word    B2W,PUSHL,B2W,LPOP
fe1d4     00aa     W2L     word    _SHL8
fe1d6     009400aa B2W     word    _SHL8,_OR,EXIT
                   
                   
                   
                   
                   {
                   
                   pub W>L ( loword hiword -- long )               8<<
                   pub B>W ( lobyte hibyte -- word )               8<< OR ;
                   pub B>L ( lobyte byte2 byte3 byte4 -- long  )   B>W >L B>W L> W>L ;
                   
                   }
                   
                   {
                   ' ANSI SUPPORT
                   ESC     word    w+$1B,EMIT,EMIT+ex
                   HOME    word    w+"H"
                   ESCB    word    w+"[",ESC,EMIT+ex
                   PEN     word    w+"3"
                   ACOL    word    ESCB,w+"0",PLUS,EMIT,w+"m",EMIT+ex
                   PAPER   word    w+"4",ACOL+ex
                   UL      word    w+"4",AATR+ex
                   REVERSE word    w+"7",AATR+ex
                   BOLD    word    w+"1",AATR+ex
                   PLAIN   word    w+"0"
                   AATR    word    ESCB,w+"m",EMIT+ex
                   CUR     word    w+"[",ESC,SWAP
                   CUR1    word    SWAP,PRTDEC,EMIT+ex
                   XY      word    w+";",SWAP,CUR,w+"H",CUR1+ex
                   'CLS    word    w+$0C
                   CURSOR  word    w+"?",ESCB,w+25,PRTDEC,_IF+02,w+"h",EMIT+ex,w+"l",EMIT+ex
                   }
                   
                   
                   ' CTYPE ( str cnt -- )
fe1dc     01010108 CTYPE   word    ADO,IX,CFETCH,TOCHAR,EMIT,LOOP,EXIT
                   
                   
fe1ea     0000000a taqoz_version    long    vernum,vertime
                   ' .VER
fe1f2              PRTVER
fe1f2     d5aa             word    PRTSTR
                                   '12345678901234567890123456789012345678901234567890123456789011'
fe1f4     61502020         byte    "  Parallax P2  .:.:--TAQOZ--:.:.  V",0
fe218     e1ea013d         word    _WORD,@taqoz_version,FETCH,PRTAST
fe220     2e237e23         byte    "#~#.#",0
fe226     d05afe09         word    w+9,SPACES,CRLF+ex
                   
                   
                   {
                   00.2488: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................
                   DICTIONARY
                   00.D000: 03 44 55 50 6B 00 04 32 44 55 50 6D 00 04 4F 56    .DUPk..2DUPm..OV
                   00.D010: 45 52 6E 00 04 44 52 4F 50 61 00 05 32 44 52 4F    ERn..DROPa..2DRO
                   00.D020: 50 60 00 04 53 57 41 50 75 00 05 32 53 57 41 50    P`..SWAPu..2SWAP
                   00.D030: 50 0D 03 52 4F 54 7A 00 04 2D 52 4F 54 79 00 03    P..ROTz..-ROTy..
                   }
                   
fe22c     d68cd0c8 WORDS   word    CRLF,ATNAMES
fe230     eb32fdb1         word    rg+spincnt,CLRL
fe234     00defdb1 .l0     word    rg+spincnt,WFETCH,w+70,GT,_IF+03,CRLF,rg+spincnt,CLRW
fe244     fc1100dc         word    DUPCFT,_IF+17
fe248     d12efdb3         word    rg+spincnt+2,WINC
                           '       track width '
fe24c     fe1f00dc         word    DUPCFT,w+cntm,_AND,INC,rg+spincnt,WPLUSST
fe258     00d80071         word    DUP,CFETCHINC,w+cntm,_AND,CTYPE,SPACE,NFACPA,INC2,.l0+ex
fe26a     fdb30067         word    DROP,rg+spincnt+2,WFETCH,SPACE,PRTDEC+ex
                   
fe274     da62da52 PRT3S   word    LHASH,HASH,HASH,HASH,w+".",HOLD,HASHS,RHASH,PSTR+ex
                   
fe286     013dd210 PRTF    word    CLKHZ,_WORD,10000,UDIVIDE,DUP,w+100,UMOD,_IF+02
fe296     e2a1e274         word    PRT3S,.L0+ex
fe29a     00cdfe64         word    w+100,UDIVIDE,PRINT
fe2a0     d5aa     .L0     word    PRTSTR
fe2a2     007a484d         byte    "MHz",0
fe2a6     0061             word    EXIT
                   
fe2a8              ELAPSED
fe2a8     01c5e96e LAPCAL  word    LAPFETCH,LAP,LAP,LAPFETCH,MINUS,EXIT
                   
                   
                   ' .LAP          LAP@  LAP LAP LAP@ -  DUP DEC . ."  cycles = "
fe2b4     e2a8     PRTLAP  word    LAPCAL
fe2b6     d2680071 PRTCYC  word    DUP,DECIMAL,PRINT,PRTSTR
fe2be     63796320         byte    " cycles = ",0,0
                           ''      DUP CLKHZ < IF 100 * 3 >> ELSE
fe2ca     d2100071 REPLAP  word    DUP,CLKHZ,LT,_IF+17,w+100,_MUL,_3,_SHR,.L0+ex
                           ''      CLKHZ U// PRINT DOT #1000 CLKHZ */ PRINT ." sec" EXIT THEN
fe2dc     00c8d210         word    CLKHZ,UDIVMOD,PRINT,DOT,W1000,CLKHZ,MULDIV,PRINT,PRTSTR
fe2ee     00636573         byte    "sec",0
fe2f2     0061             word    EXIT
                           ''      DUP #999999 > IF #1,000,000 U// PRINT DOT  #1000 U/ PRINT ." ms " EXIT THEN
fe2f4     d2040071 .L0     word    DUP,W1000000,EQGT,_IF+11,W1000000,UDIVMOD,PRINT,DOT,W1000,UDIVIDE,PRINT,PRTSTR
fe30c     0020736d         byte    "ms ",0
fe310     0061             word    EXIT
                           '       DUP #999 > IF #1,000 U// PRINT DOT PRINT ." us" EXIT THEN
fe312     d20a0071 .L1     word    DUP,W1000,EQGT,_IF+09,W1000,UDIVMOD,PRINT,DOT,PRINT,PRTSTR
fe326     00207375         byte    "us ",0
fe32a     0061             word    EXIT
                           '       PRINT ." ns "
fe32c     d5aada8c .L2     word    PRINT,PRTSTR
fe330     0020736e         byte    "ns ",0
fe334     0061             word    EXIT
                   
                   ' .ms           LAP@ LAP LAP LAP@ - ~l ;
fe336     e2cbe2a8 PRTMS   word    LAPCAL,REPLAP+ex
                   
                   
                   
                   
fe33a     0000ec7f _datorg long    endcode&$FFFF
fe33e     0000ec7f _datptr long    endcode&$FFFF
                   
fe342     e33e013d ATDAT   word    _WORD,_datptr,FETCHX+ex
fe348     013d0071 DATORG  word    DUP,_WORD,_datorg
fe34e     013d00ea         word    STORE,_WORD,_datptr,STOREX+ex
                   
                   ' pub res ( bytes -- )                  _datptr +! ;
fe356     e33e013d dres    word    _WORD,_datptr,PLUSST,EXIT
                   
                   ' pre words                             [C] GRAB 2* [C] BYTES ;
                   ' pre LONGS                             [C] GRAB 4* [C] BYTES ;
                   ' pre BYTES ( bytes <name> -- )         [C] GRAB DATPTR SWAP res [C] DATCON ;
fe35e     00acd632 dlongs  word    GRAB,_SHL1
fe362     00acd632 dwords  word    GRAB,_SHL1
fe366     e342d632 dbytes  word    GRAB,ATDAT,SWAP,dres,_DATCON+ex
fe370     e367fe01 dbyte   word    _1,dbytes+ex
fe374     e367fe02 dword   word    _2,dbytes+ex
fe378     e367fe04 dlong   word    _4,dbytes+ex
                   
                   
                   
                   
fe37c     fd20fe01 _ECHO   word    w+echo,rg+fflags,ROT,BITST,EXIT
                   
                   ' TAQOZ marks the start of a block of source code to be compiled in block mode
                   '
fe386              _TAQOZ
fe386     e1f2             word    PRTVER
                           ''      disable background keypoll during load & reset error count
fe388     eb3efd14         word    rg+keypoll,CLRW,rg+errors,CLRW
                           ''      remember code position for reporting
fe390     fd99d686         word    ATHERE,rg+fromhere,STORE
                           ''      reset line# to 1 to active
fe396     fdadfe01         word    _1,rg+linenum,WSTORE,_0,_ECHO
                           ''      backup dictionary pointer
fe3a0     fd91d68c         word    ATNAMES,rg+oldnames,STORE
                           ''      time the load
fe3a6     fdb1e9c2         word    _GETCNT,rg+spincnt,STORE,EXIT
                   
                   ' end of block load mode  TAQOZ <source> END
                   '
fe3ae     e37c013f _END    word    _TRUE,_ECHO
                           ''      read linenum and clear to exit line mode
fe3b2     00defdad         word    rg+linenum,WFETCH,rg+linenum,CLRW
fe3ba     dc02d0c8         word    CRLF,PRTDEC,PRTSTR
fe3c0     6e696c20         byte    " lines and ",0
fe3cc     fd99d686         word    ATHERE,rg+fromhere,FETCH,MINUS,PRTDECL,PRTSTR
fe3d8     74796220         byte    " bytes compiled,  with ",0
fe3f0     00defdab         word    rg+errors,WFETCH,PRTDEC,PRTSTR
fe3f8     72726520         byte    " errors in ",0
                           ''      report compile time
fe404     fdb1e9c2         word    _GETCNT,rg+spincnt,FETCH,MINUS,CLKKHZ,UDIVIDE,PRTDECL,PRTSTR
fe414     0020736d         byte    "ms ",0
fe418     d0e5fe02         word    _2,CLRFLG+ex
                   
                   
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   
                   
                   ''''''''''''''''' SERIAL FLASH '''''''''''''''''''''
                   {
                   spi_cs          =       0              'pin SPI memory select          (also sd_ck)
                   spi_ck          =       3              'pin SPI memory clock           (also sd_cs)
                   spi_di          =       1              'pin SPI memory data in         (also sd_di)
                   spi_do          =       2              'pin SPI memory data out        (also sd_do)
                   
                   flashpins	= spi_cs<<24+spi_do<<16+spi_di<<8+spi_ck
                   }
                   
                           ''( &cs.so.si.ck -- )
fe41c     e42c013d SFPINS  word    _WORD,_sfpins,STORE,EXIT
                   
fe424     fe06e446 SFWE    word    SFBSY,w+6,SFINS
fe42a     013b     SFINS   word    _LONG
fe42c     3d3a3b3c _sfpins long    flashpins
fe430     01b7ea76         word    SPIPINS,SPICE,SPIWR8,EXIT
                           '' SFWE ( ins -- )
fe438     d09dfe04 SFWD    word    _4,SPINNER+ex
                   
fe43c     fe05     SFSTAT  word    _5
fe43e     fe00e42a SFRD1   word    SFINS,_0,SPIRD,SPIX+ex
fe446     00b5e43c SFBSY   word    SFSTAT,_ZEQ,_UNTIL+03,EXIT
                   
                           ''( sfadr dst cnt -- ) '' read block from SF to RAM
fe44e     fe03007f SFRDBLK word    ROT,_3,SFINS,SPIWM,SPIRX
fe458     006101b7 SPIX    word    SPICE,EXIT
                   
                           ''( Read serial Flash serial number )
fe45c     e42afe4b SFSID   word    w+$4B,SFINS
fe460     0191fe00 SFRDD	word	_0,SPIRDL,SPIRDL
fe466     0191fe00 SFRDL	word	_0,SPIRDL,SPIX+ex
                           ''( Read serial Flash Jedec ID )
fe46c     e42afe9f SFJID   word    w+$9F,SFINS,SFRDL+ex
fe472     d810e46c PRTSF	word	SFJID,PRTL,SPACE,SFSID,PRTL,DOT,PRTL+ex
                   
                           ''( addr -- )
fe480     fe20     SFER4   word    w+$20
fe482     01a6e424 SFER    word    SFWE,SPIWM,SPIX+ex
                           ''( addr -- )
fe488     e483fe52 SFER32  word    w+$52,SFER+ex
                           '' SFER64K ( addr -- )
fe48c     e483fed8 SFER64  word    w+$D8,SFER+ex
                   
fe490     e424fec7 SFERALL word    w+$C7,SFWE,SPIX+ex
                   
                           '' SFRDS ( sfsrc hubdst bytes -- )
fe496     e4fc007f SFRDS   word    ROT,SFRD,ADO,_0,SPIRD,IX,CSTORE,LOOP,SPIX+ex
                   
                           '' SFWRPAGE ( src dst -- )
fe4a8     e424fe02 SFWRPAGE word   w+$02,SFWE,SPIWM,w+256,SPITX,SPIX+ex
                   
                   	'' RESTORE TAQOZ from FLASH by copying to $1.0000 first'
fe4b4     013dd222 RESTORE	word	BRORG,_WORD,$1000,PLUS,_WORD,$1000,_WORD,$F000,SFRDS,EXIT
                   
                           '' BACKUP the first 64K of memory into flash
                           '' Write block 0 to Flash block 0
fe4c8     e48cd222 BACKUP  word    BRORG,SFER64,_0,BRORG,w+64,KB
                           ''SFWRS ( hubsrc sfdst cnt -- )
fe4d4     007b007f SFWRS   word    ROT,SWAP,ADO,IX,OVER,SFWRPAGE,SPINNER,w+256,PLUS,w+256,PLOOP,DROP,EXIT
fe4ee     0193fe00 SFRDW   word    _0,SPIRD,_0,SPIRD,_SHL8,_OR,EXIT
                           '' SFR ( addr -- )
fe4fc     e42afe03 SFRD    word    _3,SFINS,SPIWM,EXIT
                           '' SFC@
fe504              SFCFETCH
fe504     fe00e4fc         word    SFRD,_0,SPIRD,SPIX+ex
                           ''pub SFW@
fe50c              SFWFETCH
fe50c     e4eee4fc         word    SFRD,SFRDW,SPIX+ex
                   
                           ''pub SF@ ( addr -- long )
fe512     e4eee4fc SFFETCH word    SFRD,SFRDW,SFRDW,_SHL8,_SHL8,_OR,SPIX+ex
                   
                           '' SF  Select Serial Flash as memory for DUMP words
fe520     e504d852 SF      word    SETDMP,SFCFETCH,SFWFETCH,SFFETCH
                   
                   
                   
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   '''''''''''''''''''''''''' SD CARD SUPPORT '''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   CON
                   SDCS	= w|sd_cs
                   SDCK	= w|sd_ck
                   SDBUFS	= $10000
                   
                   dtk	= w|$FE
                   
                   DAT
                   
fe528     014d     BLKSIZ	word	CONL
fe52a     00000200 	long	512
                   
fe52e     014d     _sdpins	word	CONL
fe530     3c3a3b3d 	long	sdpins
                   
fe534     00000153 ocr	word	VARB,0,0
                   
fe53a     00000153 sdcrc	word	VARB,0
fe53e     00000153 sdcmd	word	VARB,0
fe542     00000153 _sdrd	word	VARB,0[2]
fe548     00000153 _sdwr	word	VARB,0[2]
fe54e     00000153 csd	word	VARB,0[8]
fe560     00000153 cid	word	VARB,0[8]
                   
fe572     00000000 seccrcs	long	0[4]
fe582     014d     seccrc	word	CONL
fe584     000fe572 	long	seccrcs
                   
                   
fe588     00000000 sdsum	long	0
fe58c     00000000 wrflgs	long	0
fe590     00000000 sectors	long	0[4]
                   
                   
fe5a0     014d     wrflg	word	CONL
fe5a2     000fe58c 	long	wrflgs
fe5a6     014d     _sector	word	CONL
fe5a8     ffffffff 	long	-1
fe5ac     014d     SDBUF	word	CONL
fe5ae     00010000 	long	SDBUFS
                   
                   ' pub SD? ( -- flg )		*SDCS PIN L 200 WAIT F 200 WAIT R H ;
fe5b2     e9d2fe3c SDQ	word	SDCS,_PIN,L,w+200,WAIT,F,w+200,WAIT,R,H,EXIT
                   
                   ' pri SDCLK
fe5c8     01b0013f SDCLK	word	MINUS1,SPIWR,EXIT
fe5ce     e5c8     SDCLK3	word	SDCLK
fe5d0     e5c9e5c8 SDCLK2	word	SDCLK,SDCLK+ex
                   
                   ' pri TOKEN ( marker -- flgX )
fe5d4     4e20013d TOKEN	word	_WORD,20000
fe5d8     fe000074 tklp	word	OVER,_0,SPIRD,_NEQ,_IF+07,DEC,DUP,_ZEQ,_IF+02,NIP,EXIT
fe5ee     e5d9     	word	tklp+ex
fe5f0     ffff0066 	word	DROP2,TRUE,EXIT
                   
                   ' pub ACMD ( data acmd -- res )
fe5f6     fe37fe00 ACMD	word	_0,w+55,CMD,DROP
                   ' pub CMD    ( data cmd -- res )
fe5fe     e53e0071 CMD	word	DUP,sdcmd,CSTORE
fe604     ea76e52e 	word	_sdpins,SPIPINS,SDCLK
fe60a     01a401ac 	word	SPIWRC,SPIWRL
fe60e     00dbe53a 	word	sdcrc,CFETCH,SPIWR8
fe614     0193fe00 SDRES	word	_0,SPIRD,BITS8,DUP,w+$FF,_NEQ,_UNTIL+06,EXIT
                   
                   
                   ' pri STAT@ ( -- stat )
fe624     fe0dfe00 SDSTAT	word	_0,w+13,CMD,SDRES,_SHL8,_OR,EXIT
                   '' pri SDERR? ( -- flg ; return SD bit flag errors)
fe632     e5b2fe00 SDERRQ	word	_0,SDQ,_ZEQ,_1,_AND,_OR
fe63e     00dfe542 	word	_sdrd,FETCH,_ZEQ,_2,_AND,_OR
fe64a     00dfe548 	word	_sdwr,FETCH,_ZEQ,_4,_AND,_OR
fe656     00dfe534 	word	ocr,FETCH,_ZEQ,_8,_AND,_OR
fe662     0061     	word	EXIT
                   '' pri SD4@ ( -- long )			0 SPIRD SPIRD SPIRD SPIRD ;
fe664     0193fe00 SDRD4	word	_0,SPIRD,SPIRD,SPIRD,SPIRD,EXIT
                   '' pri SDDAT! ( adr -- ) read info into memory
fe670     e5d4fefe SDDATST	word	dtk,TOKEN,_IF+09,w+16,ADO,_0,SPIRD,IX,CSTORE,LOOP,SDCLK3,EXIT
fe688     00610067 	word	DROP,EXIT
                   
fe68c     eb46e53e INITSX	word	sdcmd,SETC
fe690     010bfe05 	word	_5,FOR,w+$95,sdcrc,CSTORE,_0,_0,CMD,_1,_EQ,QNEXT,ZEXIT
fe6a8     010bfe05 	word	_5,FOR,w+$87,sdcrc,CSTORE,w+$1AA,_8,CMD,_1,_EQ,QNEXT,ZEXIT
fe6c0     ffaae664 	word	SDRD4,w+$1AA,_EQ,ZEXIT
fe6c8     013dfe00 	word	_0,_WORD,1000,_0,DO
fe6d2     00aefe1e 	word	w+30,MASK,w+41,ACMD,_IF+09,SPICE,SDCK,_PIN,w+200,FOR,H,L,forNEXT,isd1+ex
fe6ee     01260089 	word	INC,LEAVE
fe6f2     005f0114 isd1	word	LOOP,ZEXIT
fe6f6     fe3afe00 	word	_0,w+58,CMD,IFEXIT,SDRD4,DUP,ocr,STORE,ZEXIT
fe708     fe0afe00 	word	_0,w+10,CMD,_ZEQ,_IF+02,cid,SDDATST
fe716     fe09fe00 	word	_0,w+9,CMD,_ZEQ,_IF+02,csd,SDDATST
fe724     0061     	word	EXIT
                   
                   '' Initialise the SD card in SPI mode and return with the OCR
                   '' pub !SD ( -- ocr|false )
fe726     ea76e52e INITSD	word	_sdpins,SPIPINS
                   	'word	_WORD,sdvars,w+32,ERASE
fe72a     fe04e5ac 	word	SDBUF,_4,_SHL9,ERASE	' erase all n file buffers
fe732     e590013d 	word	_WORD,sectors,w+16,w+$FF,CFILL,MINUS1,_sector,STORE
fe742     fc09e5b2 	word	SDQ,_IF+09,w+20,FOR,INITSX,sdcmd,CFETCH,w+9,_EQ,QNEXT,DROP
fe758     00dfe534 	word	ocr,FETCH,EXIT
                   
                   '' pub SDWR    ( src sect -- flg ; Write from src to xdst in the SD )
fe75e     e5ce     SDWR	word	SDCLK3
fe760     e5fefe18 	word	W+24,CMD,_ZEQ,_IF+12
fe768     fefee5ce 	word	SDCLK3,dtk,SPIWR8,BLKSIZ,SPITX
fe772     e5d4fe00 	word	_0,TOKEN,w+$FF,TOKEN,_AND,sdwr1+ex
fe77e     fe00     	word	_0
fe780     e5480071 sdwr1	word	DUP,_sdwr,STORE,SPIX+ex
                   '' pri SDRDBK ( dst -- crc|flg )	BLKSIZ SPIRX sdsum ! 0 SPIRD SPIRD 1 OR ;
fe788     0186e528 SDRDBK	word	BLKSIZ,SPIRX,_WORD,sdsum,STORE,_0,SPIRD,SPIRD,_1,_OR,EXIT
                   
                   '' pub FLUSH ( force -- )		wrflg C@ OR IF SDBUF @sector @ SDWR DROP wrflg C~ THEN ;
fe79e     00dbe5a0 FLUSH	word	wrflg,CFETCH,_OR,ZEXIT,SDBUF,_sector,FETCH,SDWR,DROP,wrflg,CLRC,EXIT
                   
                   '' pub SECTOR ( sect -- )
fe7b6     e5a60071 SECTOR	word	DUP,_sector,FETCH,_EQ,_IF+02,DROP,EXIT
fe7c4     e79efe00 	word	_0,FLUSH,DUP,_sector,STORE,SDBUF
                   '' pub SDRD    ( sector dst --  )
fe7d0     fe11007b SDRD	word	SWAP,w+17,CMD,DUP,_ZEQ,_IF+11
fe7dc     e6140067 	word	DROP,SDRES,dtk,_EQ,_IF+02,SDRDBK,sdrd1+ex
fe7ea     e624e5d0 	word	SDCLK2,SDSTAT,DROP2,_0
fe7f2     0071e5c8 sdrd1	word	SDCLK,DUP,_sdrd,STORE,seccrc,STORE,SPIX+ex
                   
                   '' pub SDRDS    ( sector dst cnt -- crc | false )
fe800     d678e528 SDRDS	word	BLKSIZ,_ALIGN,_SHR9
fe806     007b007e 	word	ROT2,SWAP,w+18,CMD,_IF+03,DROP2,FALSE,.sd1+ex
fe816     fefee614 	word	SDRES,dtk,_EQ,_IF+09,SWAP,FOR,DUP,SDRDBK,DROP,BLKSIZ,PLUS,forNEXT,.sd1+ex
fe830     e5d00066 	word	DROP2,SDCLK2,SDSTAT,DROP,SPICE,_0
fe83c     01b7e5c8 .sd1	word	SDCLK,SPICE
fe840     e5420071 	word	DUP,_sdrd,STORE
fe846     fe0cfe00 	word	_0,w+12,CMD,_ZEQ,_UNTIL+5,SPIX+ex
                   '' SDWRS ( hubsrc sdadr cnt -- )
fe852     d678e528 SDWRS	word	BLKSIZ,_ALIGN,_SHR9
fe858     01010108 	word	ADO,IX,SECTOR,DUP,SDBUF,BLKSIZ,CMOVE
fe866     e528e79e 	word	FLUSH,BLKSIZ,PLUS,LOOP,DROP,EXIT
                   
                   
                   
fe872     eb46e5a0 SDADRW	word	wrflg,SETC
                   '' pub SDADR ( xaddr -- addr )	L>S ( @SECTOR + ) SECTOR SDBUF + ;
fe876     e7b6eae6 SDADR	word	L2S,SECTOR,SDBUF,PLUS,EXIT
                   '' pub SD@ ( xaddr -- long )	RDSDA @ ;
fe880     00dfe876 SDFETCH	word	SDADR,FETCH,EXIT
fe886     00eae872 SDSTORE	word	SDADRW,STORE,EXIT
fe88c     00dbe876 SDCFETCH word	SDADR,CFETCH,EXIT
fe892     00e2e872 SDCSTORE word	SDADRW,CSTORE,EXIT
fe898     00dee876 SDWFETCH word	SDADR,WFETCH,EXIT
fe89e     e88cd852 SD      word    SETDMP,SDCFETCH,SDWFETCH,SDFETCH
                   
                   
                   
                   {
                   
                   
                   }
                   
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   ''''''''''''''''''''''''''''''''''''''''
                   
                   
                   '
                   '***************************************** HUBEXEC CODE ***************************
                   '
fe8a6                              alignw
fe8a6              _wordcode
                   
                   
                   ' !SP - init the data stack pointer
fe8a6     f6042200 INITSP          mov     datptr,#datstk
fe8aa     f6042a00                 mov     depth,#0
fe8ae     ff6f56df         _ret_   mov     tos,##$DEADBEEF         	' marker
fe8b2     06044aef 
                   
                   
fe8b6              InitTaqoz
fe8b6     fd601601                 cogid   fx
fe8ba     fed0f566                 loc     PTRA,#@IDLE&$FFFF               ' default startup into Instruction Pointer
fe8be     fb9c160b                 tjnz    fx,#INITSTKS
                   ' COG 0 CONSOLE '
fe8c2     fd647c41                 dirh    #tx_pin                 	'set tx output high
fe8c6     fed0f5d2                 loc     PTRA,#@TERMINAL&$FFFF
fe8ca     fd647e41 		dirh    #rx_pin
                   		'setse1	#%001_111111
fe8ce     fa9c3c3f 		rdpin	fz,#rx_pin wc			' clear rx?
fe8d2     fd640025 		setint1	#0
fe8d6     f6044000 		mov 	rxwrC,#0
fe8da     fc64400c 		wrlong 	rxwrC,#rxrd
                   
fe8de     fd677e20 		setse1  #%110<<6+rx_pin        		'set se1 to trigger on  rx char event?????
fe8e2     ff0007f4                 mov     ijmp1,##@taqoz_rxisr     	'set int1 jump vector to receive buffer
fe8e6     f607e8fe 
fe8ea     fd640825 		setint1	#4
                   
fe8ee     fdbfffb4 INITSTKS        call    #INITSP
fe8f2     f6042630 INITLP          mov     lpptr,#lpstk
fe8f6     f6042420                 mov     braptr,#brastk
fe8fa     06042840 INITRP  _ret_   mov     retptr,#retstk
                   
fe8fe     f0643a08 taqoz_rxisr	shl 	rxlong,#8
fe902     fa8c3c3f                 rdpin   fz,#rx_pin       		' recv byte (bits31:24) from rx pin
fe906     f0443c18 		shr	fz,#24
fe90a     f5483a1e 		or	rxlong,fz wz
fe90e     ff0d8d8d 		cmp	rxlong,##$1B1B1B1B wz
fe912     f20c3b1b 
fe916     af0007f6 	if_z	coginit #0,##@RESET
fe91a     acec007f 
fe91e     f6003e20 		mov	rxwrP,rxwrC
fe922     f1043e10 		add	rxwrP,#rxbuffers
fe926     fc403c1f 		wrbyte	fz,rxwrP
fe92a     ff000007 		incmod	rxwrC,##rxsize-1
fe92e     f70441ef 
fe932     fc54400e 		wrword	rxwrC,#rxwr
fe936     fb3bfff5 		reti1
                   
                   
fe93a     fae4180c READRX		rdword	r0,#rxrd
fe93e     f2081820 		cmp	r0,rxwrC wz
fe942     ad900018 	if_z	jmp	#@rr1
fe946     f6001a0c 		mov	r1,r0
fe94a     f1041a10 		add	r1,#rxbuffers
fe94e     fac0140d 		rdbyte	acc,r1
fe952     ff000007 		incmod	r0,##rxsize-1
fe956     f70419ef 
fe95a     fc54180c 		wrword	r0,#rxrd
fe95e     fd800140 rr1		jmp	#PUSHACC
                   
fe962     fd640025 DEBUGGER	setint1	#0
fe966     fd8fca5c 		jmp 	#\_Start_Monitor	' \ forces absolute address '
                   
                   
                   
                   ' Registers can be used just like variables and the interpreted kernel uses some for itself
                   ' 128+ bytes are reserved. Since the registers are pointed to by "regptr" they can relocated
                   ' REG ( index -- addr ) Find the address of the register
fe96a     01004a09 ATREG   _ret_           add     tos,regptr
                   
fe96e     f6001616 LAPFETCH                mov     fx,lap1
fe972     f1801617                         sub     fx,lap2
fe976     fd800143                         jmp     #pushx
                   
                   ' COGSTOP ( cog -- )
fe97a     fd604a03 _COGSTOP                cogstop tos
fe97e     fd800067                         jmp     #DROP
                   
                   ' COGINIT ( addr cog -- )
fe982     fce04a26                         coginit tos,tos1
fe986     fd800066                         jmp     #DROP2
                   
                   ' COGATN ( mask -- )
fe98a     fd604a3f _COGATN                 cogatn  tos
fe98e     fd800067                         jmp     #DROP
                   
                   ' POLLATN ( -- flg )
fe992     fd701c24 _POLLATN                pollatn wc
fe996     c1841401                 if_c    sub     acc,#1
fe99a     fd800140                         jmp     #PUSHACC
                   
                   '' SETEDG ( edge pin -- ) add 4 to edge for lock
fe99e     f0644c06 _SETEDG                 shl     tos+1,#6
fe9a2     f1004a26                         add     tos,tos+1
fe9a6     fd604a20                         setse1  tos
fe9aa     fd800066                         jmp     #DROP2
                   
                   '' POLLEDG ( -- flg )
fe9ae     fd700824 _POLLEDG                pollse1 wc
fe9b2     c1841401                 if_c    sub     acc,#1
fe9b6     fd800140                         jmp     #PUSHACC
                   
fe9ba              WAIT ''( clks -- )
fe9ba     fd604a1f                         waitx   tos
fe9be     fd800067                         jmp     #DROP
                   
fe9c2     fd60161a _GETCNT                 GETCT   fx
fe9c6     fd800143                         jmp     #PUSHX
                   
                   
                   
                   
                   ' some smartpin support for high level
                   ' @PIN ( -- pin )
fe9ca     f6001618 _ATPIN                  mov     fx,pinreg
fe9ce     fd800143                         jmp     #PUSHX
                   
                   '' PIN ( pin -- )
fe9d2     f6003025 _PIN                    mov     pinreg,tos
fe9d6     fd800067                         jmp     #DROP
                   
fe9da     f6003225 _CLK                    mov     tepin,tos
fe9de     fd800067                         jmp     #DROP
                   
                   ' WRACK ( data -- )     Write smartpin data and wait for empty then ack
fe9e2     fc204a18 WRACK                   wypin   tos,pinreg
fe9e6     fd703040 .wait                   testp   pinreg  wc              '..wait for buffer empty
fe9ea     3d9ffff8         	if_nc   jmp     #.wait
fe9ee     fc080218                         akpin   pinreg                  '..acknowledge pin
fe9f2     fd800067                         jmp     #DROP
                   
                   {
                   CONEMIT
                                   wypin   tos,#tx_pin             '..send byte
                   .wait           testp   #tx_pin         wc      '..wait for buffer empty
                    if_nc          jmp     #.wait
                                   akpin   #tx_pin                 '..acknowledge pin
                                   jmp     #DROP
                   }
                   
fe9f6     fd605c68 _RND                    xoro32  seed
fe9fa     f600162e                         mov     fx,seed
fe9fe     fd800143                         jmp     #PUSHX
                   
                   ' SKIPNZ ( flg -- ) Skip if flg is true ( replace 0= IF xxx THEN )
fea02     fb944a01 SKIPNZ                  tjz     tos,#.L0
fea06     f107f002                         add     PTRA,#2
fea0a     fd800067 .L0                     jmp     #DROP
                   
                   
                   
                   ' > ( n1 n2 -- flg )
fea0e     f2504a26 GT                      cmps    tos,tos1 wc
fea12     fd90000c                         jmp     #CFLG
                   ' < ( n1 n2 -- flg )
fea16     f2504c25 LT                      cmps    tos1,tos wc
fea1a     fd900004                         jmp     #CFLG
                   ' U< ( u1 u2 -- flg )
fea1e     f2104c25 _ULT                    cmp     tos1,tos wc
fea22     f1a04c26 CFLG                    subx    tos1,tos1
fea26     fd800067                         jmp     #DROP
                   
                   
                   ' main division sub - called both by U/ and U//
                   ' double div, single divisor
                   ' By specifing bits and left justifying the routine can be adapted and run faster
                   ' CLKHZ 1234 LAP U// LAP .LAP  27.400us ok --> 18.800us
                   
                   ' UM/MOD64 ( Dbl.dividend divisor -- remainder Dbl.quotient)
fea2a     f6041420 UMDIVMOD64      mov     ACC,#32
fea2e     f1041420 UMDIVMOD32      add     ACC,#32
fea32     f6001825                 mov     R0, tos         ' R0 = divisor
fea36     f6001a27                 mov     R1, tos2                ' R1R2 = dividend
fea3a     f6001c26                 mov     R2, tos1
fea3e     f6044e00                 mov     tos2, #0                                ' remainder
                   
fea42     f0741a01 udmlp           shl     R1, #1 wc                       ' dividend msb
fea46     f0b41c01                 rcl     R2, #1 wc
fea4a     f0a44e01                 rcl     tos2, #1                        ' hi bit from dividend
fea4e     f2f04e0c                 cmpsub  tos2, R0   wc                   ' cmp divisor ( R0 - tos & c set if tos => R0 )
fea52     f0b44c01                 rcl     tos1, #1 wc                             ' R1 = quotient l
fea56     f0a44a01                 rcl     tos, #1                         ' R2 = quotient h
fea5a     0b6c15f9         _ret_   djnz    ACC,#udmlp
                   
                   ' DSWAP ( n1 n2 n3 n4 -- n3 n4 n1 n2 )
fea5e     f6001825 DSWAP                   mov     R0,tos
fea62     f6001a26                         mov     R1,tos1
fea66     f6004a27                         mov     tos,tos2
fea6a     f6004c28                         mov     tos1,tos3
fea6e     f6004e0c                         mov     tos2,R0
fea72     0600500d                 _ret_   mov     tos3,R1
                   
                   {
                   ' Testing big-bashed TX(+TE) in conjunction with continuous smartpin RX
                   ' assuming porta is used at present - using current PIN in pinreg
                   ' SEROUT ( ch -- )
                   SEROUT          dirh    pinreg          ' make sure transmit is an output
                                   outh    tepin           ' enable RS485 transmit if selected
                                   bith    tos,#8          ' add stop bit
                                   shl     tos,#1          ' insert start bit
                                   getct   r1
                                   rep     @.sn1,#10
                                    testb  tos,#0 wz       ' test next bit to send
                                    drvnz  pinreg          ' set/clr txd
                                    addct1 r1,pinticks
                                    waitct1
                                    shr    tos,#1
                   .sn1            outl    tepin           ' receive
                                   dirl    pinreg
                                   jmp     #DROP
                   
                   SERBAUD '( baud -- )    ' (sys_clk / baud_rate)-6
                                   qdiv    ##sys_clk,tos
                                   getqx   fx
                                   sub     fx,#6
                                   mov     pinticks,fx
                                   jmp     #DROP
                   }
                   
                   
fea76              SPIPINS ' ( long --- ) sets bit numbers for SPI mode from bytes in long as cs.mi.mo.ck
fea76     fdb00030                 call    #.SPSET
fea7a     fd601658                 drvl    fx              ' clock low
fea7e     f600040b                 mov     sck,fx          ' setup SCK clock
                                   '
fea82     fdb00024                 call    #.SPSET
fea86     fd601659                 drvh    fx              ' leave high
fea8a     f600060b                 mov     mosi,fx         ' setup MOSI data to slave
                                   '
fea8e     fdb00018                 call    #.SPSET
fea92     fd601640                 dirl    fx              ' input
fea96     f600080b                 mov     miso,fx         ' MISO
                                   '
fea9a     fdb0000c                 call    #.SPSET
fea9e     fd601659                 drvh    fx              ' chip select high
feaa2     f6000a0b                 mov     ss,fx           ' SS
feaa6     fd800067                 jmp     #DROP
                   
feaaa     f6001625 .SPSET          mov     fx,tos
feaae     f50416ff                 and     fx,#$FF
feab2     00044a08         _ret_   ror     tos,#8
                   
                   {               testb   ss,#5 wz
                           if_z    bith    outa,ss
                           if_nz   bith    outb,ss
                                   ret
                   }
                   
                   {
                   PAFETCH                 mov     fx,INA
                                           jmp     #PUSHX
                   PBFETCH                 mov     fx,INB
                                           jmp     #PUSHX
                   PASTORE                 mov     OUTA,tos
                                           jmp     #DROP
                   PBSTORE                 mov     OUTA,tos
                                           jmp     #DROP
                   DACLR                   andn    DIRA,tos
                                           jmp     #DROP
                   DBCLR                   andn    DIRB,tos
                                           jmp     #DROP
                   ' ( mask -- )
                   PASET                   or      OUTA,tos
                   DASET                   or      DIRA,tos
                                           jmp     #DROP
                   
                   PBSET                   or      OUTB,tos
                   DBSET                   or      DIRB,tos
                                           jmp     #DROP
                   
                   PACLR                   andn    OUTA,tos
                                           jmp     #DASET
                   PBCLR                   andn    OUTB,tos
                                           jmp     #DBSET
                   }
                   
                   { *** COG ACCESS *** }
                   
feab6     f9944a00 COGFETCH                alts    tos,#0
feaba     06004a00                 _ret_   mov     tos,0_0
                   
                   '' COG! ( long addr -- ) Store a long to cog memory
feabe              COGSTORE
feabe     f98c4a00                         altd    tos,#0
feac2     f6000026                         mov     0_0,tos+1
feac6     fd800066                         jmp     #DROP2
                   
                   
feaca     fd601601 _COGID                  cogid   fx
feace     fd800143                         jmp     #PUSHX
                   
                   
                   '' _COGINIT ( dest cog -- )
fead2     fce04a26 _COGINIT                coginit tos,tos1
fead6     fd800066                         jmp     #DROP2
                   
                   '' DELTA ( delta -- )   Calculate and set the cnt delta and waitcnt
feada     fda00067 DELTA                   call    #POPX
feade     f600200b                         mov     deltaR,fx
                   '' WAITCNT ( -- )
feae2     0d60201f WAITCNTS        _ret_   waitx   deltaR          '' continue from last count (must be called before target is reached)
                   
                   
                   {
                   
                   ' OUTCLR ( iomask  -- ) Clear multiple bits on the output
                   OUTCLRA         andn    OUTA,tos
                                   or      DIRA,tos
                                   jmp     #DROP
                   
                   '' OUTSET ( iomask  -- ) Set multiple bits on the output
                   OUTSETA         or      OUTA,tos
                    ' OUTPUTS ( iomask  -- ) Set selected port pins to outputs
                                   or      DIRA,tos
                                   jmp     #DROP
                   
                   
                   ' INPUTS ( iomask -- ) Set selected port pins to inputs
                   INPUTSA         andn    DIRA,tos
                                   jmp     #DROP
                   
                   }
                   
                   
                   
                   ' L2S ( n -- lsb9 h ) specialized operation for filesystem addresses
feae6     f6001625 L2S                     mov     fx,tos
feaea     f5044bff                         and     tos,#$1FF
feaee     f0441609                         shr     fx,#9
feaf2     fd800143                         jmp     #PUSHX
                   
                   ' L2W   word    DUP,TOW,SWAP,_SHR16,EXIT
                   
                   {
                   ' SHIFT from INPUT - Assembles with last bit received as msb - needs SHR to right justify if asynch data
                   ' SHRINP ( pin dat -- pin dat/2 )
                   SHRINP                  testp   tos1 wc
                                           rcr     tos,#1
                                           ret
                   }
                   { SHIFT to OUT -
                   This is optimized for when you are sending out multiple bits as in asynchronous serial data or I2C
                   Shift data one bit right into output via iomask - leave mask & shifted data on stack (looping)
                   400ns execution time including wordcode read and execute  or 200ns/bit with REPS }
                   {
                   ' SHROUT ( pin dat -- iomask dat/2 )
                   
                   SHROUT
                                           shr     tos,#1 wc       ' Shift right and get lsb
                                           drvc    tos1
                                           ret
                   }
                   
feaf6     fda00067 BITST                   call    #POPX
feafa     fb941604                         tjz     fx,#CLR
                   ' SET ( mask addr -- ) Set bit(s) in hub long
feafe     fb001625 SET                     rdlong  fx,tos
feb02     f5401626                         or      fx,tos1
feb06     fc601625                         wrlong  fx,tos
feb0a     fd800066                         jmp     #DROP2
                   
                   ' CLR ( mask addr -- ) Clear bit(s) in hub long
feb0e     fb001625 CLR                     rdlong  fx,tos
feb12     f5201626                         andn    fx,tos1
feb16     fc601625                         wrlong  fx,tos
feb1a     fd800066                         jmp     #DROP2
                   
                   ' SET? ( mask caddr -- flg ) Test single bit of a byte in memory
feb1e     fb004a25 BITQ                    rdlong  tos,tos
feb22     f5084c25                         and     tos1,tos wz
feb26     56004d7c         if_nz           mov     tos1,M1
feb2a     fd800067                         jmp     #DROP
                   
                   
                   
                   
                   ' ~~ ( addr -- )                set long
feb2e     f1841401 SETL                    sub     ACC,#1
                   ' ~ ( addr -- )                 clear long
feb32     fc601425 CLRL                    wrlong  ACC,tos
feb36     fd800067                         jmp     #DROP
                   
                   ' W~~ ( addr -- )               set word
feb3a     f1841401 SETW                    sub     ACC,#1
                   ' W~ ( addr -- )                clear word
feb3e     fc501425 CLRW                    wrword  ACC,tos
feb42     fd800067                         jmp     #DROP
                   
                   ' C~~ ( addr -- )               set byte
feb46     f1841401 SETC                    sub     ACC,#1
                   ' C~ ( addr -- )                clear byte
feb4a     fc401425 CLRC                    wrbyte  ACC,tos
feb4e     fd800067                         jmp     #DROP
                   
                   
                   ' Inline vector check and exeute  !!!! needs to be able to handle hubexec !!!!
                   ' ?JMP ( adr -- )
                   
feb52     fae81625 QJMP                    rdword  fx,tos wz       ' read contents of vector
feb56     5603f00b                 if_nz   mov     PTRA,fx
feb5a     fd800067                         jmp     #DROP
                   
                   
                   
                   ' SQRT ( d. -- sqrt )
feb5e     fd304c25 _SQRT                   qsqrt   tos+1,tos
feb62     fd604c18                         getqx   tos+1
feb66     fd800067                         jmp     #DROP
                   
                   
                   {
                   _INCMOD '( mod dst -- )
                                   incmod  tos,tos+1
                                   jmp     #DROP2
                   }
                   
                   
                   
                   
feb6a     fd60161b _GETRND         getrnd  fx
feb6e     fd800143                 jmp     #PUSHX
                   
feb72              _HUBSET
feb72     fd604a00                 hubset  tos
feb76     fd800067                 jmp     #DROP
                   
                   
                   
                   
                   ' WS2812 ( array ledcnt -- ) pin is in cog "pinreg" - line RET is done at HL, not here
                   ' Will transmit a whole array of 24-bit words each back to back in WS2812 timing format
                   ' line idles low and resets/synchs with low =>50us
                   ' A zero is transmitted as 400ns high by 850ns low (+/-150ns)
                   ' A one is transmitted as 800ns high by 450ns low HHL
                   ' The low period between each led is about 400ns longer but inconsequential
                   ' <30us/LED
feb7a     20       wsdly 	      byte  sys_clk/2500000
feb7b     ff0007f5 WSLED	      rdbyte 	r2,##wsdly
feb7f     fac41d7a 
feb83     f1844c01               sub       tos1,#1         ' offset for 24-bit long alignment
feb87     fb001626 .l2           rdlong    fx,tos1          ' read next long
feb8b     f1044c03               add       tos1,#3         ' but leds are 3 bytes apart
feb8f     f6041a18               mov       r1,#24          ' write all 24 bits
feb93              .lp
feb93     f0741601               shl       fx,#1 wc         ' get next bit
feb97     fd603059               drvh      pinreg          ' always clock tx pin high for at least 400ns
feb9b     fd601c1f               waitx     r2              ' 400ns
feb9f     fd60305a               drvc      pinreg          ' output data bit
feba3     fd601c1f               waitx     r2              ' delay again, (data is either high or low)
feba7     fd603058               drvl      pinreg          ' always needs to go low in the last third of the cycle
febab     fd601c1f               waitx     r2 '-20'
febaf     fb6c1bf8               djnz      r1,#.lp
febb3     fb6c4bf4               djnz      tos,#.l2        ' read the next long as long as we can (tos = count)
febb7     fd800066               jmp       #DROP2          ' tx line left low to synch - discard stack parameters, all done.
                   
                   {
                   ' VER ( -- verptr )
                   GETVER          loc     PA,#@version
                                   mov     fx,PA
                                   jmp     #PUSHX
                   }
                   
                   {
                   DICTIONARY
                   00.D000: 03 44 55 50 6B 00 04 32 44 55 50 6D 00 04 4F 56    .DUPk..2DUPm..OV
                   00.D010: 45 52 6E 00 04 44 52 4F 50 61 00 05 32 44 52 4F    ERn..DROPa..2DRO
                   00.D020: 50 60 00 04 53 57 41 50 75 00 05 32 53 57 41 50    P`..SWAPu..2SWAP
                   00.D030: 50 0D 03 52 4F 54 7A 00 04 2D 52 4F 54 79 00 03    P..ROTz..-ROTy..
                   }
                   ' ATR(765):CNT(43210),<NAME>,CFA '
                   ' Find string in dictionary is written in code and takes around 1us/word
                   ' r3 = cnt+1st char of source '
                           '    r1   r2  '
febbb              FINDSTR '  ( cstr dict -- nfaptr | false )
febbb     fae01e26                 rdword  r3,tos1                 ' read in count and 1st char
febbf     f6001c25 fstlp           mov     r2,tos                  ' R2 = dict word ptr '
febc3     f6001a26                 mov     r1,tos1                 ' R1 = source
febc7     fae8160e                 rdword  fx,r2 wz                ' read in count + 1st char'
febcb     ad90005c         if_z    jmp     #fstfail                ' end of dictionary?'
febcf     f52416e0                 andn    fx,#$E0                 ' mask out atrs from count
febd3     f208160f                 cmp     fx,r3   wz              ' compare count+1st char '
febd7     5d90003c         if_nz   jmp     #fstskip                ' no match, go to next word
febdb     f600200f                 mov     r4,r3                   ' matched on cnt + 1st char'
febdf     f504201f                 and     r4,#cntm                ' now match rest if needed'
febe3     f18c2001                 sub     r4,#1 wz                ' matched if single else setup'
febe7     ad900024         if_z    jmp     #fstmatch
febeb     f1041a02                 add     r1,#2                   ' skip into 2nd char'
febef     f1041c02                 add     r2,#2
febf3     fac0180d fstrem          rdbyte  r0,r1                   ' read in char from source '
febf7     f1041a01                 add     r1,#1                   ' hub has to wait anyway so get ready for next source byte
febfb     fac0160e                 rdbyte  fx,r2                   ' read in a character from the dictionary
febff     f1041c01                 add     r2,#1
fec03     f208160c                 cmp     fx,r0 wz                        ' are they the same?
fec07     5d90000c          if_nz  jmp     #fstskip                ' skip if not same'
fec0b     fb6c21f9                 djnz    r4,#fstrem              ' continue for remainder'
fec0f     f6004c25 fstmatch        mov     tos1,tos                ' NIP
fec13     fd800067                 jmp     #DROP                   ' found it
fec17     fac01625 fstskip         rdbyte  fx,tos                  ' read cnt to skip to next header '
fec1b     f504161f                 and     fx,#cntm                        ' 03,D,U,P,CFAL,CFAH
fec1f     f1004a0b                 add     tos,fx
fec23     f1044a03                 add     tos,#3                  ' skip over CPA to next header'
fec27     fd9fff94                 jmp     #fstlp
fec2b     f6044c00 fstfail         mov     tos1,#0
fec2f     fd800067                 jmp     #DROP
                   
fec33     f6001615 _DEPTH          mov     fx,depth
fec37     fd800143                 jmp     #PUSHX
                   
                   
fec3b     fd60162b REGVAR          POP     fx
fec3f     fac0160b                 rdbyte  fx,fx
fec43     f1001609                 add     fx,regptr
fec47     fd800143                 jmp     #PUSHX
                   
                   {
                           "   ABCDEFGHIKLMNOPQRSTUVWXYZ$@!+- _abcdefghijklmnopqrstuvwxyz{|}~ #J%&'()*,./0123456789:;<=>?[\]^"
                           0 -ROT BEGIN DUP C@ WHILE OVER OVER C@ = IF 2DROP EXIT THEN ROT 1+ -ROT 1+ REPEAT
                           ;
                   }
                   
                   ' LOOKIN ( val array -- index )
fec4b     f6001a26 LOOKIN          mov     R1,tos1
fec4f     f6044c00                 mov     tos1,#0                         ' init result index
fec53     fac81625 .L0             rdbyte  fx,tos wz
fec57     a6044c00         if_z    mov     tos1,#0
fec5b     ad800067         if_z    jmp     #DROP
fec5f     f1044c01                 add     tos1,#1                         ' inc result index
fec63     f208160d                 cmp     fx,R1 wz
fec67     ad800067         if_z    jmp     #DROP
fec6b     f1044a01                 add     tos,#1
fec6f     fd9fffe0                 jmp     #.L0
                   
fec73              _LOOKUP '( index array -- value )
fec73     f1004c25                 add     tos1,tos
fec77     fac04c26                 rdbyte  tos1,tos1
fec7b     fd800067                 jmp     #DROP
                   
                   
                   
                   
                   
                   
fec7f              endcode
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   '************************************* HUB REGISTERS **************************************
                   
fec7f 000                          org  0
                   ' register offsets within "registers". Access as    REG,delim   ...  REG,base ... etc
                   '
                   ' Minimum registers required for a new task - other registers after the ' ---- are not needed other than by the console
fec7f 000          temp            res 12          ' general purpose
fec7f 00c          double          res 4           ' hold high word of double
                   ' @16
fec7f 010          uemit           res 2           ' emit vector 0 = default
fec7f 012          ukey            res 2           ' key vector
fec7f 014          keypoll         res 2           ' poll user routines - low priority background task
fec7f 016          base            res 2           ' current number base + backup location during overrides
fec7f 018          baudcnt         res 4           ' SERIN SEROUT baud cnt value where baud = clkfreq/baudcnt each cog can have it's own
fec7f 01c          uswitch         res 4           ' target parameter used in CASE structures
                   ' @32
fec7f 020          fflags          res 2           ' echo,linenums,ipmode,leadspaces,prset,striplf,sign,comp,defining
                   
fec7f 022          keycol          res 1           ' maintains column position of key input
                   
fec7f 023          wordcnt         res 1           ' length of current word (which is still null terminated)
fec7f 024          wordbuf         res wordsz              ' words from the input stream are assembled here
                   ' numpad may continue to build backwards into wordbuf for special cases such as long binary numnbers
fec7f 04b          numpad          res numpadsz    ' Number print format routines assemble digit characters here builds from end - 18,446,744,073,709,551,615
fec7f 065          padwr           res 1           ' write index (builds characters down from lsb to msb in MODULO style)
                   
                   
                   'leader         res 1
                   
fec7f 066          pflg            res 1
fec7f 067          pbase           res 1
fec7f 068          pfmt            res 4
                   
                   
                   
fec7f 06c          delim           res 2           ' the delimiter used in text input and a save location
fec7f 06e          prefix          res 1           ' NUMBER input prefix
fec7f 06f          uprompt         res 2           ' pointer to code to execute when Forth prompts for a new line
fec7f 071          accept          res 2           ' pointer to code to execute when Forth accepts a line to interpret (0=ok)
fec7f 073          keychar         res 4           ' override for key character
                   
fec7f 077          suffix          res 1           ' NUMBER input suffix
fec7f 078                          res 3
                   
fec7f 07b          unum            res 2           ' User number processing routine - executed if number failed and UNUM <> 0
fec7f 07d          ufind           res 2           ' runs extended dictionary search if set after failing precompiled dictionary search
                   
                   
                   '
                   ' ------ console only registers not required for other tasks  --- can be accessed as globals
                   '
                   
                   
                   ' these 4 variables are cleared as an array of 10 bytes
fec7f 07f          anumber         res 4           ' Assembled number from input
fec7f 083          bnumber         res 4
fec7f 087          digits          res 1           ' number of digits in current number that has just been processed
fec7f 088          dpl             res 1           ' Position of the decimal point if encountered (else zero)
                   
                   'createvec      res 2           ' If set will execute user create routines rather than the kernel's (CREATE revectored)
                   
fec7f 089          dmm             res 6           ' dump "fetch' vectors to allow dump to access special devices
fec7f 08f          dmp             res 2           ' DUMP vector
                   
                   
                   ''''''''''''''''''''''' fixed ''''''''''''''''''''''''''''
                   
                   'rxptr          res 4           ' Pointer to the terminal receive buffer - read & write index precedes
                   'rxsz           res 2
                   
                   
fec7f 091          oldnames        res 4           ' backup of names used at start of TAQOZ load
fec7f 095          names           res 4           ' start of dictionary (builds down)
                   
                   
fec7f 099          fromhere        res 4           ' Used by TAQOZ word to backup current here to determine code size at end of load
fec7f 09d          here            res 4           ' pointer to compilation area (overwrites VM image)
fec7f 0a1          codes           res 4           ' current code compilation pointer (updates "here" or is reset by it)
                   
                   'bootsig                res 4
                   
fec7f 0a5          autovec         res 4           ' user autostart address if non-zero - called from within terminal
fec7f 0a9          cold            res 2           ' pattern to detect if this is a cold or warm start ($A55A )
fec7f 0ab          errors          res 2
fec7f 0ad          linenum         res 2
                   'lines          res 2
                   
fec7f 0af          prevch          res 2           ' used to detect LF only sequences vs CRLF to perform auto CR
                   
fec7f 0b1          spincnt         res 2           ' Used by spinner to rotate busy symbol
fec7f 0b3                          res 2           ' word count
                   
fec7f 0b5          endreg          res 0
                   
                   '*********************************************************************************************************
                   '************************************** TACHYON COG KERNEL ***********************************************
                   '*********************************************************************************************************
                   
fec7f 000                          org 0
fec7f 000 fdafe8b6 RESET           call    #@InitTaqoz
fec83 001 fd9000d0                 jmp     #doNEXT
                   
                   '********************************** data *************************************
                   
                   
                   ' Registers used by PASM modules to hold parameters such as I/O masks and bit counts etc
                   ' COG 2
fec87 002          sck
fec87 002 00000000 REG0            long 0
fec8b 003          mosi
fec8b 003 00000000 REG1            long 0
fec8f 004          miso
fec8f 004 00000000 REG2            long 0
fec93 005          ss
fec93 005 00000000 REG3            long 0
fec97 006 00000000 REG4            long 0
fec9b 007 00000000                 long 0
fec9f 008 00000000                 long 0
                   
                   ' $00E0
                   ' COG 9 = TASK REGISTER POINTER
feca3 009 0000fe00 regptr          long registers                          ' used by REG
                   
feca7 00a 00000000 ACC             long    0
fecab 00b 00000000 fx              long    0
fecaf 00c 00000000 R0              long    0
fecb3 00d 00000000 R1              long    0
fecb7 00e          P
fecb7 00e 00000000 R2              long    0
fecbb 00f 00000000 R3              long    0
fecbf 010          R4
fecbf 010 00000000 deltaR          long    0
                   
                   
                   ' COG 17 STACK POINTERS
fecc3 011 00000000 datptr          long    0                               ' data stack pointer to LUT
fecc7 012 00000000 braptr          long    0                               ' branch stack pointer to LUT
feccb 013 00000000 lpptr           long    0
feccf 014 00000000 retptr          long    0                               ' return stack pointer to LUT
                   ' COG 21
fecd3 015 00000000 depth           long    0
fecd7 016 00000000 lap1            long    0
fecdb 017 00000000 lap2            long    0
                   ' #0024
fecdf 018 00000000 pinreg          long    0
fece3 019 00000000 tepin           long    0
fece7 01a 00000050 pinticks        long    sys_clk / 1000000               ' set default 1Mbaud
                   
                   ' #0027
feceb 01b 00000000 clockpins       long 0                                  ' I/O mask for CLOCK instruction
fecef 01c 00000000 clkdly          long 0
                   
                   ' #0029 rx isr variables
fecf3 01d 00000000 rxlong		long 0
fecf7 01e 00000000 fz		long 0
fecfb 01f 00000000 rxwrP		long 0
fecff 020 00000000 rxwrC		long 0
                   
                   
                   ' constants used by doNEXT decode
fed03 021 0000e8a5 wordcodes               long    (_wordcode-1)&$FFFF             ' ~$0E0C end of assembly area in hub, start of wordcode
fed07 022 0000fbff ops                     long    _IF-1                   ' $FC00..$FCFF conditional branch +/- 127 words
fed0b 023 0000fcff reg8                    long    rg-1                    ' $FD00..$FDFF 8-bit register offset
fed0f 024 0000fdff ag                      long    w-1                     ' $FE00..$FFFF 9-bit literal
                   
                   
                   
                   ' *** COG STACKS ***
                   
                   ' top of data stack registers
fed13 025 deadbeef tos                     long    $DEADBEEF
fed17 026 deadbeef tos1                    long    $DEADBEEF
fed1b 027 deadbeef tos2                    long    $DEADBEEF
fed1f 028 deadbeef tos3                    long    $DEADBEEF
                   
                   ' top of loop stack registers
fed23 029 00000000 limit1                  long    0
fed27 02a 00000000 index                   long    0
fed2b 02b 00000000 limit2                  long    0
fed2f 02c 00000000 index2                  long    0
                   
fed33 02d 00000000 branchadr               long    0
fed37 02e 00000001 seed                    long    1
                   
fed3b 02f 000001f0 L496                    long    496
                   
fed3f 030 f603f025 AJMP                    mov     PTRA,tos                ' jump to address on top of the data stack
fed43 031 fd9000d4                         jmp     #DROP
                   
fed47 032 fdb000d0 ACALL                   call    #POPX                   ' get wordcode into X
fed4b 033 fd601a2b                         pop     R1                      ' discard return address and jump back and use interpreter
fed4f 034 fd900008                         jmp     #doCODE
                   
                   
                   
                   ' main Forth wordcode interpreter - PTRA = Instruction Pointer
                   ' wordcode order: ASM,THREADED,IF,UNTIL,REG,LIT9
                   '
fed53 035 fd60162d doCALL                  call    fx                      ' could call cog or hub code - use ret to return
fed57 036 fae41761 doNEXT                  rdword  fx,PTRA++               ' read word code instruction
fed5b 037 f2105e0b doCODE                  cmp     L496,fx wc              ' wordcode below $1F0 are cog addresses - just call
fed5f 038 3d9ffff0         if_nc           jmp     #doCALL
                                                                           ' Not a cog address, could be hub address or further encoded '
fed63 039 f210420b                         cmp     wordcodes,fx wc         ' just call if it is asm code - either cog or in hubexec range below wordcodes
fed67 03a 3d900020         if_nc           jmp     #ENTER                  ' COLON if not then just execute as threaded code - needs to save IP
fed6b 03b f210440b                         cmp     ops,fx wc               ' special opcodes? (at high end for branches, short literals, registers etc)
fed6f 03c 3d9fffe0         if_nc           jmp     #doCALL                 ' execute as cog code '
                   
fed73 03d f210460b                         cmp     reg8,fx wc
fed77 03e 3d900028         if_nc           jmp     #doBRANCH               ' IF UNTIL conditional relative branch code
fed7b 03f f210480b                         cmp     ag,fx wc                        '
fed7f 040 3d90003c         if_nc           jmp     #doREG                  ' REG 8-bit task register offset '
fed83 041 fdb00400                         call    #doLIT9                 ' LIT short 9-bit literal
fed87 042 fd9fffcc                         jmp     #doNEXT
                   
                   ' Call wordcode - Save IP and load with new IP from call
                   '
fed8b 043 f7cc1601 ENTER                   test    fx,#1 wz                        ' bit0 is the jump/call bit
fed8f 044 f5241601                         andn    fx,#1                   ' word align
fed93 045 ac33f014         if_z            wrlut   PTRA,retptr             ' save IP onto return stack
fed97 046 a1042801         if_z            add     retptr,#1
fed9b 047 f603f00b                         mov     PTRA,fx                 ' jump to new wordcode (PTRA = IP)
fed9f 048 fd9fffb4                         jmp     #doNEXT
                   
                   '
                   ' Conditional with 7-bit signed word displacement
                   ' $FC80 _UNTIL
                   ' $FC00 _IF
feda3 049 fb9c4a04 doBRANCH                tjnz    tos,#dj1                ' discard flag and continue w/o jumping
                                                                           ' take the jump - X has instruction wordcode
feda7 04a f7cc1680                         test    fx,#$80 wz              ' reverse jump? nz
fedab 04b f504167f                         and     fx,#$7F                         ' mask displacement
fedaf 04c f0641601                         shl     fx,#1                   ' index as words
fedb3 04d f3e3f00b                         sumnz   PTRA,fx                         ' +/- jump
fedb7 04e fdb00060 dj1                     call    #DROP                   ' discard condition flag
fedbb 04f fd9fff98                         jmp     #doNEXT
                   
                   
                   ' REG OP ( -- addr ) - the byte offset is relative to the regptr for that task
fedbf 050          doREG
fedbf 050 f50416ff                         and     fx,#$FF
fedc3 051 f1001609                         add     fx,regptr
fedc7 052 fdb003c0                         call     #PUSHX
fedcb 053 fd9fff88                         jmp     #doNEXT
                   
                   
                   '###################################################################################'
                   
fedcf 054          STRLEN  ' ( str -- len )
fedcf 054 fc780025                         rdfast  #0,tos
fedd3 055 f6044a00                         mov     tos,#0
fedd7 056 fd601810 .L0                     rfbyte  R0              ' read a byte
feddb 057 f1841801                         sub     R0,#1           ' end is either a null or anything >$7F
feddf 058 f214187e                         cmp     R0,#$7E wc
fede3 059 c1044a01         if_c            add     tos,#1
fede7 05a cd9fffec         if_c            jmp     #.L0
fedeb 05b fd64002d                         ret
                   
                   
                   ' ?EXIT ( flg -- ) Exit if flg is true
fedef 05c fdb00028 IFEXIT                  call    #POPX
fedf3 05d 5d90000c         if_nz           jmp     #EXIT
fedf7 05e fd64002d                         ret
                   
                   ' 0EXIT ( flg -- ) Exit if flg is false (or zero)  Used in place of IF......THEN EXIT as false would just end up exiting
fedfb 05f fdb0001c ZEXIT                   call    #POPX
fedff 060 5d64002d         if_nz           ret
fee03 061 f1842801 EXIT                    sub     retptr,#1
fee07 062 0aa3f014                 _ret_   rdlut   PTRA,retptr
                   
                   
                   { *** STACK OPERATORS *** }
                   
                   ' NIP ( n1 n2 -- n2 ) : 600ns
fee0b 063 f6004c25 NIP                     mov     tos1,tos
fee0f 064 fd900008                         jmp     #DROP
                   ' 3DROP ( n1 n2 n3 -- ) : 1.2us
fee13 065 fdb00004 DROP3                   call    #POPX
                   ' 2DROP ( n1 n2 -- ) : 800ns
fee17 066 fdb00000 DROP2                   call    #POPX
                   ' DROP ( n -- ) : 500ns : 400ns
fee1b 067          DROP
                   ' Pop the data stack using fixed size register stack in COG memory (allows fast direct access for operations)
                   ' overflow stack in hub ram and reduces the size of the cog stack to 4
fee1b 067          POPX ' wz
fee1b 067 fb942a07                         tjz     depth,#_NOP     ' don't pop beyond bottom of stack
fee1f 068 f6081625                         mov     fx,tos wz       ' pop old tos into X
fee23 069 f6004a26                         mov     tos,tos1
fee27 06a f6004c27                         mov     tos1,tos2
fee2b 06b f6004e28                         mov     tos2,tos3
fee2f 06c f1842a01                         sub     depth,#1        ' maintain depth count
fee33 06d f1842201                         sub     datptr,#1       ' stack pointer
fee37 06e 0aa05011                 _ret_   rdlut   tos3,datptr     ' pop from lut stack into register stack
fee3b 06f fd64002d _NOP                    ret
                   
                   
                   ' ?DUP ( n1 -- n1 n1 | 0 ) DUP n1 if non-zero
fee3f 070 fb944bfe QDUP                    tjz     tos,#_NOP
                   ' DUP ( n1 - n1 n1 ) Duplicate the top item on the stack - 48 cycles
fee43 071 f6001625 DUP                     mov     fx,tos                  ' Read directly from the top of the data stack
fee47 072 fd900340                         jmp     #PUSHX                  ' Push the internal X register onto the datastack
                   
                   
fee4b 073 fdb00000 DUP2                    call    #OVER
                   ' OVER ( n1 n2 -- n1 n2 n1 ) - 1us
fee4f 074 f6001626 OVER                    mov     fx,tos1                 'read second data item and push
fee53 075 fd900334                         jmp     #PUSHX
                   ' tos2 ( n1 n2 n3 -- n1 n2 n3 n1 ) Copy the tos2 item onto the stack
fee57 076 f6001627 THIRD                   mov     fx,tos2                 ' read third data item
fee5b 077 fd90032c                         jmp     #PUSHX
                   ' 4TH ( n1 n2 n3 n4 -- n1 n2 n3 n4 n1 ) Copy the 4th item onto the stack - 1.2us
fee5f 078 f6001628 FOURTH                  mov     fx,tos3
fee63 079 fd900324                         jmp     #PUSHX
                   
                   
                   ' BOUNDS ( n1 n2 -- n2+n1 n1 ) == OVER + SWAP
fee67 07a f1004a26 BOUNDS                  add     tos,tos1
                   ' SWAP ( n1 n2 -- n2 n1 ) Swap the top two items
fee6b 07b f6001626 SWAP                    mov     fx,tos1
fee6f 07c f6004c25 SWAPX                   mov     tos1,tos
fee73 07d 06004a0b PUTX            _ret_   mov     tos,fx
                   
                   ' -ROT ( a b c -- c a b )
fee77 07e fdb00000 ROT2                    call    #ROT
                   ' ROT ( a b c -- b c a )
fee7b 07f f6001627 ROT                     mov     fx,tos2
fee7f 080 f6004e26                         mov     tos2,tos1
fee83 081 fd9fffe8                         jmp     #SWAPX
                   
                   
                   { *** ARITHMETIC *** }
                   ' - ( n1 n2 -- n3 ) Subtract n2 from n1
fee87 082 f6604a25 MINUS                   neg     tos             ' (note: save one long by negating and adding)
                   ' + ( n1 n2 -- n3 ) Add top two stack items together and replace with result
fee8b 083 f1104c25 PLUS                    add     tos1,tos wc
fee8f 084 fd9fff88                         jmp     #DROP
                   
                   ' 2-
fee93 085 01844a02 DEC2            _ret_   sub     tos,#2
                   ' 1-
fee97 086 01844a01 DEC             _ret_   sub     tos,#1
                   
                   ' 4+
fee9b 087 01044a04 INC4            _ret_   add     tos,#4
                   ' 2+
fee9f 088 01044a02 INC2            _ret_   add     tos,#2
                   ' 1+
feea3 089 01044a01 INC             _ret_   add     tos,#1
                   
                   ' -NEGATE ( n1 sn -- n1 | -n1 ) negate n1 if the sign of sn is negative (used in signed divide op)
feea7 08a f0444a1f MNEGATE                 shr     tos,#31
                    ' ?NEGATE ( n1 flg -- n2 ) negate n1 if flg is true
feeab 08b fb944bdb QNEGATE                 tjz     tos,#DROP
feeaf 08c fdbfff68                         call    #POPX
                   ' NEGATE ( n1 -- n2 )  equivalent to  n2 = 0-n1
feeb3 08d 06604a25 NEGATE          _ret_   neg     tos
                   
                   { *** BOOLEAN *** }
                   {
                   ' INVERT ( n1 -- n2 ) bitwise invert n1 and replace with result n2
                   INVERT                  add     tos,#1
                                           jmp     #NEGATE
                   }
                   ' BITS ( n1 bits -- n2 )
feeb7 08e f9c04a25 BITS                    decod   tos
feebb 08f f1844a01                         sub     tos,#1
feebf 090 f5004c25 _AND                    and     tos1,tos
feec3 091 fd9fff54                         jmp     #DROP
feec7 092 f5204c25 _ANDN                   andn    tos1,tos
feecb 093 fd9fff4c                         jmp     #DROP
feecf 094 f5404c25 _OR                     or      tos1,tos
feed3 095 fd9fff44                         jmp     #DROP
feed7 096 f5604c25 _XOR                    xor     tos1,tos
feedb 097 fd9fff3c                         jmp     #DROP
                   
                   ' mainly for testing instructions'
feedf 098 f7404c25 _ZEROX                  zerox   tos1,tos
feee3 099 fd9fff34                         jmp     #DROP
                   
                   ' *** shift operators ***
                   
                   ' *** RIGHT SHIFT ***
                   ' SHR ( n1 cnt -- n2 ) Shift n1 right by count (5 lsbs )
feee7 09a f0404c25 _SHR                    shr     tos1,tos
feeeb 09b fd9fff2c                         jmp     #DROP
                   
                   ' 16>>
feeef 09c 00444a10 _SHR16          _ret_   shr     tos,#16
                   ' 9>>
feef3 09d 00444a09 _SHR9           _ret_   shr     tos,#9
                   ' 8>>
feef7 09e 00444a08 _SHR8           _ret_   shr     tos,#8
                   
                   ' 4/
feefb 09f 00444a02 _SHR2           _ret_   shr     tos,#2
                   
                   ' 2/ ( n1 -- n1/2 )
feeff 0a0 00444a01 _SHR1           _ret_   shr     tos,#1
                   
                   
fef03 0a1 f0004c25 _ROR                    ror     tos1,tos
fef07 0a2 fd9fff10                         jmp     #DROP
fef0b 0a3 f0c04c25 _SAR                    sar     tos1,tos
fef0f 0a4 fd9fff08                         jmp     #DROP
                   
                   
                   ' *** LEFT SHIFT ***
                   ' << ( n1 bits -- n2 )
fef13 0a5 f0604c25 _SHL                    shl     tos1,tos
fef17 0a6 fd9fff00                         jmp     #DROP
                   
                   ' ROL ( n1 bits -- n2 )
fef1b 0a7 f0204c25 _ROL                    rol     tos1,tos
fef1f 0a8 fd9ffef8                         jmp     #DROP
                   
fef23 0a9 00644a09 _SHL9           _ret_   shl     tos,#9
                   ' 8<<
fef27 0aa 00644a08 _SHL8           _ret_   shl     tos,#8
                   
                   ' 4*
fef2b 0ab 00644a02 _SHL2           _ret_   shl     tos,#2
                   ' 2* ( n1 -- n2 ) shift n1 left one bit (equiv to multiply by 2)
fef2f 0ac 00644a01 _SHL1           _ret_   shl     tos,#1
                   
                   
                   
                   
                   
                   ' REV ( n1 -- n2 ) Reverse bits 0..31 --> 31..0
fef33 0ad 0d604a69 _REV            _ret_   rev     tos
                   
                   '_BMASK                 bmask   tos
                   
                   ' MASK ( bitpos -- bitmask  \ only the lower 5 bits of bitpos are taken, regardless of the higher bits )
fef37 0ae 09c04a25 MASK            _ret_   decod   tos
                   
                   ' ENCODE ( mask -- bitpos )
fef3b 0af 07804a25 ENCODE          _ret_   encod   tos
                   
                   ''      FAST MASKING
                   ' 4BITS ( n -- nibble ) mask n to a nibble
fef3f 0b0 05044a0f BITS4           _ret_   and     tos,#$0F
                   ' 8BITS ( n -- nibble ) mask n to a byte
fef43 0b1 05044aff BITS8           _ret_   and     tos,#$FF
                   ' 9BITS
fef47 0b2 05044bff BITS9           _ret_   and     tos,#$1FF
                   
                   
                   
                                           { *** COMPARISON *** }
                   
                   ' Basic instructions from which other comparison instructions are built from
                   
                   
                   ' = ( n1 n2 -- flg ) true if n1 is equal to n2 : 700ns @80
fef4b 0b3 fdbffecc _EQ                     call    #POPX
fef4f 0b4 f1804a0b                         sub     tos,fx          ' n1 == 0 if equal
                   ' 0= ( n -- flg ) true if n = 0  : 400ns @80
fef53 0b5 fb944a02 _ZEQ                    tjz     tos,#SETTRUE
fef57 0b6 06044a00                 _ret_   mov     tos,#0
                   
                   ' 0<> ( n -- flg ) true if n <> 0 (promote n to boolean) : 400ns @80
fef5b 0b7 fb944a01 _ZNE                    tjz     tos,#z1
fef5f 0b8 06004b7c SETTRUE         _ret_   mov     tos,M1
fef63 0b9 fd64002d z1                      ret
                   
                   
                   ' <> ( n1 n2 -- flg ) true if n1 <> n2 : 600ns @80
fef67 0ba f1884c25 _NEQ                    sub     tos1,tos wz
fef6b 0bb 56004d7c                 if_nz   mov     tos1,M1
fef6f 0bc fd9ffea8                         jmp     #DROP
                   
                   
                   ' 0< ( n -- flg ) true if n < 0 (negative) : 400ns @80
fef73 0bd 00c44a1f _ZLT            _ret_   sar     tos,#31
                   
                   ' NOT ( n -- !n ) invert bits of n : 350ns @80
fef77 0be 06204a25 _NOT            _ret_   not     tos
                   
                   
                   ' ABS ( n -- abs )
fef7b 0bf 06404a25 _ABS            _ret_   abs     tos,tos
                   
fef7f 0c0 fd004a26 _MUL                    qmul    tos,tos1
fef83 0c1 fd604c18                         getqx   tos1
fef87 0c2 fd9ffe90                         jmp     #DROP
                   
fef8b 0c3 fa004c25 MUL16                   mul     tos1,tos
fef8f 0c4 fd9ffe88                         jmp     #DROP
                   
                   
                   ' UM* ( u1 u2 -- u1*u2L u1*u2H )
                   ' DESC: unsigned 32bit * 32bit multiply -- 64bit result
fef93 0c5 fd004a26 UMMUL                   qmul    tos,tos1
fef97 0c6 fd604c18                         getqx   tos1
fef9b 0c7 0d604a19                 _ret_   getqy   tos
                   
                   
                   ' U// ( dvdn dvsr -- rem quot )
fef9f 0c8 fd104c25 UDIVMOD                 qdiv    tos1,tos
fefa3 0c9 fd604a18                         getqx   tos
fefa7 0ca 0d604c19                 _ret_   getqy   tos1
                   
                   ' MOD ( n1 mod -- rem )
fefab 0cb fdbffff0 UMOD                    call    #UDIVMOD
fefaf 0cc fd9ffe68                         jmp     #DROP
                   
                   
                   ' U/ ( u1 u2 -- quot )
fefb3 0cd fd104c25 UDIVIDE                 qdiv    tos1,tos
fefb7 0ce fd604c18                         getqx   tos1
fefbb 0cf fd9ffe5c                         jmp     #DROP
                   
                   
                   
                   ' signed MIN returns the minimum of the two values
fefbf 0d0 f3604c25 _MINS                   fles    tos1,tos
fefc3 0d1 fd9ffe54                         jmp     #DROP
fefc7 0d2 f3404c25 _MAXS                   fges    tos1,tos
fefcb 0d3 fd9ffe4c                         jmp     #DROP
                   ' unsigned MIN returns the minimum of the two values
fefcf 0d4 f3204c25 _MIN                    fle     tos1,tos
fefd3 0d5 fd9ffe44                         jmp     #DROP
fefd7 0d6 f3004c25 _MAX                    fge     tos1,tos
fefdb 0d7 fd9ffe3c                         jmp     #DROP
                   
                   { *** MEMORY *** }
                   
                   ' C@++  ( caddr -- caddr+1 byte ) fetch byte character and increment address
fefdf 0d8 f6001625 CFETCHINC               mov     fx,tos                  ' dup the address
fefe3 0d9 fdb001a4                         call    #PUSHX
fefe7 0da f1044c01                         add     tos1,#1                 ' inc the backup address
                   ' C@  ( caddr -- byte ) Fetch a byte from hub memory : 500ns @80
fefeb 0db 0ac04a25 CFETCH          _ret_   rdbyte  tos,tos
                   
                   ' DUPC@
fefef 0dc fac01625 DUPCFT                  rdbyte  fx,tos
feff3 0dd fd900194                         jmp     #PUSHX                  ' Push the internal fx register onto the datastack
                   
                   
                   
                   ' W@  ( waddr -- word ) Fetch a word from hub memory
feff7 0de 0ae04a25 WFETCH          _ret_   rdword  tos,tos
                   
                   ' @  ( addr -- long ) Fetch a long from hub memory
feffb 0df 0b004a25 FETCH           _ret_   rdlong  tos,tos
                   
                   ' C+!  ( n caddr -- ) add n to byte at hub addr : 1.2us @80
fefff 0e0 fac01625 CPLUSST                 rdbyte  fx,tos                  ' read in word from adress
ff003 0e1 f1004c0b                         add     tos1,fx                         ' add to contents of address - cascade
                   ' C!  ( n caddr -- ) store n to byte at addr : 1us @80
ff007 0e2 fc404c25 CSTORE                  wrbyte  tos1,tos                ' write the byte using address on the tos
ff00b 0e3 fd9ffe08                         jmp     #DROP2
                   
                   ' W+!  ( n waddr -- ) add n to word at hub addr
ff00f 0e4 fae01625 WPLUSST                 rdword  fx,tos                  ' read in word from address
ff013 0e5 f1004c0b                         add     tos1,fx
                   ' W!  ( n waddr -- ) store n to word at addr
ff017 0e6 fc504c25 WSTORE                  wrword  tos1,tos
ff01b 0e7 fd9ffdf8                         jmp     #DROP2
                   
                   ' +!  ( n addr -- ) add n to long at hub addr
ff01f 0e8 fb001625 PLUSST                  rdlong  fx,tos                  ' read in long from address
ff023 0e9 f1004c0b                         add     tos1,fx
                   ' !  ( n addr -- ) store n to long at addr
ff027 0ea fc604c25 STORE                   wrlong  tos1,tos
ff02b 0eb fd9ffde8                         jmp     #DROP2
                   
                   ' LUT@ ( addr -- data ) : 400ns
ff02f 0ec 0aa04a25 LUTFETCH        _ret_   rdlut   tos,tos
                   
                   ' LUT! ( data addr -- ) : 900ns
ff033 0ed fc304c25 LUTSTORE                wrlut   tos1,tos
ff037 0ee fd9ffddc                         jmp     #DROP2
                   
                   
                   ' BLOCK MOVE
                   '
                   ' 171219 64K in 19.866ms using rep vs 24.872ms using djnz
                   ' RCMOVE bytes from source to destination primitive - <CMOVE conditions the parameters before calling
                   ' (RCMOVE) ( src dst cnt -- ) Copy bytes from src to dst for cnt bytes starting from the ends (in reverse)
ff03b 0ef fd75e06f pRCMOVE                 modcz   _set,0 wc  'modc    $0F wc          ' set carry for decrementing (always cleared by PUSH)
                   ' (CMOVE) ( src dst cnt -- ) Copy cnt bytes from src to dst address
ff03f 0f0 fcd80825 CMOVE                   rep     @.end,tos
ff043 0f1 fac01827                         rdbyte  R0,tos2         ' read source byte
ff047 0f2 f3844e01                         sumc    tos2,#1         ' inc or dec depending upon carry
ff04b 0f3 fc401826                         wrbyte  R0,tos1         ' write destination byte
ff04f 0f4 f3844c01                         sumc    tos1,#1         ' inc or dec depending upon carry!!
ff053 0f5 fd9ffdbc .end                    jmp     #DROP3
                   
                   ' ------------------------------------------------------------------------------
                   
                   ' wrfast rep code -> $6.0000 $1.0000 LAP ERASE LAP DECIMAL .LAP 131208 cycles = 1.640ms/64K
                    ' ( addr bytes -- )
ff057 0f6 fdb00124 ERASE                   call    #PUSHACC
                   ' ( addr cnt fillch -- )
ff05b 0f7 fc804c27 CFILL                   wrfast  tos1,tos2
ff05f 0f8 fcd80226                         rep     @.L0,tos1
ff063 0f9 fd604a15                         wfbyte  tos
ff067 0fa fd9ffda8 .L0                     jmp     #DROP3
                   
                   ' Test for non-zero data in memory block
                   ' DATA? ( addr longs -- flg )
ff06b 0fb fc780026 DATAQ                   rdfast  #0,tos1
ff06f 0fc fcd80425                         rep     @.L0,tos
ff073 0fd fd601612                         rflong  fx
ff077 0fe f540140b                         or      ACC,fx
ff07b 0ff f6004c0a .L0                     mov     tos1,ACC
ff07f 100 fd9ffd98                         jmp     #DROP
                   
                   
                   
                   ' I ( -- index ) read the loop index
ff083 101 f600162a IX                      mov     fx,index
ff087 102 fd900100                         jmp     #PUSHX
                   ' J ( -- index ) read the loop index
ff08b 103 f600162c J                       mov     fx,index2
ff08f 104 fd9000f8                         jmp     #PUSHX
                   ' IC@ ( -- byte )
ff093 105 fac0162a ICFETCH                 rdbyte  fx,index
ff097 106 fd9000f0                         jmp     #PUSHX
                   ' I+ ( n -- n+I ) fast index offset i.e.  table I+
ff09b 107 01004a2a IPLUS           _ret_   add     tos,index
                   
                   
                   { *** BRANCH & LOOP *** }
                   
                   
                   
                   ' ADO = BOUNDS DO - just a quick and direct way as BOUNDS is most often never used elsewhere
                   ' ADO ( from cnt -- )
ff09f 108 fdbffdc4 ADO             call    #BOUNDS
                   '
                                                                           ' DO ( to from -- )
ff0a3 109 fdbffdc4 DO              call    #SWAP
ff0a7 10a fdb000a4                 call    #PUSHL                          ' PUSH index onto loop stack
                   '
                                                                           ' FOR ( count -- ) Setup FOR...NEXT loop for count
                   '
ff0ab 10b fc305a12 FOR             wrlut   branchadr,braptr
ff0af 10c f1042401                 add     braptr,#1
ff0b3 10d f6005bf8                 mov     branchadr,PTRA
                   ' >L ( n -- ) Push n onto the loop stack
ff0b7 10e fd900094                 jmp     #PUSHL
                   
                   ' L> ( -- n ) Pop n from the loop stack
ff0bb 10f fdb00078 LPOP            call    #LPOPX                          ' Pop loop stack into X
ff0bf 110 fd9000c8                 jmp     #PUSHX                          ' Push X onto the data stack as tos
                   
                   ' +LOOP ( n1 -- )
ff0c3 111 fdbffd54 PLOOP           call    #POPX                           ' get loop increment
ff0c7 112 f100540b                 add     index,fx                                ' add to index
ff0cb 113 f1845401                 sub     index,#1                        ' compensate so we can drop through to LOOP
                   ' The comparison above is between the call insn (wr) at DELTA and the jump insn (nr) at POPX_ret,
                   ' this will always be carry set. The call itself is indirect.
                   '
ff0cf 114 f1045401 LOOP            add     index,#1                        ' increment index
ff0d3 115 f258522a                 cmps    limit1,index wcz
ff0d7 116 1603f02d BRANCH  if_a    mov     PTRA,branchadr                  ' Branch to the address that is saved in branch stack
ff0db 117 1d64002d         if_a    ret
ff0df 118 fdb00054                 call    #LPOPX                          ' discard the limit
ff0e3 119 f1842401 POPBRANCH       sub     braptr,#1
ff0e7 11a f2142420                 cmp     braptr,#brastk wc
ff0eb 11b c6042420         if_c    mov     braptr,#brastk
ff0ef 11c faa05a12                 rdlut   branchadr,braptr
ff0f3 11d fd900040                 jmp     #LPOPX                          ' discard the index
                                                                                   ' then next loop and its branch address
                   
                   ' ?NEXT ( flg -- index ) Same as NEXT except terminate early if flag is true and return with flag
ff0f7 11e f6084a25 QNEXT           mov     tos,tos wz
ff0fb 11f 5d9fffe4         if_nz   jmp     #POPBRANCH
ff0ff 120 f19c5401                 sub     index,#1 wcz
ff103 121 5603f02d         if_nz   mov     PTRA,branchadr
ff107 122 5d9ffd10         if_nz   jmp     #DROP                           ' discard flag and continye looping
ff10b 123 fd9fffd4                 jmp     #POPBRANCH
                   
                   ' NEXT ( -- ) Decrement count (on loop stack) and loop until 0, then pop loop stack
ff10f 124 fb6455f4 forNEXT         djz     index,#POPBRANCH                ' exit loop
ff113 125 0603f02d         _ret_   mov     PTRA,branchadr                  ' loop again
                   
                   
                   ' LEAVE -  make the loop index = to the limit so that it will leave on the next LOOP
ff117 126 f6005429 LEAVE           mov     index,limit1
ff11b 127 01845401         _ret_   sub     index,#1
                   
                   {HELP >R ( n -- ) Push n onto the return stack }
ff11f 128 fc304a14 PUSHR           wrlut   tos,retptr
ff123 129 f1042801                 add     retptr,#1
ff127 12a fd9ffcf0                 jmp     #DROP
                   
                   {HELP R> ( -- n ) Pop n from the return stack }
ff12b 12b f1842801 RPOP            sub     retptr,#1
ff12f 12c faa01614                 rdlut   fx,retptr
ff133 12d fd900054                 jmp     #PUSHX                          ' Push X onto the data stack as tos
                   
                   
                   
ff137 12e          LPOPX
ff137 12e f600162a                 mov     fx,index
ff13b 12f f6005429                 mov     index,limit1
ff13f 130 f600522c                 mov     limit1,index2
ff143 131 f600582b                 mov     index2,limit2
ff147 132 f1842601                 sub     lpptr,#1
ff14b 133 0aa05613         _ret_   rdlut   limit2,lpptr
                   
                   ' 171231 - mod so that index is on top/last
                   ' limit         -> index
                   ' index         -> limit
                   ' limit2        -> indexJ
                   ' index2        -> limitJ
                   ' stack
                   
                   ' >L ( tos -- ) Push tos onto the loop stack and drop tos
ff14f 134          PUSHL
ff14f 134 fc305613                 wrlut   limit2,lpptr                    ' push bottom register to stack
ff153 135 f1042601                 add     lpptr,#1
ff157 136 f600562c                 mov     limit2,index2                   ' ripple registers
ff15b 137 f6005829                 mov     index2,limit1
ff15f 138 f600522a                 mov     limit1,index
ff163 139 f6005425                 mov     index,tos
ff167 13a fd9ffcb0                 jmp     #POPX
                   
                   
                   { *** LITERALS *** }
                   
                   ' LITERALS are stored unaligned in big endian format which faciliates cascading byte reads to accumulate the full number
                   
                   ' ( -- 32bits ) Push a 32-bit literal onto the datastack by reading in the next 4 bytes (non-aligned)
                   
ff16b 13b fb041761 _LONG                   rdlong  fx,PTRA++
ff16f 13c fd900018                         jmp     #PUSHX
                   
                   ' Read an inline word literal and push it onto the stack
                   '
ff173 13d fae41761 _WORD                   rdword  fx,PTRA++
ff177 13e fd900010                         jmp     #PUSHX
                   
                   
                   { *** FAST CONSTANTS *** }
                   
                   ' Only one fast constant is needed, -1
                   ' Also 9-bit literals are encoded as wordcodes
                   
ff17b 13f          _TRUE
ff17b 13f f1841401 MINUS1          sub     ACC,#1
ff17f 140 f600160a PUSHACC         mov     fx,ACC          ' Push the accumulator onto the stack then zero it
ff183 141 fd900004                 jmp     #PUSHX
                   
ff187 142 f50417ff doLIT9          and     fx,#$1FF                ' push 9-bit literal
ff18b 143 f6041400 PUSHX           mov     ACC,#0          ' clear it for next operation
ff18f 144 fc305011                 wrlut   tos3,datptr     ' save bottom of register stack into lut memory
ff193 145 f1042201                 add     datptr,#1
ff197 146 f6005027                 mov     tos3,tos2       ' push 4 top items held in registers
ff19b 147 f6004e26                 mov     tos2,tos1
ff19f 148 f6004c25                 mov     tos1,tos
ff1a3 149 f6004a0b                 mov     tos,fx          ' replace tos with X (DEFAULT)
ff1a7 14a f1042a01                 add     depth,#1        ' the depth variable indexes bytes in LUT
ff1ab 14b 0d74006f         _ret_   modcz   0,0 wc 		' clear C for some operations that use this to determine behaviour
                   
                   
                   
                   { *** CONSTANTS & VARIABLES *** }
                   { Constants and variables etc are standalone fragments preceded by an opcode then the parameters,
                   either a long or the addess of the parameter field.
                   They are called from the main program and only use the IP to get the result.
                   }
                   
ff1af 14c 00000000 DATCON                  nop                     ' This entry is used for constants that point to the DATA area - FORGETable by signature
ff1b3 14d fb041700 CONL                    rdlong  fx,PTRA
ff1b7 14e fdbfffd0                         call    #PUSHX
ff1bb 14f fd9ffc44                         jmp     #EXIT
                   
ff1bf 150 fae41700 CONW			rdword  fx,PTRA
ff1c3 151 fdbfffc4 			call    #PUSHX
ff1c7 152 fd9ffc38 			jmp     #EXIT
                   
                   ' INLINE:
ff1cb 153 f60017f8 VARB                    mov     fx,PTRA
ff1cf 154 fdbfffb8                         call    #PUSHX
ff1d3 155 fd9ffc2c                         jmp     #EXIT
                   
                   
                   
                   
                   
                   
                   { *** SMART PINS *** }
                   {
                   WRPIN   D/#,S/#    - Set smart pin S/# mode to D/#
                   WXPIN   D/#,S/#    - Set smart pin S/# parameter X to D/#
                   WYPIN   D/#,S/#    - Set smart pin S/# parameter Y to D/#
                   RDPIN   D,S/#        - Get smart pin S/# result Z into D
                   
                   V30
                   WRPIN   D/#,S/#    - Set smart pin S/# mode to D/#, acknowledge pin
                   WXPIN   D/#,S/#    - Set smart pin S/# parameter X to D/#, ack
                   WYPIN   D/#,S/#    - Set smart pin S/# parameter Y to D/#, ack
                   RDPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, ack
                   RQPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, don't ack
                   AKPIN   S/#        - Acknowledge pin S/#
                   
                   }
                   
                   ' 160620-2300 - MODIFIED SMARTPIN OPS TO USE "pinreg" for faster access
                   ' WRPIN   D/#,S/#    - Set smart pin S/# mode to D/#, acknowledge pin
                   ' WRPIN ( dst -- )
ff1d7 156 fc004a18 _WRPIN                  wrpin   tos,pinreg
ff1db 157 fd9ffc3c                         jmp     #DROP
                   
                   
                   ' WXPIN   D/#,S/#    - Set smart pin S/# parameter X to D/#, ack
                   ' WXPIN ( dst -- )
ff1df 158 fc104a18 _WXPIN                  wxpin   tos,pinreg
ff1e3 159 fd9ffc34                         jmp     #DROP
                   
                   
                   ' WYPIN   D/#,S/#    - Set smart pin S/# parameter Y to D/#, ack
                   ' WYPIN ( dst -- )
ff1e7 15a fc204a18 _WYPIN                  wypin   tos,pinreg
ff1eb 15b fd9ffc2c                         jmp     #DROP
                   
                   
                   ' RDPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, ack
                   ' RDPIN ( -- res )
ff1ef 15c fa881618 _RDPIN                  rdpin   fx,pinreg
ff1f3 15d fd9fff94                         jmp     #PUSHX
                   
                   ' RQPIN   D,S/# {WC}    - Get smart pin S/# result Z into D, flag into C, don't ack
                   ' RQPIN ( -- res )
ff1f7 15e fa801618 _RQPIN                  rqpin   fx,pinreg
ff1fb 15f fd9fff8c                         jmp     #PUSHX
                   
                   
                   ' AKPIN   S/#        - Acknowledge pin S/#
                   ' AKPIN  ( -- )
ff1ff 160 0c080218 _AKPIN          _ret_   wrpin   #1,pinreg
                   
                   ' BEGIN RDPIN $80 AND 0= UNTIL
ff203 161 fa881618 WAITPIN                 rdpin   fx,pinreg
ff207 162 f40c1607                         testb   fx,#7 wz
ff20b 163 5d9ffff4                 if_nz   jmp     #WAITPIN
ff20f 164 fd64002d                         ret
                   
                   ' TXDAT ( buf cnt -- )  write buffer direct to WYPIN
ff213 165 fc780026 _TXDAT                  rdfast  #0,tos+1
                   ''                      rep     @.end,tos
ff217 166 fd601610 .L1                     rfbyte  fx
ff21b 167 fc201618                         wypin   fx,pinreg
ff21f 168 fd703040 .wait                   testp   pinreg  wc              '..wait for buffer empty
ff223 169 3d9ffff8         if_nc           jmp     #.wait
ff227 16a fc080218                         akpin   pinreg                  '..acknowledge pin
ff22b 16b fb6c4bfa                         djnz    tos,#.L1
ff22f 16c fd9ffbe4 .end                    jmp     #DROP2
                   
                   
                   
                   { *** I/O ACCESS *** }
                   
                   
                   ' Fast pin operations via PIN pinreg
                   
                   ' H - set the PIN high - fast as the parameter is in the pinreg
ff233 16d 0d603059 H               _ret_   drvh    pinreg
                   
                   ' L - set the PIN low - fast as the parameter is in the pinreg
ff237 16e 0d603058 L               _ret_   drvl    pinreg
                   
ff23b 16f 0d60305f _T              _ret_   drvnot  pinreg
                   
                   ' F - float pin
ff23f 170 0d603040 F               _ret_   dirl    pinreg
                   ' R - read pin
                   
ff243 171 fd703040 R                       testp   pinreg wc
ff247 172 c1841401                 if_c    sub     ACC,#1
ff24b 173 fd9fff30                         jmp     #PUSHACC
                   
                   ' normal pin operations via stack
                   
                   ' HIGH ( pin -- )
ff24f 174 fd604a59 HIGH                    drvh    tos
ff253 175 fd9ffbc4                         jmp     #DROP
                   ' LOW ( pin -- )
ff257 176 fd604a58 LOW                     drvl    tos
ff25b 177 fd9ffbbc                         jmp     #DROP
                   ' FLOAT ( pin -- )
ff25f 178 fd604a40 _FLOAT                  dirl    tos
ff263 179 fd9ffbb4                         jmp     #DROP
                   ' PIN@ ( bit -- state )
ff267 17a fd704a40 PINTEST                 testp   tos wc
ff26b 17b 05804b7c                 _ret_   muxc    tos,M1
                   
ff26f 17c ffffffff M1                      long    -1
                   
                   
                   '************************************* SERIAL I/O **************************************
ff273 17d f6030a25 SEROUT		mov	txpin,tos
ff277 17e fd9ffba0 		jmp	#DROP
ff27b 17f f6070a3e CONEMIT		mov	txpin,#tx_pin
ff27f 180 fc204a3e                 wypin   tos,tx_pin             '..send byte
ff283 181 fd64001f 		waitx	#0
ff287 182 fd707c40 .wait           testp   tx_pin         wc      '..wait for buffer empty
ff28b 183 3d9ffff8  if_nc          jmp     #.wait
ff28f 184 fd9ffb88                 jmp     #DROP
ff293 185 0000003e txpin		long	tx_pin
                   
                   
                   '********************** SPI READ/WRITE *********************
                   
                   ' 461.7us/512
                   ' SPI>BUF ( dst cnt -- sum )
ff297 186 fc880026 SPIRX           wrfast  #0,tos1
ff29b 187 f6044c00                 mov     tos1,#0
ff29f 188 fcdc0808 .L0             rep     @.end,#8                ' 8 bits
ff2a3 189 fd60044f                 outnot  sck                     ' clock (low high or low high)
ff2a7 18a fd60044f                 outnot  sck
ff2ab 18b fd700840                 testp   miso wc                 ' read data from card
ff2af 18c f0a41a01                 rcl     r1,#1                   ' shift in msb first
ff2b3 18d fd601a15 .end            wfbyte  r1
ff2b7 18e f1004c0d                 add     tos1,r1
ff2bb 18f fb6c4bf8                 djnz    tos,#.L0
ff2bf 190 fd9ffb58                 jmp     #DROP
                   
ff2c3 191          SPIRDL
ff2c3 191 fcdc0c20                 rep     @sre1,#32
ff2c7 192 fd640231                 skip    #1
                   ' SPIRD ( dat -- dat+rd )
ff2cb 193 fcdc0808 SPIRD           rep     @sre1,#8                ' 8 bits
ff2cf 194 fd60044f                 outnot  sck                     ' clock (low high)
ff2d3 195 fd60044f                 outnot  sck
ff2d7 196 fd700840                 testp   miso wc                 ' read data from card
ff2db 197 f0a44a01                 rcl     tos,#1                  ' shift in msb first
ff2df 198 fd64002d sre1            ret
                   
                   ' 474.6us/512
                   ' SPITX ( src bytes -- )
ff2e3 199 fd600a58 SPITXE          drvl    ss
ff2e7 19a fc780026 SPITX           rdfast  #0,tos1
ff2eb 19b fd601a10 .L0             rfbyte  r1
ff2ef 19c f0641a18                 shl     r1,#24
ff2f3 19d fcdc0808                 rep     @.L1 , #8
ff2f7 19e f0341a01                 rol     r1,#1 wc                ' output next msb
ff2fb 19f fd60064a                 outc    mosi
ff2ff 1a0 fd60044f                 outnot  sck                     ' clock
ff303 1a1 fd60044f                 outnot  sck                     ' clock
ff307 1a2 fb6c4bf8 .L1             djnz    tos,#.L0
ff30b 1a3 fd9ffb08                 jmp     #DROP2
                   
ff30f 1a4 f6041a20 SPIWRL		mov	r1,#32
ff313 1a5 fd900028 		jmp	#SPIWR
ff317 1a6 f0644a08 SPIWM		shl	tos,#8
ff31b 1a7 f6041a18 		mov	r1,#24
ff31f 1a8 fd90001c 		jmp	#SPIWR
ff323 1a9 f0644a10 SPIWR16		shl	tos,#16
ff327 1aa f6041a10 		mov	r1,#16
ff32b 1ab fd900010 		jmp	#SPIWR
                   
                   ' Write SD Command
ff32f 1ac f5044a3f SPIWRC		and     tos,#$3F
ff333 1ad f5444a40 		or      tos,#$40
                   ' SPIWR8 ( byte -- )
                   ' Shift 8 bits from data[0..7] out and leave data on stack (restored with other bytes zeroed)
                   '
ff337 1ae f0644a18 SPIWR8          shl     tos , #24               ' left justify 8-bit data s
ff33b 1af f6041a08 		mov	r1,#8
                   '
                   ' SPIWR ( data -- )
                   '
ff33f 1b0 fd600a58 SPIWR           drvl    ss                      ' chip enable
ff343 1b1 fcd8080d                 rep     @.L1 , r1
ff347 1b2 f0344a01                 rol     tos,#1 wc               ' output next msb
ff34b 1b3 fd60064a                 outc    mosi
ff34f 1b4 fd60044f                 outnot  sck                     ' clock
ff353 1b5 fd60044f                 outnot  sck                     ' clock
ff357 1b6 fd9ffac0 .L1             jmp	#DROP
                   
ff35b 1b7 0d600a49 SPICE   _ret_   outh    ss
                   
                   
                   ' I2C support
                   ' CLKOUT ( iobit dat -- iobit dat2 ) REG6=iomask ) Shift msb bit out,  clock high, clock low
ff35f 1b8 fd604c48 CLKOUT          outl    tos+1              ' ensure output will be active low
ff363 1b9 fd603658                 drvl    clockpins
ff367 1ba f0744a01                 shl     tos,#1 wc
ff36b 1bb fd604c43                 dirnc   tos+1                   ' make it an output if it is a low else float
                   ' CLOCK ( REG6=iomask ) Toggle multiple bits on the output)
ff36f 1bc fd60364f CLOCK           outnot  clockpins
ff373 1bd fb943802                 tjz     clkdly,#ckx
ff377 1be f600161c                 mov     fx,clkdly
ff37b 1bf 0b6c17ff         _ret_   djnz    fx,#$
ff37f 1c0 fd64002d ckx             ret
                   
                   ' $01CA
                   ' CLKIN ( iomask dat -- iomask dat2 )
ff383 1c1 fd604c40 CLKIN           dirl    tos+1
ff387 1c2 fd704c40                 testp   tos+1 wc
ff38b 1c3 f0a44a01                 rcl     tos,#1
ff38f 1c4 fd9fffdc                 jmp     #CLOCK
                   
                   
                   ' timing utility word
ff393 1c5 f6002e16 LAP             mov     lap2,lap1
ff397 1c6 0d602c1a         _ret_   getct   lap1
                   
                   
ff39b 1c7          ENDCOG
ff39b 1c7                          fit 496
                   
                   '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
                   
                   
                   
                   
                   '************************************** DICTIONARY **********************************
                   
                   { *** DICTIONARY *** }
ff39b                      orgh
ff39b              romdict
                   
                   ' The count field is left blank but filled in at cold boot so that these do not need to be calculated when defining
                   '
                           ''      CNT,NAME,ATR,addr16
ff39b     50554403         byte 3, "DUP"
ff39f     0071             word                    DUP
ff3a1     45564f04         byte 4, "OVER"
ff3a6     0074             word                    OVER
ff3a8     41575304         byte 4, "SWAP"
ff3ad     007b             word                    SWAP
ff3af     544f5203         byte 3, "ROT"
ff3b3     007f             word                    ROT
ff3b5     4f522d04         byte 4, "-ROT"
ff3ba     007e             word                    ROT2
ff3bc     4f524404         byte 4, "DROP"
ff3c1     0067             word                    DROP
ff3c3     44523303         byte 3, "3RD"
ff3c7     0076             word                    THIRD
ff3c9     48543403         byte 3, "4TH"
ff3cd     0078             word                    FOURTH
                   
ff3cf     52443205         byte 5, "2DROP"
ff3d5     0066             word                    DROP2
ff3d7     52443305         byte 5, "3DROP"
ff3dd     0065             word                    DROP3
ff3df     50494e03         byte 3, "NIP"
ff3e3     0063             word                    NIP
ff3e5     57533205         byte 5, "2SWAP"
ff3eb     ea5e             word                    DSWAP
ff3ed     55443204         byte 4, "2DUP"
ff3f2     0073             word                    DUP2
ff3f4     55443f04         byte 4, "?DUP"
ff3f9     0070             word                    QDUP
                   
                   ' BITWISE LOGIC
ff3fb     444e4103         byte 3, "AND"
ff3ff     0090             word                    _AND
ff401     444e4104         byte 4, "ANDN"
ff406     0092             word                    _ANDN
ff408     524f02           byte 2, "OR"
ff40b     0094             word                    _OR
ff40d     524f5803         byte 3, "XOR"
ff411     0096             word                    _XOR
                   
ff413     52455a05         byte 5, "ZEROX"
ff419     0098             word                    _ZEROX
                   
                   ' SHIFT'
ff41b     4c4f5203         byte 3, "ROL"
ff41f     00a7             word                    _ROL
ff421     524f5203         byte 3, "ROR"
ff425     00a1             word                    _ROR
ff427     3e3e02           byte 2, ">>"
ff42a     009a             word                    _SHR
ff42c     3c3c02           byte 2, "<<"
ff42f     00a5             word                    _SHL
ff431     52415303         byte 3, "SAR"
ff435     00a3             word                    _SAR
ff437     2f3202           byte 2, "2/"
ff43a     00a0             word                    _SHR1
ff43c     2a3202           byte 2, "2*"
ff43f     00ac             word                    _SHL1
ff441     2f3402           byte 2, "4/"
ff444     009f             word                    _SHR2
ff446     2a3402           byte 2, "4*"
ff449     00ab             word                    _SHL2
ff44b     3c3c3803         byte 3, "8<<"
ff44f     00aa             word                    _SHL8
ff451     3e363104         byte 4, "16>>"
ff456     009c             word                    _SHR16
ff458     3e3e3803         byte 3, "8>>"
ff45c     009e             word                    _SHR8
ff45e     3c3c3903         byte 3, "9<<"
ff462     00a9             word                    _SHL9
ff464     3e3e3903         byte 3, "9>>"
ff468     009d             word                    _SHR9
                   
ff46a     56455203         byte 3, "REV"
ff46e     00ad             word                    _REV
ff470     3c7c02           byte 2, "|<"
ff473     00ae             word                    MASK
ff475     7c3e02           byte 2, ">|"
ff478     00af             word                    ENCODE
                   
ff47a     4e3e02           byte 2, ">N"
ff47d     00b0             word                    BITS4
ff47f     423e02           byte 2, ">B"
ff482     00b1             word                    BITS8
ff484     393e02           byte 2, ">9"
ff487     00b2             word                    BITS9
ff489     54494204         byte 4, "BITS"
ff48e     008e             word                    BITS
                   
                   
ff490     544f4e03         byte 3, "NOT"
ff494     00be             word                    _NOT
                   
                   ' COMPARISON
ff496     3d01             byte 1, "="
ff498     00b3             word                    _EQ
ff49a     3e3c02           byte 2, "<>"
ff49d     00ba             word                    _NEQ
                   
ff49f     3d3002           byte 2, "0="
ff4a2     00b5             word                    _ZEQ
ff4a4     3e3c3003         byte 3, "0<>"
ff4a8     00b7             word                    _ZNE
ff4aa     3c3002           byte 2, "0<"
ff4ad     00bd             word                    _ZLT
ff4af     3c01             byte 1, "<"
ff4b1     ea16             word                    LT
ff4b3     3c5502           byte 2, "U<"
ff4b6     ea1e             word                    _ULT
ff4b8     3e01             byte 1, ">"
ff4ba     ea0e             word                    GT
ff4bc     3e5502           byte 2, "U>"
ff4bf     d0f0             word                    UGT
ff4c1     3d3c02           byte 2, "<="
ff4c4     d0f6             word                    LTEQ
ff4c6     3e3d02           byte 2, "=>"
ff4c9     d0f8             word                    EQGT
ff4cb     54495706         byte 6, "WITHIN"
ff4d2     d794             word                    WITHIN
                   
ff4d4     50554405         byte 5, "DUPC@"
ff4da     00dc             word                    DUPCFT
                   
ff4dc     404302           byte 2, "C@"
ff4df     00db             word                    CFETCH
ff4e1     405702           byte 2, "W@"
ff4e4     00de             word                    WFETCH
ff4e6     4001             byte 1, "@"
ff4e8     00df             word                    FETCH
ff4ea     212b4303         byte 3, "C+!"
ff4ee     00e0             word                    CPLUSST
ff4f0     214302           byte 2, "C!"
ff4f3     00e2             word                    CSTORE
ff4f5     2b404304         byte 4, "C@++"
ff4fa     00d8             word                    CFETCHINC
ff4fc     212b5703         byte 3, "W+!"
ff500     00e4             word                    WPLUSST
ff502     215702           byte 2, "W!"
ff505     00e6             word                    WSTORE
ff507     212b02           byte 2, "+!"
ff50a     00e8             word                    PLUSST
ff50c     2101             byte 1, "!"
ff50e     00ea             word                    STORE
                   
ff510     54494204         byte 4, "BIT!"
ff515     eaf6             word                    BITST
ff517     54455303         byte 3, "SET"
ff51b     eafe             word                    SET
ff51d     524c4303         byte 3, "CLR"
ff521     eb0e             word                    CLR
ff523     54455304         byte 4, "SET?"
ff528     eb1e             word                    BITQ
                   
                   
                   
                   ' MATHS
ff52a     2b3102           byte 2, "1+"
ff52d     0089             word                    INC
ff52f     2d3102           byte 2, "1-"
ff532     0086             word                    DEC
ff534     2b3202           byte 2, "2+"
ff537     0088             word                    INC2
ff539     2d3202           byte 2, "2-"
ff53c     0085             word                    DEC2
ff53e     2b3402           byte 2, "4+"
ff541     0087             word                    INC4
ff543     2b01             byte 1, "+"
ff545     0083             word                    PLUS
ff547     2d01             byte 1, "-"
ff549     0082             word                    MINUS
                   
ff54b     2a4d5503         byte 3, "UM*"
ff54f     00c5             word                    UMMUL
ff551     2a01             byte 1, "*"
ff553     00c0             word                    _MUL
ff555     2a5702           byte 2, "W*"
ff558     00c3             word                    MUL16
                   
ff55a     2f01             byte 1, "/"
ff55c     d0fe             word                    DIVIDE
ff55e     2f5502           byte 2, "U/"
ff561     00cd             word                    UDIVIDE
ff563     2f2f5503         byte 3, "U//"
ff567     00c8             word                    UDIVMOD
ff569     2f2f02           byte 2, "//"
ff56c     00cb             word                    UMOD
ff56e     2f2a02           byte 2, "*/"
ff571     d110             word                    MULDIV
ff573     2f4d5504         byte 4, "UM//"
ff578     ea2a             word                    UMDIVMOD64
                   
ff57a     2b2b4303         byte 3, "C++"
ff57e     d122             word                    CINC
ff580     2d2d4303         byte 3, "C--"
ff584     d11e             word                    CDEC
ff586     2b2b5703         byte 3, "W++"
ff58a     d12e             word                    WINC
ff58c     2d2d5703         byte 3, "W--"
ff590     d12a             word                    WDEC
ff592     2b2b02           byte 2, "++"
ff595     d13a             word                    LINC
ff597     2d2d02           byte 2, "--"
ff59a     d136             word                    LDEC
                   
ff59c     444e5203         byte 3, "RND"
ff5a0     e9f6             word                    _RND
ff5a2     54454706         byte 6, "GETRND"
ff5a9     eb6a             word                    _GETRND
ff5ab     52515304         byte 4, "SQRT"
ff5b0     eb5e             word                    _SQRT
                   
ff5b2     7e01             byte 1, "~"
ff5b4     eb32             word                    CLRL
ff5b6     7e7e02           byte 2, "~~"
ff5b9     eb2e             word                    SETL
ff5bb     7e5702           byte 2, "W~"
ff5be     eb3e             word                    CLRW
ff5c0     7e7e5703         byte 3, "W~~"
ff5c4     eb3a             word                    SETW
ff5c6     7e4302           byte 2, "C~"
ff5c9     eb4a             word                    CLRC
ff5cb     7e7e4303         byte 3, "C~~"
ff5cf     eb46             word                    SETC
                   
ff5d1     533e4c03         byte 3, "L>S"
ff5d5     eae6             word                    L2S
ff5d7     573e02           byte 2, ">W"
ff5da     e1ae             word                    TOW
ff5dc     573e4c03         byte 3, "L>W"
ff5e0     e1b6             word                    L2W
ff5e2     423e5703         byte 3, "W>B"
ff5e6     e1c0             word                    W2B
ff5e8     4c3e5703         byte 3, "W>L"
ff5ec     e1d4             word                    W2L
ff5ee     573e4203         byte 3, "B>W"
ff5f2     e1d6             word                    B2W
ff5f4     4c3e4203         byte 3, "B>L"
ff5f8     e1cc             word                    B2L
                   
                   
                   
ff5fa     4e494d04         byte 4, "MINS"
ff5ff     00d0             word                    _MINS
ff601     58414d04         byte 4, "MAXS"
ff606     00d2             word                    _MAXS
ff608     4e494d03         byte 3, "MIN"
ff60c     00d4             word                    _MIN
ff60e     58414d03         byte 3, "MAX"
ff612     00d6             word                    _MAX
                   
ff614     53424103         byte 3, "ABS"
ff618     00bf             word                    _ABS
                   
ff61a     454e2d07         byte 7, "-NEGATE"
ff622     008a             word                    MNEGATE
ff624     454e3f07         byte 7, "?NEGATE"
ff62c     008b             word                    QNEGATE
ff62e     47454e06         byte 6, "NEGATE"
ff635     008d             word                    NEGATE
                   
                   
                   ' CONSTANTS '
ff637     4e4f02           byte 2, "ON"
ff63a     013f             word                    MINUS1
ff63c     55525404         byte 4, "TRUE"
ff641     013f             word                    MINUS1
ff643     312d02           byte 2, "-1"
ff646     013f             word                    MINUS1
                   
ff648     4c414605         byte 5, "FALSE"
ff64e     fe00             word                    _0
ff650     46464f03         byte 3, "OFF"
ff654     fe00             word                    _0
                   
                   
                   
                   ' STRUCTURES
ff656     544f4784         byte 4+im,      "GOTO"
ff65b     d4f8             word                    GOTO
ff65d     464982           byte 2+im,      "IF"
ff660     d4ec             word                    _IF_
ff662     534c4584         byte 4+im,      "ELSE"
ff667     d504             word                    _ELSE_
ff669     45485484         byte 4+im,      "THEN"
ff66e     d514             word                    _THEN_
                           'byte 5,        "ENDIF"         +im
                           'word                   _THEN_
ff670     47454285         byte 5+im,      "BEGIN"
ff676     d4a4             word                    _BEGIN_
ff678     544e5585         byte 5+im,      "UNTIL"
ff67e     d4d2             word                    _UNTIL_
ff680     41474185         byte 5+im,      "AGAIN"
ff686     d4c6             word                    _AGAIN_
ff688     49485785         byte 5+im,      "WHILE"
ff68e     d4ec             word                    _IF_
ff690     50455286         byte 6+im,      "REPEAT"
ff697     d4c0             word                    _REPEAT_
ff699     49575306         byte 6,         "SWITCH"
ff6a0     d76c             word                    _SWITCH
ff6a2     53414305         byte 5,         "CASE@"
ff6a8     d772             word                    SWFETCH
ff6aa     53414305         byte 5,         "CASE="
ff6b0     d776             word                    ISEQ
ff6b2     53414305         byte 5,         "CASE>"
ff6b8     d78e             word                    ISWITHIN
ff6ba     45524285         byte 5+im,      "BREAK"
ff6c0     d784             word                    ISEND
ff6c2     53414384         byte 4+im,      "CASE"
ff6c7     d77c             word                    _CASE
                   
                   ' LOOPS'
ff6c9     4f444103         byte 3, "ADO"
ff6cd     0108             word                    ADO
ff6cf     4f4402           byte 2, "DO"
ff6d2     0109             word                    DO
ff6d4     4f4f4c04         byte 4, "LOOP"
ff6d9     0114             word                    LOOP
ff6db     4f4c2b05         byte 5, "+LOOP"
ff6e1     0111             word                    PLOOP
ff6e3     524f4603         byte 3, "FOR"
ff6e7     010b             word                    FOR
ff6e9     58454e04         byte 4, "NEXT"
ff6ee     0124             word                    forNEXT
ff6f0     454e3f05         byte 5, "?NEXT"
ff6f6     011e             word                    QNEXT
ff6f8     4901             byte 1, "I"
ff6fa     0101             word                    IX
ff6fc     4a01             byte 1, "J"
ff6fe     0103             word                    J
ff700     41454c05         byte 5, "LEAVE"
ff706     0126             word                    LEAVE
ff708     40434903         byte 3, "IC@"
ff70c     0105             word                    ICFETCH
ff70e     2b4902           byte 2, "I+"
ff711     0107             word                    IPLUS
ff713     554f4206         byte 6, "BOUNDS"
ff71a     007a             word                    BOUNDS
                   
                   
                   ' -------------I/O---------------
                   
ff71c     4801             byte 1, "H"
ff71e     016d             word                    H
ff720     4c01             byte 1, "L"
ff722     016e             word                    L
ff724     5401             byte 1, "T"
ff726     016f             word                    _T
ff728     4601             byte 1, "F"
ff72a     0170             word                    F
ff72c     5201             byte 1, "R"
ff72e     0171             word                    R
ff730     47494804         byte 4, "HIGH"
ff735     0174             word                    HIGH
ff737     574f4c03         byte 3, "LOW"
ff73b     0176             word                    LOW
ff73d     4f4c4605         byte 5, "FLOAT"
ff743     0178             word                    _FLOAT
                   
ff745     4e495004         byte 4, "PIN@"
ff74a     017a             word                    PINTEST
                   
                   
                   ''      byte 6, "SHROUT"
                   ''      word                    SHROUT
                   ''      byte 6, "SHRINP"
                   ''      word                    SHRINP
                   
                   ' SMARTPIN INSTRUCTIONS
ff74c     50525705         byte 5, "WRPIN"
ff752     0156             word                    _WRPIN
ff754     50585705         byte 5, "WXPIN"
ff75a     0158             word                    _WXPIN
ff75c     50595705         byte 5, "WYPIN"
ff762     015a             word                    _WYPIN
                   
ff764     50445205         byte 5, "RDPIN"
ff76a     015c             word                    _RDPIN
ff76c     50515205         byte 5, "RQPIN"
ff772     015e             word                    _RQPIN
ff774     504b4105         byte 5, "AKPIN"
ff77a     0160             word                    _AKPIN
                   
ff77c     49415707         byte 7, "WAITPIN"
ff784     0161             word                    WAITPIN
                   
ff786     41525705         byte 5, "WRACK"
ff78c     e9e2             word                    WRACK
                   
                   
                   
ff78e     4e495003         byte 3, "PIN"
ff792     e9d2             word                    _PIN
ff794     49504004         byte 4, "@PIN"
ff799     e9ca             word                    _ATPIN
                   
                   
ff79b     736e02           byte 2, "ns"
ff79e     d19e             word                    ns
ff7a0     575002           byte 2, "PW"
ff7a3     d1a6             word                    PW
ff7a5     4c555005         byte 5, "PULSE"
ff7ab     d1b0             word                    PULSE
ff7ad     4c555006         byte 6, "PULSES"
ff7b4     d1b2             word                    PULSES
ff7b6     4c494804         byte 4, "HILO"
ff7bb     d1b6             word                    HILO
                   
                   
                   
                   ' SMARTPIN NCO/PWM
ff7bd     54554404         byte 4, "DUTY"
ff7c2     d16c             word                    DUTY
ff7c4     4f434e03         byte 3, "NCO"
ff7c8     d15a             word                    NCO
ff7ca     5a4802           byte 2, "HZ"
ff7cd     d158             word                    HZ
ff7cf     5a484b03         byte 3, "KHZ"
ff7d3     d154             word                    KHZ
ff7d5     5a484d03         byte 3, "MHZ"
ff7d9     d150             word                    MHZ
ff7db     54554d04         byte 4, "MUTE"
ff7e0     d146             word                    MUTE
ff7e2     494c4205         byte 5, "BLINK"
ff7e8     d180             word                    BLINK
ff7ea     4d575003         byte 3, "PWM"
ff7ee     d186             word                    PWM
ff7f0     57415303         byte 3, "SAW"
ff7f4     d19a             word                    SAW
                   
                   
                   ' SMARTPIN ASYNCH
ff7f6     54494203         byte 3, "BIT"
ff7fa     d1d4             word                    BIT
ff7fc     55414204         byte 4, "BAUD"
ff801     d1e0             word                    BAUDST
ff803     44585403         byte 3, "TXD"
ff807     d1dc             word                    TXD
ff809     44585203         byte 3, "RXD"
ff80d     d1fe             word                    RXD
                   
ff80f     44585405         byte 5, "TXDAT"
ff815     0165             word                    _TXDAT
                   
                   {
                           byte c, "PA@"
                           word                    PAFETCH
                           byte c, "PB@"
                           word                    PBFETCH
                           byte c, "PA!"
                           word                    PASTORE
                           byte c, "PB!"
                           word                    PBSTORE
                           byte c, "DACLR"
                           word                    DACLR
                           byte c, "DBCLR"
                           word                    DBCLR
                           byte c, "PASET"
                           word                    PASET
                           byte c, "DASET"
                           word                    DASET
                           byte c, "PBSET"
                           word                    PBSET
                           byte c, "DBSET"
                           word                    DBSET
                           byte c, "PACLR"
                           word                    PACLR
                           byte c, "PBCLR"
                           word                    PBCLR
                    }
                   
ff817     49415705         byte 5, "WAITX"
ff81d     eada             word                    DELTA
ff81f     49415707         byte 7, "WAITCNT"
ff827     eae2             word                    WAITCNTS
                   
                   
                   
ff829     42455206         byte 6, "REBOOT"
ff830     d23a             word                    REBOOT
ff832     53455205         byte 5, "RESET"
ff838     0000             word                    RESET
ff83a     58453005         byte 5, "0EXIT"
ff840     005f             word                    ZEXIT
ff842     49584504         byte 4, "EXIT"
ff847     0061             word                    EXIT
                   ''      byte 6, "SKIPNZ"
                   ''      word                    SKIPNZ
                   
ff849     504f4e03         byte 3, "NOP"
ff84d     006f             word                    _NOP
ff84f     4c414304         byte 4, "CALL"
ff854     0032             word                    ACALL
ff856     4d554a04         byte 4, "JUMP"
ff85b     0030             word                    AJMP
                   
                   
ff85d     523e02           byte 2, ">R"
ff860     0128             word                    PUSHR
ff862     3e5202           byte 2, "R>"
ff865     012b             word                    RPOP
ff867     4c3e02           byte 2, ">L"
ff86a     0134             word                    PUSHL
ff86c     3e4c02           byte 2, "L>"
ff86f     010f             word                    LPOP
ff871     50532103         byte 3, "!SP"
ff875     e8a6             word                    INITSP
ff877     50454405         byte 5, "DEPTH"
ff87d     ec33             word                    _DEPTH
                   
ff87f     474f4304         byte 4, "COG@"
ff884     eab6             word                    COGFETCH
ff886     474f4304         byte 4, "COG!"
ff88b     eabe             word                    COGSTORE
ff88d     54554c04         byte 4, "LUT@"
ff892     00ec             word                    LUTFETCH
ff894     54554c04         byte 4, "LUT!"
ff899     00ed             word                    LUTSTORE
                   
ff89b     474f4305         byte 5, "COGID"
ff8a1     eaca             word                    _COGID
ff8a3     474f4307         byte 7, "COGINIT"
ff8ab     ead2             word                    _COGINIT
ff8ad     474f4307         byte 7, "COGSTOP"
ff8b5     e97a             word                    _COGSTOP
                   
ff8b7     474f4306         byte 6, "COGATN"
ff8be     e98a             word                    _COGATN
ff8c0     4c4f5007         byte 7, "POLLATN"
ff8c8     e992             word                    _POLLATN
ff8ca     54455306         byte 6, "SETEDG"
ff8d1     e99e             word                    _SETEDG
ff8d3     4c4f5007         byte 7, "POLLEDG"
ff8db     e9ae             word                    _POLLEDG
                   
                   
                   
                   
ff8dd     59454b03         byte 3, "KEY"
ff8e1     e0c4             word                    KEY
ff8e3     59454b04         byte 4, "KEY!"
ff8e8     e0c0             word                    PUTKEY
                   
                   ''      byte 7, "keypoll"
                   ''      word                    rg+keypoll
                   
ff8ea     4e4f4303         byte 3, "CON"
ff8ee     d078             word                    _CON
ff8f0     4e4f4e04         byte 4, "NONE"
ff8f5     d08a             word                    NONE
ff8f7     4d4f4303         byte 3, "COM"
ff8fb     d07e             word                    _COM
                   
                   
                   ''      byte 7, "DISCARD"
                   ''      word                    DISCARD
                   
ff8fd     4e4f4306         byte 6, "CONKEY"
ff904     e0ea             word                    CONKEY
ff906     4e4f4307         byte 7, "CONEMIT"
ff90e     017f             word                    CONEMIT
                   
ff910     494d4504         byte 4, "EMIT"
ff915     d040             word                    EMIT
ff917     494d4505         byte 5, "EMITS"
ff91d     d05e             word                    EMITS
                   
ff91f     4c524304         byte 4, "CRLF"
ff924     d0c8             word                    CRLF
ff926     524302           byte 2, "CR"
ff929     d0ce             word                    CR
ff92b     534c4303         byte 3, "CLS"
ff92f     d094             word                    CLS
                   
ff931     544f4403         byte 3, "DOT"
ff935     d0da             word                    DOT
ff937     41505305         byte 5, "SPACE"
ff93d     d03e             word                    SPACE
ff93f     41505306         byte 6, "SPACES"
ff946     d05a             word                    SPACES
                   
                   ' DUMP MEMORY
ff948     4d415203         byte 3, "RAM"
ff94c     d84a             word                    RAM
ff94e     4d554405         byte 5, "DUMP:"
ff954     d852             word                    SETDMP
ff956     4d554404         byte 4, "DUMP"
ff95b     d85c             word                    DUMP
ff95d     4d554405         byte 5, "DUMPW"
ff963     d88a             word                    DUMPW
ff965     4d554405         byte 5, "DUMPL"
ff96b     d8a8             word                    DUMPL
ff96d     4d554405         byte 5, "DUMPA"
ff973     d8c8             word                    DUMPA
ff975     4d554406         byte 6, "DUMPAW"
ff97c     d8c4             word                    DUMPAW
ff97e     445102           byte 2, "QD"
ff981     d86c             word                    QD
                   
ff983     42454405         byte 5, "DEBUG"
ff989     d948             word                    DEBUG
ff98b     69736c04         byte 4, "lsio"
ff990     d984             word                    lsio
                   
ff992     474f4303         byte 3, "COG"
ff996     d914             word                    _COG
ff998     54554c03         byte 3, "LUT"
ff99c     d90e             word                    _LUT
                   
ff99e     424b02           byte 2, "KB"
ff9a1     da0c             word                    KB
ff9a3     424d02           byte 2, "MB"
ff9a6     da08             word                    MB
ff9a8     4d01             byte 1, "M"
ff9aa     da02             word                    M
                   
                   
                   ' PRINTING
                   
ff9ac     2e01             byte 1, "."
ff9ae     da8c             word                    PRT
ff9b0     49525005         byte 5, "PRINT"
ff9b6     da8c             word                    PRT
                   
ff9b8     53412e03         byte 3, ".AS"
ff9bc     db9c             word                    PRTAS
ff9be     53412e84         byte 4+im,      ".AS",$22
ff9c3     dbd4             word                    PRTASR
                   
ff9c5     45442e05         byte 5, ".DECL"
ff9cb     dbdc             word                    PRTDECL
ff9cd     45442e05         byte 5, ".DEC4"
ff9d3     dbf0             word                    PRTDEC4
ff9d5     45442e05         byte 5, ".DEC2"
ff9db     dbfa             word                    PRTDEC2
                   
                   ''      byte c, "@PAD"
                   ''      word                    ATPAD
ff9dd     4c4f4804         byte 4, "HOLD"
ff9e2     da5a             word                    HOLD
                   ''      byte 5, ">CHAR"
                   ''      word                    BINASC
ff9e4     3e2302           byte 2, "#>"
ff9e7     da7e             word                    RHASH
ff9e9     233c02           byte 2, "<#"
ff9ec     da52             word                    LHASH
ff9ee     2301             byte 1, "#"
ff9f0     da62             word                    HASH
ff9f2     532302           byte 2, "#S"
ff9f5     da74             word                    HASHS
ff9f7     3e443c03         byte 3, "<D>"
ff9fb     da88             word                    DNUM
                   
ff9fd     2e5502           byte 2, "U."
ffa00     da98             word                    UPRT
ffa02     45442e04         byte 4, ".DEC"
ffa07     dc02             word                    PRTDEC
ffa09     49422e04         byte 4, ".BIN"
ffa0e     daac             word                    PRTBIN
                   
ffa10     422e02           byte 2, ".B"
ffa13     d7f6             word                    PRTB
ffa15     59422e05         byte 5, ".BYTE"
ffa1b     d7f8             word                    PRTBYTE
ffa1d     572e02           byte 2, ".W"
ffa20     d802             word                    PRTW
ffa22     4f572e05         byte 5, ".WORD"
ffa28     d804             word                    PRTWORD
ffa2a     4c2e02           byte 2, ".L"
ffa2d     d810             word                    PRTL
ffa2f     4f4c2e05         byte 5, ".LONG"
ffa35     d812             word                    PRTLONG
                   
ffa37     44412e05         byte 5, ".ADDR"
ffa3d     d8e6             word                    PRTADR
                   
                   
ffa3f     49525006         byte 6, "PRINT$"
ffa46     da9e             word                    PSTR
ffa48     4e454c04         byte 4, "LEN$"
ffa4d     0054             word                    STRLEN
                   
ffa4f     2281             byte 1+im,      $22
ffa51     d5a2             word                    _STRING_
ffa53     222e82           byte 2+im,      $2E,$22
ffa56     d5bc             word                    _PSTR_          ' ."
ffa58     59544305         byte 5, "CTYPE"
ffa5e     e1dc             word                    CTYPE
                   
                   
                   
                   
ffa60     58453f05         byte 5, "?EXIT"
ffa66     005c             word                    IFEXIT
                   
                   ''      byte c, "MOVBYTES"
                   ''      word                    _MOVBYTES
                   
                   ' MEMORY BLOCKS
ffa68     54414405         byte 5, "DATA?"
ffa6e     00fb             word                    DATAQ
ffa70     41524505         byte 5, "ERASE"
ffa76     00f6             word                    ERASE
ffa78     4c494604         byte 4, "FILL"
ffa7d     00f7             word                    CFILL
ffa7f     4f4d4305         byte 5, "CMOVE"
ffa85     00f0             word                    CMOVE
ffa87     4d433c06         byte 6, "<CMOVE"
ffa8e     d7a6             word                    RCMOVE
                   
                   ' TIMING
ffa90     7301             byte 1, "s"
ffa92     d7bc             word                    secs
ffa94     736d02           byte 2, "ms"
ffa97     d7c0             word                    ms
ffa99     737502           byte 2, "us"
ffa9c     d7d0             word                    us
                   
                   ' LAP TIMING
ffa9e     544e4304         byte 4, "CNT@"
ffaa3     e9c2             word                    _GETCNT
ffaa5     50414c03         byte 3, "LAP"
ffaa9     01c5             word                    LAP
ffaab     50414c04         byte 4, "LAP@"
ffab0     e96e             word                    LAPFETCH
ffab2     414c2e04         byte 4, ".LAP"
ffab7     e2b4             word                    PRTLAP
ffab9     736d2e03         byte 3, ".ms"
ffabd     e336             word                    PRTMS
                   
                   
                   ' RADIX
ffabf     58454803         byte 3, "HEX"
ffac3     d26c             word                    HEX
ffac5     43454403         byte 3, "DEC"
ffac9     d268             word                    DECIMAL
ffacb     4e494203         byte 3, "BIN"
ffacf     d260             word                    BIN
                   
ffad1     532e02           byte 2, ".S"
ffad4     e03c             word                    PRTSTK
                   
                   
                   ' DICTIONARY
ffad6     524f5705         byte 5, "WORDS"
ffadc     e22c             word                    WORDS
ffade     4f574006         byte 6, "@WORDS"
ffae5     d68c             word                    ATNAMES
ffae7     54454704         byte 4, "GET$"
ffaec     dd84             word                    _GETWORD
ffaee     41455306         byte 6, "SEARCH"
ffaf5     dd94             word                    SEARCH
ffaf7     233e2403         byte 3, "$>#"
ffafb     d3f4             word                    NUMBER
                   
ffafd     41444005         byte 5, "@DATA"
ffb03     e342             word                    ATDAT
ffb05     52454804         byte 4, "HERE"
ffb0a     d686             word                    ATHERE
ffb0c     45484005         byte 5, "@HERE"
ffb12     fd9d             word                    rg+here
ffb14     4f434006         byte 6, "@CODES"
ffb1b     fda1             word                    rg+codes
                   
                   ' TABLES
ffb1d     4f4f4c06         byte 6, "LOOKIN"
ffb24     ec4b             word                    LOOKIN
ffb26     4f4f4c06         byte 6, "LOOKUP"
ffb2d     ec73             word                    _LOOKUP
                   
                   
                   ' VARIABLES
ffb2f     6d657505         byte 5, "uemit"
ffb35     fd10             word                    rg+uemit
ffb37     656b7504         byte 4, "ukey"
ffb3c     fd12             word                    rg+ukey
ffb3e     61686304         byte 4, "char"
ffb43     fef0             word                    w+lastkey
ffb45     6c656405         byte 5, "delim"
ffb4b     fd6c             word                    rg+delim
ffb4d     6d616e05         byte 5, "names"
ffb53     fd95             word                    rg+names
                   
                   {
                   
                           byte c, "lead"
                           word                    rg+leader
                           byte c, "flags"
                           word                    rg+flags
                           byte c, "base"
                           word                    rg+base
                           byte c, "digits"
                           word                    rg+digits
                   ''      byte c, "temp"
                   ''      word                    rg+temp
                           byte c, "prompt"
                           word                    rg+prompt
                           byte c, "accept"
                           word                    rg+accept
                   ''      byte c, "rxptr"
                   ''      word                    rg+rxptr
                           byte c, "lines"
                           word                    rg+lines
                           byte c, "errors"
                           word                    rg+errors
                           byte c, "unum"
                           word                    rg+unum
                   }
                   
ffb55     53415404         byte 4, "TASK"
ffb5a     de18             word                    TASK
ffb5c     47455203         byte 3, "REG"
ffb60     e96a             word                    ATREG
ffb62     4f574005         byte 5, "@WORD"
ffb68     fd24             word                    rg+wordbuf
ffb6a     49505304         byte 4, "SPIN"
ffb6f     d09c             word                    SPINNER
                   
                   
                   ' | compile byte   || compile word   , compile long
ffb71     7c81             byte 1+im,      "|"
ffb73     d604             word                    CCOMP
ffb75     7c7c82           byte 2+im,      "||"
ffb78     d614             word                    WCOMP
ffb7a     2c81             byte 1+im,      ","
ffb7c     d61a             word                    LCOMP
ffb7e     5d575b83         byte 3+im,      "[W]"
ffb82     d5f0             word                    COMPW
ffb84     5d225b83         byte 3+im,      "[",$22,"]"
ffb88     d5c2             word                    COMPSTR
                   
ffb8a     4c554e05         byte 5, "NULL$"
ffb90     d558             word                    NULLSTR
ffb92     212402           byte 2, "$!"
ffb95     d55c             word                    STRST
ffb97     3d2402           byte 2, "$="
ffb9a     d566             word                    STREQ
                   
                   
                   ' DEFINITIONS
                   '
                   
ffb9c     524f4686         byte 6+im,      "FORGET"
ffba3     e174             word                    FORGET
ffba5     45524387         byte 7+im,      "CREATE$"
ffbad     d696             word                    CREATEWORD
ffbaf     45524386         byte 6+im,      "CREATE"
ffbb6     d6e2             word                    CREATE
ffbb8     52415683         byte 3+im,      "VAR"
ffbbc     d6f4             word                    _VAR
                   
ffbbe     62757083         byte 3+im,      "pub"
ffbc2     d736             word                    PUBDEF
ffbc4     69727083         byte 3+im,      "pri"
ffbc8     d742             word                    PRIDEF
ffbca     65727083         byte 3+im,      "pre"
ffbce     d73e             word                    PREDEF
ffbd0     646f6d86         byte 6+im,      "module"
ffbd7     d73a             word                    MODDEF
ffbd9     3a81             byte 1+im,      ":"
ffbdb     d72e             word                    NEWDEF
ffbdd     3b81             byte 1+im,      ";"
ffbdf     d75a             word                    ENDDEF
ffbe1     5b81             byte 1+im,      "["
ffbe3     d760             word                    UNDEF
ffbe5     2781             byte 1+im,      "'"
ffbe7     d66c             word                    ATICK
                   
ffbe9     3d3a82           byte 2+im,      ":="
ffbec     d6fa             word                    _CON9
ffbee     3d3d82           byte 2+im,      "=="
ffbf1     d70c             word                    _CONST
ffbf3     213d3d03         byte 3,         "==!"
ffbf7     d6f0             word                    CONST
ffbf9     494c4105         byte 5,         "ALIGN"
ffbff     d678             word                    _ALIGN
                   
ffc01     54414486         byte 6+im,      "DATCON"
ffc08     d71c             word                    _DATCON
                   
ffc0a     4c4c4105         byte 5,         "ALLOT"
ffc10     d626             word                    ALLOT
                   
ffc12     67726f03         byte 3,         "org"
ffc16     e348             word                    DATORG
ffc18     74796285         byte 5+im,      "bytes"
ffc1e     e366             word                    dbytes
ffc20     726f7785         byte 5+im,      "words"
ffc26     e362             word                    dwords
ffc28     6e6f6c85         byte 5+im,      "longs"
ffc2e     e35e             word                    dlongs
ffc30     74796284         byte 4+im,      "byte"
ffc35     e370             word                    dbyte
ffc37     726f7784         byte 4+im,      "word"
ffc3c     e374             word                    dword
ffc3e     6e6f6c84         byte 4+im,      "long"
ffc43     e378             word                    dlong
ffc45     73657203         byte 3,         "res"
ffc49     e356             word                    dres
                   
ffc4b     5d435b83         byte 3+im,      "[C]"
ffc4f     d768             word                    COMPILES
ffc51     41524784         byte 4+im,      "GRAB"
ffc56     d632             word                    GRAB
                   
                   
                   ' FIELDS ( NAME-FIELD  CODE-POINTER CODE-FIELD )
ffc58     41464e84         byte 4+im,      "NFA'"
ffc5d     d652             word                    _NFATICK
ffc5f     41504303         byte 3,         "CPA"
ffc63     d656             word                    NFACPA
ffc65     41464303         byte 3,         "CFA"
ffc69     d662             word                    NFACFA
                   
                   
                   ''      byte c, "TWICE"         +im
                   ''      word                    TWICE
                   
                   ' COMMENTS
ffc6b     5c81             byte 1+im,      "\"
ffc6d     e120             word                    COMMENT
ffc6f     2d2d2d83         byte 3+im,      "---"
ffc73     e120             word                    COMMENT
ffc75     2881             byte 1+im,      "("
ffc77     e138             word                    PAREN
ffc79     7b81             byte 1+im,      "{"
ffc7b     e152             word                    BRACE
ffc7d     7d81             byte 1+im,      "}"
ffc7f     006f             word                    _NOP
                   
                   ' CONDITIONAL COMPILATION ( conditionally ignore as comment )
                   
ffc81     4e464986         byte 6+im,      "IFNDEF"
ffc88     e14e             word                    IFNDEF
ffc8a     44464985         byte 5+im,      "IFDEF"
ffc90     e146             word                    IFDEF
                   
                   
ffc92     4c444904         byte 4, "IDLE"
ffc97     de24             word                    IDLE
                   
ffc99     45562e04         byte 4, ".VER"
ffc9e     e1f2             word                    PRTVER
ffca0     51415405         byte 5, "TAQOZ"
ffca6     e386             word                    _TAQOZ
ffca8     52455404         byte 4, "TERM"
ffcad     de9c             word                    TERMINAL
ffcaf     54554184         byte 4+im,      "AUTO"
ffcb4     de4a             word                    AUTORUN
                   
ffcb6     49505305         byte 5, "SPIRD"
ffcbc     0193             word                    SPIRD
ffcbe     49505306         byte 6, "SPIRDL"
ffcc5     0191             word                    SPIRDL
ffcc7     49505305         byte 5, "SPIWB"
ffccd     01ae             word                    SPIWR8
ffccf     49505305         byte 5, "SPIWR"
ffcd5     01b0             word                    SPIWR
ffcd7     49505305         byte 5, "SPICE"
ffcdd     01b7             word                    SPICE
ffcdf     49505305         byte 5, "SPIWC"
ffce5     01ac             word                    SPIWRC
ffce7     49505305         byte 5, "SPIWW"
ffced     01a9             word                    SPIWR16
ffcef     49505305         byte 5, "SPIWM"
ffcf5     01a6             word                    SPIWM
ffcf7     49505307         byte 7, "SPIPINS"
ffcff     ea76             word                    SPIPINS
ffd01     49505305         byte 5, "SPIRX"
ffd07     0186             word                    SPIRX
ffd09     49505306         byte 6, "SPITXE"
ffd10     0199             word                    SPITXE
ffd12     49505305         byte 5, "SPITX"
ffd18     019a             word                    SPITX
                   
ffd1a     4b4c4305         byte 5, "CLKIN"
ffd20     01c1             word                    CLKIN
ffd22     4b4c4306         byte 6, "CLKOUT"
ffd29     01b8             word                    CLKOUT
ffd2b     4f4c4305         byte 5, "CLOCK"
ffd31     01bc             word                    CLOCK
                   
                   
ffd33     4c535705         byte 5, "WSLED"
ffd39     eb7b             word                    WSLED
                   
ffd3b     49415704         byte 4, "WAIT"
ffd40     e9ba             word                    WAIT
                   
ffd42     4b4c4306         byte 6, "CLKDIV"
ffd49     d24c             word                    CLKDIV
ffd4b     53435206         byte 6, "RCSLOW"
ffd52     d25a             word                    RCSLOW
                   
                   
ffd54     42554806         byte 6, "HUBSET"
ffd5b     eb72             word                    _HUBSET
ffd5d     505702           byte 2, "WP"
ffd60     d242             word                    WP
ffd62     455702           byte 2, "WE"
ffd65     d23e             word                    WE
                   
                   
ffd67     4b4c4305         byte 5, "CLKHZ"
ffd6d     d210             word                    CLKHZ
ffd6f     4b4c4306         byte 6, "CLKMHZ"
ffd76     d21c             word                    CLKMHZ
                   
                   
ffd78     46554207         byte 7, "BUFFERS"
ffd80     d228             word                    BUFFERS
ffd82     4d4f5203         byte 3, "ROM"
ffd86     d22e             word                    ROM
ffd88     51524906         byte 6, "IRQVEC"
ffd8f     d234             word                    IRQVEC
                   
ffd91     52545004         byte 4, "PTRA"
ffd96     fff8             word                    w+PTRA
ffd98     52545004         byte 4, "PTRB"
ffd9d     fff9             word                    w+PTRB
ffd9f     52494404         byte 4, "DIRA"
ffda4     fffa             word                    w+DIRA
ffda6     52494404         byte 4, "DIRB"
ffdab     fffb             word                    w+DIRB
ffdad     54554f04         byte 4, "OUTA"
ffdb2     fffc             word                    w+OUTA
ffdb4     54554f04         byte 4, "OUTB"
ffdb9     fffd             word                    w+OUTB
ffdbb     414e4903         byte 3, "INA"
ffdbf     fffe             word                    w+INA
ffdc1     424e4903         byte 3, "INB"
ffdc5     ffff             word                    w+INB
                   
                   
                   {
                           byte 3, "blk"
                           word                    w+0
                           byte 3, "red"
                           word                    w+1
                           byte 3, "grn"
                           word                    w+2
                           byte 3, "yel"
                           word                    w+3
                           byte 3, "blu"
                           word                    w+4
                           byte 3, "mag"
                           word                    w+5
                           byte 3, "cyn"
                           word                    w+6
                           byte 3, "whi"
                           word                    w+7
                   }
                   
ffdc7     52524505         byte 5, "ERROR"
ffdcd     e00e             word                    ERROR
                   
                   
                   
                   
ffdcf     50465306         byte    6,"SFPINS"
ffdd6     e41c             word                    SFPINS
ffdd8     3f465303         byte    3,"SF?"
ffddc     e43c             word                    SFSTAT
ffdde     57465304         byte    4,"SFWE"
ffde3     e424             word                    SFWE
ffde5     49465305         byte    5,"SFINS"
ffdeb     e42a             word                    SFINS
ffded     57465304         byte    4,"SFWD"
ffdf2     e438             word                    SFWD
ffdf4     52465305         byte    5,"SFRDS"
ffdfa     e44e             word                    SFRDBLK
ffdfc     53465305         byte    5,"SFSID"
ffe02     e45c             word                    SFSID
ffe04     4a465305         byte    5,"SFJID"
ffe0a     e46c             word                    SFJID
ffe0c     45465305         byte    5,"SFER4"
ffe12     e480             word                    SFER4
ffe14     45465306         byte    6,"SFER32"
ffe1b     e488             word                    SFER32
ffe1d     45465306         byte    6,"SFER64"
ffe24     e48c             word                    SFER64
ffe26     45465307         byte    7,"SFERASE"
ffe2e     e490             word                    SFERALL
ffe30     57465306         byte    6,"SFWRPG"
ffe37     e4a8             word                    SFWRPAGE
                   
ffe39     43414206         byte    6,"BACKUP"
ffe40     e4c8             word                    BACKUP
ffe42     53455207         byte    7,"RESTORE"
ffe4a     e4b4             word                    RESTORE
ffe4c     52465305         byte    5,"SFRDS"
ffe52     e496             word                    SFRDS
                   
ffe54     57465305         byte    5,"SFWRS"
ffe5a     e4d4             word                    SFWRS
ffe5c     43465304         byte    4,"SFC@"
ffe61     e504             word                    SFCFETCH
ffe63     57465304         byte    4,"SFW@"
ffe68     e50c             word                    SFWFETCH
ffe6a     40465303         byte    3,"SF@"
ffe6e     e512             word                    SFFETCH
ffe70     465302           byte    2,"SF"
ffe73     e520             word                    SF
ffe75     46532e03 	byte    3,".SF"
ffe79     e472             word                    PRTSF
                   
                   
ffe7b     42445305 	byte	5,"SDBUF"
ffe81     e5ac     	word			SDBUF
ffe83     70647306 	byte	6,"sdpins"
ffe8a     e52e     	word			_sdpins
ffe8c     44532103 	byte	3,"!SD"
ffe90     e726     	word			INITSD
ffe92     58532103 	byte	3,"!SX"
ffe96     e68c     	word			INITSX
ffe98     3f445303 	byte	3,"SD?"
ffe9c     e5b2     	word			SDQ
ffe9e     444d4303 	byte	3,"CMD"
ffea2     e5fe     	word			CMD
ffea4     4d434104 	byte	4,"ACMD"
ffea9     e5f6     	word			ACMD
ffeab     64736303 	byte	3,"csd"
ffeaf     e54e     	word			csd
ffeb1     64696303 	byte	3,"cid"
ffeb5     e560     	word			cid
ffeb7     57445304 	byte	4,"SDWR"
ffebc     e75e     	word			SDWR
ffebe     52445305 	byte	5,"SDRDS"
ffec4     e800     	word			SDRDS
ffec6     57445305 	byte	5,"SDWRS"
ffecc     e852     	word			SDWRS
ffece     554c4605 	byte	5,"FLUSH"
ffed4     e79e     	word			FLUSH
ffed6     43455306 	byte	6,"SECTOR"
ffedd     e7b6     	word			SECTOR
ffedf     52445304 	byte	4,"SDRD"
ffee4     e7d0     	word			SDRD
ffee6     52445305 	byte	5,"SDRDS"
ffeec     e800     	word			SDRDS
ffeee     41445305 	byte	5,"SDADR"
ffef4     e876     	word			SDADR
ffef6     40445303 	byte	3,"SD@"
ffefa     e880     	word			SDFETCH
ffefc     21445303 	byte	3,"SD!"
fff00     e886     	word			SDSTORE
fff02     43445304 	byte	4,"SDC@"
fff07     e88c     	word			SDCFETCH
fff09     43445304 	byte	4,"SDC!"
fff0e     e892     	word			SDCSTORE
fff10     57445304 	byte	4,"SDW@"
fff15     e898     	word			SDWFETCH
fff17     445302   	byte	2,"SD"
fff1a     e89e     	word			SD
                   
                   
                   
fff1c     444e4503         byte 3, "END"
fff20     e3ae             word                    _END
                   
fff22     00000000         long    0
fff26              enddict
                   
fff26                      alignl
                   
                   
                   
                   
                   
                   
                   
                   
                   
                   {{
                   +------------------------------------------------------------------------------------------------------------------------------+
                   |                                                   TERMS OF USE: MIT License                                                  |
                   +------------------------------------------------------------------------------------------------------------------------------+
                   |Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation    |
                   |files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy,    |
                   |modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software|
                   |is furnished to do so, subject to the following conditions:                                                                   |
                   |                                                                                                                              |
                   |The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.|
                   |                                                                                                                              |
                   |THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE          |
                   |WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR         |
                   |COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,   |
                   |ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                         |
                   +------------------------------------------------------------------------------------------------------------------------------+
                   }}
